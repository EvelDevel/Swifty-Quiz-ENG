
//  Created by Евгений Никитин on 12.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

// MARK: 10 - Вопросы (id) с 901 по 1000

class PropertiesSet {
	static func getQuestions() -> [Question] {
		return [
			Question(question: ["The kind of properties that stores constant and variable values as part of an instance",
								"These properties are provided only by classes and structures",
								"Which properties store constant and variable values as part of an instance and are not provided by enumerations?"],
					 image: "",
					 optionA: "Stored properties",
					 optionB: "Computed properties",
					 optionC: "Private properties",
					 optionD: "Type properties",
					 questionId: 902,
					 helpText: "Properties associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures."),
			
			Question(question: ["Which option is the name of the properties associated with a whole type?",
								"How do we call properties associated the type itself?"],
					 image: "",
					 optionA: "Type properties",
					 optionB: "Data properties",
					 optionC: "Stored properties",
					 optionD: "",
					 questionId: 903,
					 helpText: "Stored and computed properties are usually associated with instances of a particular type. However, properties can also be associated with the type itself. Such properties are known as type properties."),
			
			Question(question: ["Can you define property observers to monitor changes in a property’s value?",
								"Can property observers be added to stored properties you define yourself?",
								"Can property observers be added to properties that a subclass inherits from its superclass?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 904,
					 helpText: "You can define property observers to monitor changes in a property’s value, which you can respond to with custom actions. Property observers can be added to stored properties you define yourself, and also to properties that a subclass inherits from its superclass."),
			
			Question(question: ["Constant stored properties introduced by this keyword",
								"Which keyword is used for constant stored properties?"],
					 image: "",
					 optionA: "let",
					 optionB: "var",
					 optionC: "func",
					 optionD: "struct",
					 questionId: 905,
					 helpText: "In its simplest form, a stored property is a constant or variable that is stored as part of an instance of a particular class or structure. Stored properties can be either variable stored properties (introduced by the var keyword) or constant stored properties (introduced by the let keyword)."),
			
			Question(question: ["Can you provide a default value for a stored property as part of its definition?",
								"Can you set and modify the initial value for a stored property during initialization?",
								"Can you provide a default value for a stored property as part of its definition if it's a constant stored property?",
								"Can you set and modify the initial value for a stored property during initialization even if it's a constant stored property?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 906,
					 helpText: "You can provide a default value for a stored property as part of its definition. You can also set and modify the initial value for a stored property during initialization. This is true even for constant stored properties."),
			
			Question(question: ["What is going to happen after running following code?"],
					 image: "Properties7",
					 optionA: "We'll get an error",
					 optionB: "We will change length value",
					 optionC: "Nothing is going to happen",
					 optionD: "",
					 questionId: 907,
					 helpText: "FixedRange instances have a variable stored property firstValue and a constant stored property length. In our example, the length property was initialized when we created a new range, which cannot be further modified since this property is constant."),
			
			Question(question: ["What is going to happen after executing following code?"],
					 image: "Properties9",
					 optionA: "We will change firstValue",
					 optionB: "We'll get an error",
					 optionC: "",
					 optionD: "",
					 questionId: 909,
					 helpText: "If you assign an instance of a reference type to a constant (class instance), then it can still change variable properties (var)."),
			
			Question(question: ["What will happen after following code is executed?"],
					 image: "Properties8",
					 optionA: "We'll get an error",
					 optionB: "We will change firstValue",
					 optionC: "",
					 optionD: "",
					 questionId: 908,
					 helpText: "If you create an instance of a structure and assign that instance to a constant, you cannot modify the instance’s properties, even if they were declared as variable properties. Because rangeOfFourItems is declared as a constant (with the let keyword), it is not possible to change its firstValue property, even though firstValue is a variable property. This behavior is due to structures being value types. When an instance of a value type is marked as a constant, so are all of its properties."),
			
			Question(question: ["The property whose initial value is not calculated until the first time it is used",
								"If there’s a special stored property type whose initial value is not calculated until the first time it is used, how is it called?"],
					 image: "",
					 optionA: "Lazy stored property",
					 optionB: "Stored property",
					 optionC: "Passive stored property",
					 optionD: "",
					 questionId: 910,
					 helpText: "A lazy stored property is a property whose initial value is not calculated until the first time it is used. You indicate a lazy stored property by writing the lazy modifier before its declaration."),
			
			Question(question: ["You indicate a lazy stored property by writing this modifier",
								"What modifier indicates a stored property whose initial value is calculated only when it is used for the first time?"],
					 image: "",
					 optionA: "lazy",
					 optionB: "delayed",
					 optionC: "passive",
					 optionD: "slow",
					 questionId: 911,
					 helpText: "You indicate a lazy stored property by writing the lazy modifier before its declaration."),
			
			Question(question: ["How do we need to declare a lazy property?",
								"We need to declare a lazy stored property ..."],
					 image: "",
					 optionA: "As a variable (var)",
					 optionB: "As a constant (let)",
					 optionC: "It doesn't matter",
					 optionD: "",
					 questionId: 912,
					 helpText: "You must always declare a lazy property as a variable (with the var keyword), because its initial value might not be retrieved until after instance initialization completes. Constant properties must always have a value before initialization completes, and therefore cannot be declared as lazy."),
			
			Question(question: ["When can lazy properties be useful?"],
					 image: "",
					 optionA: "If you need to avoid unnecessary initialization",
					 optionB: "If you need instant initialization",
					 optionC: "If you need partial initialization",
					 optionD: "",
					 questionId: 913,
					 helpText: "Lazy properties are useful when the initial value for a property is dependent on outside factors whose values are not known until after an instance’s initialization is complete. Lazy properties are also useful when the initial value for a property requires complex or computationally expensive setup that should not be performed unless or until it is needed."),
			
			Question(question: ["Does Swift ensures that a lazy property will be initialized only once, if it's accessed by multiple threads simultaneously (and the property has not yet been initialized)?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 914,
					 helpText: "If a property marked with the lazy modifier is accessed by multiple threads simultaneously and the property has not yet been initialized, there’s no guarantee that the property will be initialized only once."),
			
			Question(question: ["The properties that don't actually store a value",
								"This kind of properties provides a getter and an optional setter to retrieve and set other properties and values indirectly"],
					 image: "",
					 optionA: "Computed properties",
					 optionB: "Calculated properties",
					 optionC: "Stored properties",
					 optionD: "",
					 questionId: 915,
					 helpText: "In addition to stored properties, classes, structures, and enumerations can define computed properties, which do not actually store a value. Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly."),
			
			Question(question: ["If a computed property’s setter doesn’t define a name for the new value to be set, this is the name it gets by default"],
					 image: "",
					 optionA: "newValue",
					 optionB: "new",
					 optionC: "value",
					 optionD: "",
					 questionId: 916,
					 helpText: "If a computed property’s setter doesn’t define a name for the new value to be set, a default name of newValue is used."),
			
			Question(question: ["How a computed property with a getter but no setter called?",
								"The property that can be accessed through dot syntax, but cannot be set to a different value (a property with no setter)?"],
					 image: "",
					 optionA: "A read-only computed property",
					 optionB: "A write-only computed property",
					 optionC: "Constant computed property",
					 optionD: "Variable computed property",
					 questionId: 917,
					 helpText: "A computed property with a getter but no setter is known as a read-only computed property. A read-only computed property always returns a value, and can be accessed through dot syntax, but cannot be set to a different value."),
			
			Question(question: ["How do you declare computed properties—including read-only computed properties?",
								"You must declare computed properties—including read-only computed properties ..."],
					 image: "",
					 optionA: "As variable properties (var)",
					 optionB: "As constant properties (let)",
					 optionC: "It doesn't matter",
					 optionD: "",
					 questionId: 918,
					 helpText: "You must declare computed properties—including read-only computed properties—as variable properties with the var keyword, because their value is not fixed. The let keyword is only used for constant properties, to indicate that their values cannot be changed once they are set as part of instance initialization."),
			
			Question(question: ["Can we simplify the declaration of a read-only computed property by removing the get keyword and its braces"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "Only removing the get keyword",
					 optionD: "Only removing its braces { }",
					 questionId: 919,
					 helpText: "You can simplify the declaration of a read-only computed property by removing the get keyword and its braces."),
			
			Question(question: ["What will we get to the console after running the following code?"],
					 image: "Properties20",
					 optionA: "40.0",
					 optionB: "40",
					 optionC: "We'll get an error",
					 optionD: "",
					 questionId: 920,
					 helpText: "Correct answer: 40.0. This example defines a new structure called Cuboid, which represents a 3D rectangular box with width, height, and depth properties. This structure also has a read-only computed property called volume, which calculates and returns the current volume of the cuboid. It doesn’t make sense for volume to be settable, because it would be ambiguous as to which values of width, height, and depth should be used for a particular volume value. Nonetheless, it is useful for a Cuboid to provide a read-only computed property to enable external users to discover its current calculated volume."),
			
			Question(question: ["Will the property observers be called every time a property’s value is set, even if the new value is the same as the property’s current value?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 921,
					 helpText: "Property observers are called every time a property’s value is set, even if the new value is the same as the property’s current value."),
			
			Question(question: ["Pick the correct pair of property observers"],
					 image: "",
					 optionA: "willSet and didSet",
					 optionB: "set and get",
					 optionC: "willSet and didGet",
					 optionD: "willGet and didSet",
					 questionId: 923,
					 helpText: "You have the option to define either or both of these observers on a property: willSet is called just before the value is stored. didSet is called immediately after the new value is stored."),
			
			Question(question: ["... observer is called just before the value is stored"],
					 image: "",
					 optionA: "willSet",
					 optionB: "didSet",
					 optionC: "get",
					 optionD: "set",
					 questionId: 924,
					 helpText: "willSet is called just before the value is stored."),
			
			Question(question: ["... observer is called immediately after the new value is stored"],
					 image: "",
					 optionA: "didSet",
					 optionB: "willSet",
					 optionC: "get",
					 optionD: "set",
					 questionId: 925,
					 helpText: "didSet is called immediately after the new value is stored."),
			
			Question(question: ["If you don’t specify a name for a parameter as part of your willSet implementation, it will be ... by default"],
					 image: "",
					 optionA: "newValue",
					 optionB: "new",
					 optionC: "setValue",
					 optionD: "oldValue",
					 questionId: 926,
					 helpText: "If you implement a willSet observer, it’s passed the new property value as a constant parameter. You can specify a name for this parameter as part of your willSet implementation. If you don’t write the parameter name and parentheses within your implementation, the parameter is made available with a default parameter name of newValue."),
			
			Question(question: ["If you won't specify a name for parameter as part of your didSet implementation, it will be ... by default"],
					 image: "",
					 optionA: "oldValue",
					 optionB: "prevValue",
					 optionC: "old",
					 optionD: "newValue",
					 questionId: 927,
					 helpText: "If you implement a didSet observer, it’s passed a constant parameter containing the old property value. You can name the parameter or use the default parameter name of oldValue."),
			
			Question(question: ["Variables that are defined outside of any function, method, closure, or type context"],
					 image: "",
					 optionA: "Global variables",
					 optionB: "Local variables",
					 optionC: "",
					 optionD: "",
					 questionId: 928,
					 helpText: "Global variables are variables that are defined outside of any function, method, closure, or type context. Local variables are variables that are defined within a function, method, or closure context."),
			
			Question(question: ["Variables that are defined within a function, method, or closure context"],
					 image: "",
					 optionA: "Local variables",
					 optionB: "Global variables",
					 optionC: "",
					 optionD: "",
					 questionId: 929,
					 helpText: "Global variables are variables that are defined outside of any function, method, closure, or type context. Local variables are variables that are defined within a function, method, or closure context."),
			
			Question(question: ["Are global constants and variables always computed lazily?",
								"Global constants and variables are always computed lazily, in a similar manner to Lazy Stored Properties. Is that true?",
								"Unlike lazy stored properties, global constants and variables do not need to be marked with the lazy modifier. Is that true?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 930,
					 helpText: "Global constants and variables are always computed lazily, in a similar manner to Lazy Stored Properties. Unlike lazy stored properties, global constants and variables do not need to be marked with the lazy modifier. Local constants and variables are never computed lazily."),
			
			Question(question: ["Can we define properties that belong to the type itself, not to any one instance of that type?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 932,
					 helpText: "You can define properties that belong to the type itself, not to any one instance of that type. There will only ever be one copy of these properties, no matter how many instances of that type you create. These kinds of properties are called type properties. Type properties are useful for defining values that are universal to all instances of a particular type, such as a constant property that all instances can use (like a static constant in C), or a variable property that stores a value that is global to all instances of that type (like a static variable in C)."),
			
			Question(question: ["Properties that belong to the type itself",
								"Properties that belong to the type itself, not to any one instance of that type",
								"There will only ever be one copy of ... properties, no matter how many instances of a type you create"],
					 image: "",
					 optionA: "Type properties",
					 optionB: "Stored properties",
					 optionC: "Global properties",
					 optionD: "",
					 questionId: 931,
					 helpText: "You can define properties that belong to the type itself, not to any one instance of that type. There will only ever be one copy of these properties, no matter how many instances of that type you create. These kinds of properties are called type properties."),
			
			Question(question: ["Type properties are useful for the following"],
					 image: "",
					 optionA: "Defining universal values",
					 optionB: "Defining local values",
					 optionC: "Storing the internal values",
					 optionD: "",
					 questionId: 922,
					 helpText: "Type properties are useful for defining values that are universal to all instances of a particular type, such as a constant property that all instances can use (like a static constant in C), or a variable property that stores a value that is global to all instances of that type (like a static variable in C)."),
			
			Question(question: ["Do you always need to give stored type properties a default value?",
								"Unlike stored instance properties, you must always give stored type properties a default value. Is that correct?",
								"You must always give stored type properties a default value. Is that true?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 933,
					 helpText: "Unlike stored instance properties, you must always give stored type properties a default value. This is because the type itself does not have an initializer that can assign a value to a stored type property at initialization time."),
			
			Question(question: ["Are stored type properties lazily initialized on their first access?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 934,
					 helpText: "Stored type properties are lazily initialized on their first access. They are guaranteed to be initialized only once, even when accessed by multiple threads simultaneously, and they do not need to be marked with the lazy modifier."),
			
			Question(question: ["Are stored type properties guaranteed to be initialized only once, even when accessed by multiple threads simultaneously?",
								"Does Swift ensure that stored type properties are initialized only once?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "We must specify that behavior",
					 optionD: "",
					 questionId: 9341,
					 helpText: "Stored type properties are lazily initialized on their first access. They are guaranteed to be initialized only once, even when accessed by multiple threads simultaneously, and they do not need to be marked with the lazy modifier."),
			
			Question(question: ["Are stored type properties need to be marked with the lazy modifier?",
								"Do you need to mark stored type properties with the lazy modifier?",
								"We must mark stored type properties with the lazy modifier. Is that right?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 9342,
					 helpText: "Stored type properties are lazily initialized on their first access. They are guaranteed to be initialized only once, even when accessed by multiple threads simultaneously, and they do not need to be marked with the lazy modifier."),
			
			Question(question: ["You define type properties with the ... keyword"],
					 image: "",
					 optionA: "static",
					 optionB: "global",
					 optionC: "private",
					 optionD: "public",
					 questionId: 935,
					 helpText: "You define type properties with the static keyword."),
			
			Question(question: ["For computed type properties for class types, you can use ... keyword instead the static keyword?"],
					 image: "",
					 optionA: "class",
					 optionB: "type",
					 optionC: "public",
					 optionD: "",
					 questionId: 936,
					 helpText: "For computed type properties for class types, you can use the class keyword instead the static keyword to allow subclasses to override the superclass’s implementation."),
			
			Question(question: ["What value will we get to console?"],
					 image: "Properties37",
					 optionA: "true",
					 optionB: "false",
					 optionC: "We'll get compile-time error",
					 optionD: "",
					 questionId: 937,
					 helpText: "The didSet does not run in the initializer, so the initial value of p.point.x will be 5, which will be true when the program is executed.")
		]
	}
}
