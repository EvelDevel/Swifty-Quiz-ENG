
//  Created by Евгений Никитин on 12.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

// MARK: 11 - Вопросы (id) с 1001 по 1100

class MethodsSet {
	static func getQuestions() -> [Question] {
		return [
			Question(question: ["What is the difference between methods and functions?",
								"Functions differ from methods in this way",
								"The difference between methods and functions is that..."],
					 image: "",
					 optionA: "Methods associated with a particular type",
					 optionB: "Methods can't be define in enumerations",
					 optionC: "Methods are more global than functions",
					 optionD: "Functions associated with a particular type",
					 questionId: 1002,
					 helpText: "Methods are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type."),
			
			Question(question: ["Can classes define type methods?",
								"Can structures define type methods, which are associated with the type itself?",
								"Can enumerations define type methods, which are associated with the type itself?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1003,
					 helpText: "Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C."),
			
			Question(question: ["Can we define methods in classes, structures, and enumerations?",
								"We can define methods in structures and enumerations in Swift. Is that true?",
								"The major difference from Objective-C is that we can define methods in structures and enumerations. Is that true?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1004,
					 helpText: "The fact that structures and enumerations can define methods in Swift is a major difference from C and Objective-C. In Objective-C, classes are the only types that can define methods. In Swift, you can choose whether to define a class, structure, or enumeration, and still have the flexibility to define methods on the type you create."),
			
			Question(question: ["Does the instance methods have exactly the same syntax as functions?",
								"Instance methods have exactly the same syntax as functions. Is that true?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1005,
					 helpText: "Instance methods are functions that belong to instances of a particular class, structure, or enumeration. They support the functionality of those instances, either by providing ways to access and modify instance properties, or by providing functionality related to the instance’s purpose. Instance methods have exactly the same syntax as functions."),
			
			Question(question: ["Where you need to write an instance method?",
								"How can you write an instance method?"],
					 image: "",
					 optionA: "Within the opening and closing braces",
					 optionB: "In extension of the type it belongs to",
					 optionC: "In the name of that type",
					 optionD: "In the protocol of that type",
					 questionId: 1006,
					 helpText: "You write an instance method within the opening and closing braces of the type it belongs to."),
			
			Question(question: ["Does instance method have implicit access to all other methods and properties?",
								"An instance method has implicit access to all methods and properties of that type. Is that true?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "It has explicit access",
					 optionD: "",
					 questionId: 1007,
					 helpText: "Yes. An instance method has implicit access to all other instance methods and properties of that type."),
			
			/// Пожалуйста глянь вторую формулировку, тут я заменил can / can't
			
			Question(question: ["Can we call an instance method in isolation without an existing instance?",
								"An instance method can't be called on a specific instance of the type it belongs to. Is that true?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 1008,
					 helpText: "An instance method can be called only on a specific instance of the type it belongs to. It cannot be called in isolation without an existing instance."),
			
			Question(question: ["You can call instance methods with that syntax",
								"With what syntax we cen call instance methods?"],
					 image: "",
					 optionA: "dot syntax",
					 optionB: "Syntax of closure",
					 optionC: "syntax of Tuple declaration",
					 optionD: "Subscripts syntax",
					 questionId: 1009,
					 helpText: "You call instance methods with the same dot syntax as properties."),
			
			Question(question: ["Can function parameters have both a name and an argument label?",
								"Function parameters can have both a name and an argument label. Is that true?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No, only name",
					 optionC: "No, only argument label",
					 optionD: "",
					 questionId: 1010,
					 helpText: "Function parameters can have both a name (for use within the function’s body) and an argument label (for use when calling the function). The same is true for method parameters, because methods are just functions that are associated with a type."),
			
			Question(question: ["In what case we need to use the self property?",
								"The implicit property self you should use..."],
					 image: "",
					 optionA: "To refer to the current instance",
					 optionB: "To refer to other instances",
					 optionC: "",
					 optionD: "",
					 questionId: 1011,
					 helpText: "Every instance of a type has an implicit property called self, which is exactly equivalent to the instance itself. You use the self property to refer to the current instance within its own instance methods."),
			
			/// Со второй тут кажется намудрил
			
			Question(question: ["Do we need to write self in your code very often?",
								"Does Swift requires you to explicitly write self every time when you reffering to a method?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 1012,
					 helpText: "In practice, you don’t need to write self in your code very often. If you don’t explicitly write self, Swift assumes that you are referring to a property or method of the current instance whenever you use a known property or method name within a method. The main exception to this rule occurs when a parameter name for an instance method has the same name as a property of that instance. In this situation, the parameter name takes precedence, and it becomes necessary to refer to the property in a more qualified way. You use the self property to distinguish between the parameter name and the property name."),
			
			Question(question: ["Do we need to use the self property, when a parameter name for an instance method has the same name as a property of that instance?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1013,
					 helpText: "When a parameter name for an instance method has the same name as a property of that instance, the parameter name takes precedence, and it becomes necessary to refer to the property in a more qualified way. You use the self property to distinguish between the parameter name and the property name."),
			
			Question(question: ["Structures and enumerations are..."],
					 image: "",
					 optionA: "value types",
					 optionB: "reference type",
					 optionC: "",
					 optionD: "",
					 questionId: 1014,
					 helpText: "Structures and enumerations are value types."),
			
			/// Если будет желание - добавь сюда третью формулировку, я удалил одну потому что не осилил
			
			Question(question: ["If you need to modify the properties of your structure within a particular method, you can that keyword",
								"What method can mutate (that is, change) its properties from within the method?"],
					 image: "",
					 optionA: "mutating",
					 optionB: "static",
					 optionC: "public",
					 optionD: "private",
					 questionId: 1015,
					 helpText: "If you need to modify the properties of your structure or enumeration within a particular method, you can opt in to mutating behavior for that method. The method can then mutate (that is, change) its properties from within the method, and any changes that it makes are written back to the original structure when the method ends. The method can also assign a completely new instance to its implicit self property, and this new instance will replace the existing one when the method ends."),
			
			Question(question: ["Can you call a mutating method on a constant of structure type?",
								"You can call a mutating method on a constant of structure type. Is that true?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "Only if its properties are variables",
					 optionD: "",
					 questionId: 1016,
					 helpText: "You cannot call a mutating method on a constant of structure type, because its properties cannot be changed, even if they are variable properties."),
			
			Question(question: ["Can mutating methods assign an entirely new instance to the implicit self property?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1017,
					 helpText: "Mutating methods can assign an entirely new instance to the implicit self property."),
			
			Question(question: ["Can mutating methods for enumerations set the implicit self parameter to be a different case from the same enumeration?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1018,
					 helpText: "Mutating methods for enumerations can set the implicit self parameter to be a different case from the same enumeration."),
			
			Question(question: ["You can define type methods with this keyword",
								"Type methods can be defined through this keyword",
								"You can define methods that are called by the type itself (type methods), which keyword should you use?"],
					 image: "",
					 optionA: "static",
					 optionB: "class",
					 optionC: "public",
					 optionD: "fileprivate",
					 questionId: 1019,
					 helpText: "You can define methods that are called on the type itself. These kinds of methods are called type methods. You indicate type methods by writing the static keyword before the method’s func keyword. Classes can use the class keyword instead, to allow subclasses to override the superclass’s implementation of that method."),
			
			Question(question: ["Can you define type-level methods for classes?",
								"Can you define type-level methods for structures?",
								"Can you define type-level methods for enumerations?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1020,
					 helpText: "In Objective-C, you can define type-level methods only for Objective-C classes. In Swift, you can define type-level methods for all classes, structures, and enumerations. Each type method is explicitly scoped to the type it supports."),
			
			Question(question: ["Can we use dot suntax to call type methods?",
								"Type methods are called with dot syntax, like instance methods. Is that true?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1021,
					 helpText: "Type methods are called with dot syntax, like instance methods. However, you call type methods on the type, not on an instance of that type."),
			
			Question(question: ["How many methods does Counter have?"],
					 image: "Methods22",
					 optionA: "Two",
					 optionB: "Three",
					 optionC: "One",
					 optionD: "Counter doesn't have methods",
					 questionId: 1022,
					 helpText: "Correct answer: Two - increment() and increment(by amount: Int). All functions belonging to a particular class are methods."),
			
			/// Пожалуйста проверь хелп-текст 1023 - 1024, они самописные
			
			Question(question: ["Will we get message to console?"],
					 image: "Methods23",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1023,
					 helpText: "Correct answer: Yes. We set the x property to 4.0, and when we call our instance method, we check if 4.0 is greater than 1.0, and when we get true, and in the line \"if somePoint.isToTheRightOf(x: 1.0)\" we check exactly that, we output our message to the console."),
			
			Question(question: ["What will we get if in \"return self.x > x\" we'll remove \"self\"?"],
					 image: "Methods23",
					 optionA: "print will not work",
					 optionB: "print will work",
					 optionC: "Compile-time error",
					 optionD: "",
					 questionId: 1024,
					 helpText: "Correct answer: print won't work. If we remove self, then the method will consider that we are comparing the input parameter x with the same input parameter x, and this comparison operation cannot return true. And since the result of our method will be false, print will not work."),
			
			Question(question: ["Can we set the implicit self like this?"],
					 image: "Methods25",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1025,
					 helpText: "Mutating methods for enumerations can set the implicit self parameter to be a different case from the same enumeration. This example defines an enumeration for a three-state switch. The switch cycles between three different power states (off, low and high) every time its next() method is called.")
		]
	}
}
