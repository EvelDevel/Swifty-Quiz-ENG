
//  Created by Евгений Никитин on 10.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

// MARK: 04 - Вопросы (id) с 301 по 400

class CollectionTypesSet {
	static func getQuestions() -> [Question] {
		return [
			Question(question: ["How many basic collection types does Swift provide?",
								"Swift supports exactly that many basic collection types",
								"How many collection types are supported in Swift?"],
					 image: "",
					 optionA: "Three",
					 optionB: "Two",
					 optionC: "Four",
					 optionD: "",
					 questionId: 301,
					 helpText: "Swift provides three primary collection types, known as arrays, sets, and dictionaries, for storing collections of values."),
			
			Question(question: ["Ordered collection of values",
								"Collection with ordered values of the same type",
								"Ordered values combined into a collection"],
					 image: "",
					 optionA: "Array",
					 optionB: "Dictionary",
					 optionC: "Set",
					 optionD: "",
					 questionId: 302,
					 helpText: "Arrays are ordered collections of values. An array stores values of the same type in an ordered list. The same value can appear in an array multiple times at different positions."),
			
			Question(question: ["Unordered collection of unique values",
								"Unique values grouped in an unordered collection",
								"A collection of unordered unique values"],
					 image: "",
					 optionA: "Set",
					 optionB: "Array",
					 optionC: "Dictionary",
					 optionD: "",
					 questionId: 303,
					 helpText: "Sets are unordered collections of unique values."),
			
			Question(question: ["Unordered collection storing key-value pairs",
								"A collection that stores unordered key-value pairs",
								"Unordered key-value pairs are stored in this collection"],
					 image: "",
					 optionA: "Dictionary",
					 optionB: "Set",
					 optionC: "Array",
					 optionD: "",
					 questionId: 304,
					 helpText: "Dictionaries are unordered collections of key-value associations. A dictionary stores associations between keys of the same type and values of the same type in a collection with no defined ordering. Each value is associated with a unique key, which acts as an identifier for that value within the dictionary. Unlike items in an array, items in a dictionary do not have a specified order. You use a dictionary when you need to look up values based on their identifier, in much the same way that a real-world dictionary is used to look up the definition for a particular word."),
			
			Question(question: ["Which type of collection is on the image?"],
					 image: "Collections5",
					 optionA: "Dictionary",
					 optionB: "Set",
					 optionC: "Array",
					 optionD: "",
					 questionId: 305,
					 helpText: "This is a dictionary, a collection of key-values pairs."),
			
			Question(question: ["Can we mistakenly insert a value of the wrong type into a collection?",
								"Does Swift allow using values of several types in an array?",
								"Is it possible to insert a value of the wrong type into the dictionary?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 306,
					 helpText: "Arrays, sets, and dictionaries in Swift are always clear about the types of values and keys that they can store. This means that you cannot insert a value of the wrong type into a collection by mistake. It also means you can be confident about the type of values you will retrieve from a collection."),
			
			Question(question: ["If an array or dictionary is assigned to a variable, can we modify it?",
								"Can we modify a dictionary or array if it assigned to a variable?",
								"Is it possible to change the dictionary if we assigned it to a variable during definition?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "Only adding elements is allowed",
					 optionC: "Only removing elements is allowed",
					 optionD: "No",
					 questionId: 307,
					 helpText: "If you create an array, a set, or a dictionary, and assign it to a variable, the collection that is created will be mutable. This means that you can change (or mutate) the collection after it is created by adding, removing, or changing items in the collection. If you assign an array, a set, or a dictionary to a constant, that collection is immutable, and its size and contents cannot be changed."),
			
			Question(question: ["What type of collection does the image show?",
								"What type of collection is shown in the image?"],
					 image: "Collections8",
					 optionA: "Array",
					 optionB: "Set",
					 optionC: "Dictionary",
					 optionD: "",
					 questionId: 308,
					 helpText: "The image shows an Array, an ordered collection of values available by their indexes."),
			
			Question(question: ["What type of collection is represented in the image?",
								"What type of collection is shown in the image?"],
					 image: "Collections9",
					 optionA: "Set",
					 optionB: "Array",
					 optionC: "Dictionary",
					 optionD: "",
					 questionId: 309,
					 helpText: "This is a set. Sets are unordered collections of unique values."),
			
			Question(question: ["If a collection is assigned to a constant, can we modify it?",
								"Can we modify a dictionary or an array if it is assigned to a constant?"],
					 image: "",
					 optionA: "No",
					 optionB: "Only removing elements",
					 optionC: "Yes",
					 optionD: "",
					 questionId: 310,
					 helpText: "If you assign an array, a set, or a dictionary to a constant, that collection is immutable, and its size and contents cannot be changed. It is good practice to create immutable collections in all cases where the collection does not need to change. Doing so makes it easier for you to reason about your code and enables the Swift compiler to optimize the performance of the collections you create."),
			
			Question(question: ["How do you write the type of a Swift array in full form?",
								"The full form of the Swift’s array type is ... ",
								"Which of these is the full array notation in Swift?"],
					 image: "",
					 optionA: "Array<Element>",
					 optionB: "[Element]",
					 optionC: "Array(Element)",
					 optionD: "",
					 questionId: 311,
					 helpText: "The type of a Swift array is written in full as Array<Element>, where Element is the type of values the array is allowed to store. You can also write the type of an array in shorthand form as [Element]. Although the two forms are functionally identical, the shorthand form is preferred."),
			
			Question(question: ["How do you write an array shorthand form in Swift?",
								"A shorthand form of writing an array in Swift is ... ",
								"The shorthand for Swift’s arrays"],
					 image: "",
					 optionA: "[Element]",
					 optionB: "Array<Element>",
					 optionC: "[Element]()",
					 optionD: "Array(Element)[]",
					 questionId: 312,
					 helpText: "You can write the type of an array in shorthand form as [Element]. Although the two forms (Array<Element> and [Element]) are functionally identical, the shorthand form is preferred and is used throughout this guide when referring to the type of an array."),
			
			Question(question: ["How can you create an empty array using initializer syntax?",
								"How can you create an empty array?",
								"An empty array is initialized this way"],
					 image: "",
					 optionA: "var someInts = [Int]()",
					 optionB: "var someInts = (Int)[]",
					 optionC: "var someInts = [Int()]",
					 optionD: "",
					 questionId: 313,
					 helpText: "You can create an empty array of a certain type using initializer syntax: var someInts = [Int]()"),
			
			Question(question: ["A way to create an array with no elements using an empty array literal",
								"How can you create an empty array?",
								"This is how an empty array can be initialized"],
					 image: "",
					 optionA: "var array: [String] = []",
					 optionB: "var array: String = []",
					 optionC: "",
					 optionD: "",
					 questionId: 314,
					 helpText: "As an alternative to the initializer syntax, you can create an empty array using an empty array literal, written as [ ] (an empty pair of square brackets)."),
			
			Question(question: ["What will be the type of the ints array and what will it contain?",
								"Choose the correct type and content of ints collection",
								"Select the type and content the ints array will have"],
					 image: "Collections15",
					 optionA: "[Double] and [0.0, 0.0, 0.0]",
					 optionB: "[Int] and [0, 0, 0]",
					 optionC: "[Double] and [0, 0, 0]",
					 optionD: "[Int] and [0.0, 0.0, 0.0]",
					 questionId: 315,
					 helpText: "Since the type is not specified, Swift will set the floating-point array to [Double]. Also the array’s initializer specifies that the array should contain 0.0, repeated three times. The correct answer would be [Double], [0.0, 0.0, 0.0]. Swift’s Array type provides an initializer for creating an array of a certain size with all of its values set to the same default value. You pass this initializer a default value of the appropriate type (called repeating): and the number of times that value is repeated in the new array (called count)"),
			
			Question(question: ["How can we create a new array by concatenating two existing arrays with compatible types?",
								"How can we create a new array from two existing ones (if their types are compatible)?"],
					 image: "",
					 optionA: "With addition operator (+)",
					 optionB: "With interpolation",
					 optionC: "With .insert method",
					 optionD: "Logical operator &&",
					 questionId: 316,
					 helpText: "You can create a new array by adding together two existing arrays with compatible types with the addition operator (+). The new array’s type is inferred from the type of the two arrays you add together. You can also add one array to another via firstArray.append(contentsOf: secondArray)."),
			
			Question(question: ["Which option shows how we can create an array using array literal syntax?"],
					 image: "",
					 optionA: "var nums: [Int] = [0, 1, 2, 3]",
					 optionB: "var nums: Int = [0, 1, 2, 3]",
					 optionC: "var nums: [Int] = 0, 1, 2, 3",
					 optionD: "var nums: [Int](0, 1, 2, 3)",
					 questionId: 317,
					 helpText: "You can also initialize an array with an array literal, which is a shorthand way to write one or more values as an array collection. An array literal is written as a list of values, separated by commas, surrounded by a pair of square brackets: [value 1, value 2, value 3]. Example: var number: [Int] = [1, 2, 3, 4, 5]."),
			
			Question(question:["Do you have to write the type of the array if you’re initializing it with an array literal containing values of the same type?",
							   "Is it possible initialize the following array in a shorter form by omitting array type: var array: [Int] = [1, 2]?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 318,
					 helpText: "Thanks to Swift’s type inference, you don’t have to write the type of the array if you’re initializing it with an array literal containing values of the same type, for example var array: [Int] = [1, 2]. The initialization could have been written in a shorter form instead: var array = [1, 2]. Because all values in the array literal are of the same type, Swift can infer that [Int] is the correct type to use for the variable."),
			
			Question(question: ["A quick way to get the number of elements of an array",
								"You can get the number of elements of an array through the ... property",
								"Which property returns the number of elements in an array?"],
					 image: "",
					 optionA: ".count",
					 optionB: ".sort()",
					 optionC: ".prefix()",
					 optionD: ".append()",
					 questionId: 319,
					 helpText: "To find out the number of items in an array, check its read-only count property."),
			
			Question(question: ["What will this code print out?"],
					 image: "Collections20",
					 optionA: "Array is empty",
					 optionB: "Array is not empty",
					 optionC: "Nothing",
					 optionD: "",
					 questionId: 320,
					 helpText: "Use the Boolean isEmpty property as a shortcut for checking whether the count property is equal to 0. In this example, we have an empty ‘array’ array, which means we will pass the check by the first condition and display \"Array is empty\""),
			
			Question(question: ["At what position the element is placed when added to the array via .append(_:)?",
								"Where exactly does the .append(_:) method called on an array add new items?",
								"If we add an element to the array via .append(_:), where will it be put?"],
					 image: "",
					 optionA: "To the end of an array",
					 optionB: "At the beginning of an array",
					 optionC: "In the middle",
					 optionD: "",
					 questionId: 321,
					 helpText: "You can add a new item to the end of an array by calling the array’s append(_:) method."),
			
			Question(question: ["What result will we get after running the code above?"],
					 image: "Collections22",
					 optionA: "We'll get an error",
					 optionB: "[0.1, 1.1, 1.2, 2.2, 3.4]",
					 optionC: "The array won't change",
					 optionD: "",
					 questionId: 322,
					 helpText: "You can add an array with one or more compatible (types) elements using the addition operator (+), but in this case we will run into an error because numbers is a constant."),
			
			Question(question: ["What will the numbers array contain after the code is executed?"],
					 image: "Collections23",
					 optionA: "[1.0, 2.0, 3.0, 4.0, 5.0]",
					 optionB: "[1.0, 2.0, 3, 4, 5]",
					 optionC: "[1, 2, 3, 4, 5]",
					 optionD: "[1.0, 2.0]",
					 questionId: 323,
					 helpText: "The correct answer is [1.0, 2.0, 3.0, 4.0, 5.0]. The addition assignment operator will add the values 3, 4, and 5 to this array, but since the numbers array is of type [Double], its values will be 3.0, 4.0, 5.0."),
			
			Question(question: ["How can you retrieve a value from an array using subscript syntax?"],
					 image: "",
					 optionA: "arrayName[1]",
					 optionB: "arrayName(0)",
					 optionC: "arrayName-2",
					 optionD: "arrayName.3",
					 questionId: 324,
					 helpText: "Retrieve a value from the array by using subscript syntax, passing the index of the value you want to retrieve within square brackets immediately after the name of the array. The first item in the array has an index of 0, not 1. Arrays in Swift are always zero-indexed."),
			
			Question(question: ["What elements will be in the numbers array after this code is executed?",
								"Select the final order of elements of the numbers array after executing the following code",
								"After executing the code above, what will be the order of elements in the numbers array?"],
					 image: "Collections25",
					 optionA: "[1.0, 2.0, 1.0, 4.0]",
					 optionB: "[1.0, 2.0, 3.0, 4.0]",
					 optionC: "[1.0, 2.0, 3.0, 1.0]",
					 optionD: "[1.0, 1.0, 3.0, 4.0]",
					 questionId: 325,
					 helpText: "You can use subscript syntax to change an existing value at a given index. The correct answer is [1.0, 2.0, 1.0, 4.0], since we are initializing a new value to the array element at index [2], starting at 0 this will be the third element (3.0)."),
			
			Question(question: ["What elements will the numbers array contain after this code is executed?",
								"Select how the elements of the numbers array will be ordered after the code above is executed",
								"Once the code is executed, what is the order of elements in the numbers array?"],
					 image: "Collections26",
					 optionA: "[1.0, 4.0, 5.0, 6.0]",
					 optionB: "[1.0, 4, 5, 6]",
					 optionC: "[1.0, 2.0, 3.0, 4.0]",
					 optionD: "[4.0, 5.0, 6.0, 4.0]",
					 questionId: 326,
					 helpText: "You can use subscript syntax to change a range of values at once, even if the replacement set of values has a different length than the range you are replacing. Correct answer: [1.0, 4.0, 5.0, 6.0], since we are changing values from 1 to 3 index, which is 2.0, 3.0, 4.0."),
			
			Question(question: ["What elements will be in the numbers array after this code is executed?",
								"Select the final order of elements of the numbers array after executing this code",
								"After executing the code, what will be the order of elements in the numbers array?"],
					 image: "Collections27",
					 optionA: "[1.0, 2.0, 11.0, 12.0, 13.0, 5.0]",
					 optionB: "[1.0, 2.0, 11.0, 12.0, 5.0]",
					 optionC: "[1.0, 2.0, 11.0, 12.0]",
					 optionD: "[1.0, 2.0, 11.0, 12.0, 13.0]",
					 questionId: 327,
					 helpText: "You can use subscript syntax to change a range of values at once, even if the replacement set of values has a different length than the range you are replacing. The correct answer is [1.0, 2.0, 11.0, 12.0, 13.0, 5.0], since we change the values from 2 to 3 index, which is 3.0, 4.0, but we are inserting three elements instead of the two deleted."),
			
			Question(question: ["Which method inserts an element into the array at a specified index?",
								"To insert an element at a specified index in the array you should use the ... method",
								"What method should you use to insert an element at a specified array index?"],
					 image: "",
					 optionA: "insert(_:at:)",
					 optionB: "append",
					 optionC: "add(_:at:)",
					 optionD: "remove(_ :at:)",
					 questionId: 328,
					 helpText: "To insert an item into the array at a specified index, call the array’s insert(_:at:) method."),
			
			Question(question: ["Which method removes an element from the array at a specified index?"],
					 image: "",
					 optionA: "remove(_ :at:)",
					 optionB: "append(_:at:)",
					 optionC: "add(_:at:)",
					 optionD: "erase(_:at:)",
					 questionId: 329,
					 helpText: "You remove an item from the array with the remove(at:) method. This method removes the item at the specified index and returns the removed item (although you can ignore the returned value if you do not need it)."),
			
			Question(question: ["What happens if you try to access or change the value of an index that is outside the existing bounds of the array?",
								"What will be the result of changing an index value that is outside the existing array boundaries?"],
					 image: "",
					 optionA: "Runtime error",
					 optionB: "We will get a nil",
					 optionC: "Nothing is going to happen",
					 optionD: "We'll get its last element",
					 questionId: 330,
					 helpText: "If you try to access or modify a value for an index that is outside of an array’s existing bounds, you will trigger a runtime error. You can check that an index is valid before using it by comparing it to the array’s count property. The largest valid index in an array is count - 1 because arrays are indexed from zero—however, when count is 0 (meaning the array is empty), there are no valid indexes."),
			
			Question(question: ["What elements will the array contain after this code is executed?",
								"Select which values will be contained in the array after insert and remove methods are executed?"],
					 image: "Collections30",
					 optionA: "[2, 3, 9, 4, 5]",
					 optionB: "[1, 2, 3, 9, 4, 5]",
					 optionC: "[1, 2, 3, 4, 5]",
					 optionD: "[1, 2, 3, 9, 4]",
					 questionId: 331,
					 helpText: "First numbers.insert (9, at: 3) adds a nine to the third index, that is, between a three and a four, then numbers.remove (at: 0) removes the one at index zero. The result is [2, 3, 9, 4, 5]."),
			
			Question(question: ["How can we remove one or more of the last elements of an array and return the remaining array?",
								"Which method will help you remove the last few values of an array, and return what's left?",
								"Choose a method that allows you to remove the last few elements of an array and return the rest"],
					 image: "",
					 optionA: ".dropLast()",
					 optionB: ".removeLast()",
					 optionC: ".remove(_ :at:)",
					 optionD: "",
					 questionId: 332,
					 helpText: "If you want to remove the last one or last few elements from an array, you can use the dropLast() method. In parentheses, you need to indicate the number of elements you want to remove. After implementing this method, dropLast() returns a subsequence containing all but the specified number of final elements."),
			
			Question(question: ["The method that we can use to remove and return the last element of an array?",
								"Which method removes the last element from an array and returns it?",
								"How can you remove the last element from an array and return it"],
					 image: "",
					 optionA: ".removeLast()",
					 optionB: ".remove(_ :at:)",
					 optionC: ".dropLast()",
					 optionD: ".deleteLast()",
					 questionId: 333,
					 helpText: "If you want to remove the final item from an array, use the removeLast() method rather than the remove(at:) method to avoid the need to query the array’s count property. Like the remove(at:) method, removeLast() returns the removed item."),
			
			Question(question: ["Choose the correct values the first and second variables after running the following code"],
					 image: "Collections34",
					 optionA: "[1, 2, 3] and 4",
					 optionB: "[1, 2, 3, 4] and 4",
					 optionC: "[1, 2, 3, 4, 5] and 5",
					 optionD: "[1, 2, 3, 4] and 5",
					 questionId: 334,
					 helpText: "The first expression var first = numbers.dropLast () will assign an array with the remaining elements - [1, 2, 3, 4] - to the variable. The second expression var second = first.removeLast () will assign the last element of the first array to the second variable, that is, the number 4, but it will remove it from the variable, so only [1, 2, 3] will remain there. Correct answer: [1, 2, 3] and 4." ),
			
			Question(question: ["The loop type that lets you iterate over the entire set of values in an array",
								"That array performs a simple iteration of the array, returning only elements without indices",
								"How can we iterate over an array to return only the non-indexed elements?"],
					 image: "",
					 optionA: "for-in loop",
					 optionB: "while loop",
					 optionC: "enumerated()",
					 optionD: "switch-case",
					 questionId: 335,
					 helpText: "You can iterate over the entire set of values in an array with the for-in loop. If you need the integer index of each item as well as its value, use the enumerated() method to iterate over the array instead. For each item in the array, the enumerated() method returns a tuple composed of an integer and the item."),
			
			Question(question: ["How can we iterate through an array to return tuples containing the index and the value at that index?",
								"This way, you can iterate over the array, returning tuples of values, consisting of the index and the value at this index"],
					 image: "",
					 optionA: "for-in and enumerated()",
					 optionB: "for-in and sorted()",
					 optionC: "repeat-while",
					 optionD: "while",
					 questionId: 336,
					 helpText: "If you need the integer index of each item as well as its value, use the enumerated() method to iterate over the array instead. For each item in the array, the enumerated() method returns a tuple composed of an integer and the item.  You can decompose the tuple into temporary constants or variables as part of the iteration: for (index, value) in someArray.enumerated() { print(index, value) }"),
			
			Question(question: ["What result will we get after running the code above?",
								"What will this code print out?"],
					 image: "Collections37",
					 optionA: "0 - 0.1 and 1 - 0.2",
					 optionB: "1 - 0.1 and 2 - 0.2",
					 optionC: "Nothing",
					 optionD: "index - value and index - value",
					 questionId: 337,
					 helpText: "Correct answer: 0 - 0.1 and 1 - 0.2."),
			
			Question(question: ["If it is critical that the values in a collection are not duplicated, what type will you use?",
								"What collection type would you use if it is important that the values inside are not repeated?",
								"What collection will you use to ensure that all its values are unique?"],
					 image: "",
					 optionA: "Set",
					 optionB: "Array",
					 optionC: "Dictionary",
					 optionD: "",
					 questionId: 338,
					 helpText: "A set stores distinct values of the same type in a collection with no defined ordering. You can use a set instead of an array when the order of items is not important, or when you need to ensure that an item only appears once."),
			
			Question(question: ["Which protocol all values stored in a set must conform to in the first place?",
								"To be able to be stored in a set all its values must conform to that protocol"],
					 image: "",
					 optionA: "Hashable",
					 optionB: "Equatable",
					 optionC: "Numerical",
					 optionD: "Computable",
					 questionId: 339,
					 helpText: "A type must be hashable in order to be stored in a set—that is, the type must provide a way to compute a hash value for itself. A hash value is an Int value that is the same for all objects that compare equally, such that if a == b, the hash value of a is equal to the hash value of b. You can use your own custom types as set value types or dictionary key types by making them conform to the Hashable protocol from the Swift standard library."),
			
			Question(question: ["How can you introduce a set type in Swift?",
								"This is how a set type is written in Swift",
								"How would you write a set type in Swift?"],
					 image: "",
					 optionA: "Set<ElementType>",
					 optionB: "Set(ElementType)",
					 optionC: "Set[ElementType]",
					 optionD: "(Set<ElementType>)",
					 questionId: 340,
					 helpText: "The type of a Swift set is written as Set<Element>, where Element is the type that the set is allowed to store. Unlike arrays, sets do not have an equivalent shorthand form."),
			
			Question(question: ["Do sets have a shorthand form?",
								"Do sets have an shorthand form? If so, which one?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes, (Set)",
					 optionC: "Yes, <Set>",
					 optionD: "",
					 questionId: 341,
					 helpText: "Unlike arrays, sets do not have an equivalent shorthand form. But you can initialize a set with an array literal, as a shorthand way to write one or more values as a set collection."),
			
			Question(question: ["How can you create an empty set of a certain type using initializer syntax?"],
					 image: "",
					 optionA: "= Set<String>()",
					 optionB: "= Array<String>[]",
					 optionC: "= Dictionary<String>()",
					 optionD: "",
					 questionId: 342,
					 helpText: "You can create an empty set of a certain type using initializer syntax: var letters = Set<Character>(). The type of the letters variable is inferred to be Set<Character>, from the type of the initializer."),
			
			Question(question: ["If the context already provides type information, can we create an empty set using an empty array literal?",
								"If we have an explicit type indication, can we cast existing set to empty set using an array literal (empty square brackets)?",
								"Can we create an empty set using an empty array literal (empty square brackets) if we the type for that set is specified explicitly?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 343,
					 helpText: "If the context already provides type information, such as a function argument or an already typed variable or constant, you can create an empty set (cast existed set to empty set) with an empty array literal: var letters = Set<Character>(); letters.insert(\"a\"); letters = []"),
			
			Question(question: ["Can we initialize a set with an array literal?",
								"Can we create a new set object with an array literal?"],
					 image: "",
					 optionA: "Yes, let ints: Set<Int> = [1, 2]",
					 optionB: "No, we can't",
					 optionC: "Yes, let ints: Set<Int>([1, 2])",
					 optionD: "",
					 questionId: 344,
					 helpText: "You can initialize a set with an array literal, as a shorthand way to write one or more values as a set collection. The example below creates a set called favoriteGenres to store String values: var favoriteGenres: Set<String> = [\"Rock\", \"Classical\", \"Hip hop\"]"),
			
			Question(question: ["Pick the full form of the set from the above"],
					 image: "Collections45",
					 optionA: "Set<String>",
					 optionB: "Character",
					 optionC: "String",
					 optionD: "Set<Character>",
					 questionId: 345,
					 helpText: "Any character is inferred as String, unless otherwise specified (Character). And since it's a set, the correct answer is Set<String>."),
			
			Question(question: ["If you try to remove an element of a set that the set doesn’t contain, what will happen?",
								"What will we get after removing a nonexistent element of a set using remove(_:)?",
								"If we try to remove an element from a set, but it turns out that the element is not there, what will we get?"],
					 image: "",
					 optionA: "nil",
					 optionB: "Its last element",
					 optionC: "Its first element",
					 optionD: "We'll get an error",
					 questionId: 346,
					 helpText: "You can remove an item from a set by calling the set’s remove(_:) method, which removes the item if it’s a member of the set, and returns the removed value, or returns nil if the set did not contain it."),
			
			Question(question: ["Can you iterate a set?",
								"Can we iterate over a set?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 347,
					 helpText: "You can iterate over the values in a set with a for-in loop."),
			
			Question(question: ["If we want to get values in specific order while iterating a set, what method should we use?"],
					 image: "",
					 optionA: ".sorted()",
					 optionB: ".sort()",
					 optionC: ".filter()",
					 optionD: ".flatMap()",
					 questionId: 34700,
					 helpText: "Swift’s Set type does not have a defined ordering. To iterate over the values of a set in a specific order, use the .sorted() method, which returns the set’s elements as an array sorted using the < operator."),
			
			Question(question: ["What method creates a new set that contains all of the values of two sets?"],
					 image: "Collections48",
					 optionA: "union(_:)",
					 optionB: "intersection(_:)",
					 optionC: "subtracting(_:)",
					 optionD: "symmetricDifference(_:)",
					 questionId: 348,
					 helpText: "Use the union(_:) method to create a new set with all of the values in both sets. If the values are repeated in the sets, they will not be repeated in the new set (all values within the set are unique). Suppose there is first set one = [0, 1, 2, 3, 4, 5], and there is a second set two = [3, 4, 5, 6], when executing one.union(two).sorted() we we get [0, 1, 2, 3, 4, 5, 6]."),
			
			Question(question: ["How to create a new set with only the values common to both sets?"],
					 image: "Collections49",
					 optionA: "intersection(_:)",
					 optionB: "union(_:)",
					 optionC: "subtracting(_:)",
					 optionD: "symmetricDifference(_:)",
					 questionId: 349,
					 helpText: "Use the intersection(_:) method to create a new set with only the values common to both sets. Let's say there is first set one = [0, 1, 2, 3, 4, 5], and there is a second set two = [3, 4, 5, 6], when executing one.intersection(two).sorted() we will get [3, 4, 5]."),
			
			Question(question: ["How can we create a new set with values not in the specified set?"],
					 image: "Collections50",
					 optionA: "subtracting(_:)",
					 optionB: "intersection(_:)",
					 optionC: "union(_:)",
					 optionD: "symmetricDifference(_:)",
					 questionId: 350,
					 helpText: "Use the subtracting(_:) method to create a new set with values not in the specified set. Let's say there is first set one = [0, 1, 2, 3, 4, 5], and there is a second set two = [3, 4, 5, 6], when doing one.subtracting(two).sorted() we will get [0, 1, 2]."),
			
			Question(question: ["Which method creates a new set with values in either set, but not both?"],
					 image: "Collections51",
					 optionA: "symmetricDifference(_:)",
					 optionB: "intersection(_:)",
					 optionC: "subtracting(_:)",
					 optionD: "union(_:)",
					 questionId: 351,
					 helpText: "Use the symmetricDifference(_:) method to create a new set with values in either set, but not both. Let's say there is first set one = [0, 1, 2, 3, 4, 5], and there is a second set two = [3, 4, 5, 6], when executing one.symmetricDifference(two).sorted() we will get [0, 1, 2, 6]."),
			
			Question(question: ["Which set is a superset?"],
					 image: "Collections52",
					 optionA: "a",
					 optionB: "b",
					 optionC: "c",
					 optionD: "There is no superset",
					 questionId: 352,
					 helpText: "The illustration depicts three sets—a, b and c—with overlapping regions representing elements shared among sets. Set a is a superset of set b, because a contains all elements in b."),
			
			Question(question: ["Which set is a subset?"],
					 image: "Collections52",
					 optionA: "b",
					 optionB: "a",
					 optionC: "c",
					 optionD: "There is no subset",
					 questionId: 353,
					 helpText: "The illustration depicts three sets—a, b and c—with overlapping regions representing elements shared among sets. Set a is a superset of set b, because a contains all elements in b. Conversely, set b is a subset of set a, because all elements in b are also contained by a."),
			
			Question(question: ["Which sets are disjoint?"],
					 image: "Collections52",
					 optionA: "b and c",
					 optionB: "a and b",
					 optionC: "c and a",
					 optionD: "There are no disjoint sets",
					 questionId: 354,
					 helpText: "The illustration above depicts three sets—a, b and c—with overlapping regions representing elements shared among sets. Set a is a superset of set b, because a contains all elements in b. Conversely, set b is a subset of set a, because all elements in b are also contained by a. Set b and set c are disjoint with one another, because they share no elements in common."),
			
			Question(question: ["How can we determine whether two sets contain all of the same values?"],
					 image: "",
					 optionA: "==",
					 optionB: "=",
					 optionC: "===",
					 optionD: "",
					 questionId: 35500,
					 helpText: "Use the “is equal” operator (==) to determine whether two sets contain all of the same values."),
			
			Question(question: ["Which method do we need to use to determine whether all of the values of a set are contained in the specified set?"],
					 image: "",
					 optionA: "isSubset(of:)",
					 optionB: "isSuperset(of:)",
					 optionC: "isStrictSubset(of:)",
					 optionD: "",
					 questionId: 355,
					 helpText: "Use the isSubset(of:) method to determine whether all of the values of a set are contained in the specified set. For example, let one: Set = [1, 2], let two: Set = [1, 2, 3, 4, 5], one.isSubset(of: two) will return true because all the values of set one are contained in the set two. In fact, we determine whether a set is a subset of the specified set."),
			
			Question(question: ["Which method do we need to use to determine whether a set contains all of the values in a specified set?"],
					 image: "",
					 optionA: "isSuperset(of:)",
					 optionB: "isSubset(of:)",
					 optionC: "isStrictSuperset(of:)",
					 optionD: "",
					 questionId: 356,
					 helpText: "Use the isSuperset(of:) method to determine whether a set contains all of the values in a specified set. For example, let one: Set = [1, 2], let two: Set = [1, 2, 3, 4, 5], two.isSuperset(of: one) will return true because all the values of set one are contained in the set two. In fact, we determine whether a set is a superset of the specified set."),
			
			Question(question: ["The type of a Swift dictionary is written in full as ..."],
					 image: "",
					 optionA: "Dictionary<KeyType, ValueType>",
					 optionB: "Dictionary<KeyType>, <ValueType>",
					 optionC: "Dictionary(KeyType, ValueType)",
					 optionD: "",
					 questionId: 357,
					 helpText: "The type of a Swift dictionary is written in full as Dictionary<KeyType, ValueType>, where KeyType is the type of value that can be used as a dictionary key, and ValueType is the type of value that the dictionary stores for those keys. A dictionary Key type must conform to the Hashable protocol, like a set’s value type."),
			
			Question(question: ["Does dictionary in Swift have a shorthand form?"],
					 image: "",
					 optionA: "Yes, [KeyType: ValueType]",
					 optionB: "No, KeyType: ValueType",
					 optionC: "Yes, <KeyType, ValueType>",
					 optionD: "No",
					 questionId: 358,
					 helpText: "You can also write the type of a dictionary in shorthand form as [Key: Value]. Although the two forms (full and shorthand) are functionally identical, the shorthand form is preferred."),
			
			Question(question: ["You can create an empty Dictionary of a certain type by using initializer syntax. How exactly can you do that?"],
					 image: "",
					 optionA: "var names = [Int: String]()",
					 optionB: "var names = Int: String[]",
					 optionC: "var names: [Int: String] = ()",
					 optionD: "var names: (Int: String) = []",
					 questionId: 359,
					 helpText: "As with arrays, you can create an empty Dictionary of a certain type by using initializer syntax: var namesOfIntegers = [Int: String](). This example creates an empty dictionary of type [Int: String] to store human-readable names of integer values. Its keys are of type Int, and its values are of type String."),
			
			Question(question: ["Pick an empty dictionary literal"],
					 image: "",
					 optionA: "[:]",
					 optionB: "[]",
					 optionC: "[](:)",
					 optionD: "{:}",
					 questionId: 360,
					 helpText: "If the context already provides type information, you can create an empty dictionary with an empty dictionary literal, which is written as [:] (a colon inside a pair of square brackets)."),
			
			Question(question: ["You can initialize a dictionary with a dictionary literal. How?"],
					 image: "",
					 optionA: "var a: [Int: String] = [0: \"Name\"]",
					 optionB: "var b: <Int: String> = ([0: \"Name\"])",
					 optionC: "var c: (Int: String)[0: \"Name\"]",
					 optionD: "",
					 questionId: 361,
					 helpText: "You can initialize a dictionary with a dictionary literal, which has a similar syntax to the array literal seen earlier. A dictionary literal is a shorthand way to write one or more key-value pairs as a Dictionary collection. A key-value pair is a combination of a key and a value. In a dictionary literal, the key and value in each key-value pair are separated by a colon. The key-value pairs are written as a list, separated by commas, surrounded by a pair of square brackets."),
			
			Question(question: ["What type will Swift assign to this dictionary?"],
					 image: "Collections62",
					 optionA: "[Double : String]",
					 optionB: "[Int : Character]",
					 optionC: "[Int : String]",
					 optionD: "[Float : String]",
					 questionId: 362,
					 helpText: "The correct answer is [Double: String], because the default type to any floating point number is Double, without explicitly specifying the type. The second part, the dictionary value is String."),
			
			Question(question: ["How can we add a new item to a dictionary with subscript syntax"],
					 image: "",
					 optionA: "dictionary[Key] = Value",
					 optionB: "dictionary.Key(Value)",
					 optionC: "dictionary.Key = [Value]",
					 optionD: "We can't modify dictionaries",
					 questionId: 363,
					 helpText: "You can add a new item to a dictionary with subscript syntax. Use a new key of the appropriate type as the subscript index, and assign a new value of the appropriate type. You can also use subscript syntax to change the value associated with a particular key. Correct answer: dictionary[Key] = Value."),
			
			Question(question: ["An alternative way to set or update a value for a specific dictionary key",
								"You can set or update the value for a specific dictionary key this way",
								"How can you set or update a value for a specific dictionary key without using subscript syntax?"],
					 image: "",
					 optionA: "updateValue(forKey:)",
					 optionB: "update(key:)",
					 optionC: "changeValue(forKey:)",
					 optionD: "change(key:)",
					 questionId: 364,
					 helpText: "As an alternative to subscripting, use a dictionary’s updateValue(_:forKey:) method to set or update the value for a particular key. Like the subscript examples above, the updateValue(_:forKey:) method sets a value for a key if none exists, or updates the value if that key already exists. Unlike a subscript, however, the updateValue(_:forKey:) method returns the old value after performing an update. This enables you to check whether or not an update took place."),
			
			Question(question: ["What does updateValue(_:forKey:) method return, in case no value is found?"],
					 image: "",
					 optionA: "nil",
					 optionB: "0",
					 optionC: "Optional type",
					 optionD: "",
					 questionId: 365,
					 helpText: "The updateValue(_:forKey:) method returns an optional value of the dictionary’s value type. For a dictionary that stores String values, for example, the method returns a value of type String?, or “optional String”. This optional value contains the old value for that key if one existed before the update, or nil if no value existed."),
			
			Question(question: ["If we try to access a nonexistent dictionary value through the subscript syntax, what do we get?",
								"What will be returned if we try to access a nonexistent dictionary value through the subscript syntax?"],
					 image: "",
					 optionA: "nil",
					 optionB: "Dictionary’s first value",
					 optionC: "Dictionary’s last value",
					 optionD: "We'll get an error",
					 questionId: 366,
					 helpText: "You can also use subscript syntax to retrieve a value from the dictionary for a particular key. Because it is possible to request a key for which no value exists, a dictionary’s subscript returns an optional value of the dictionary’s value type. If the dictionary contains a value for the requested key, the subscript returns an optional value containing the existing value for that key. Otherwise, the subscript returns nil."),
			
			Question(question: ["How can we remove a key-value pair from a dictionary using the subscript syntax?",
								"We can remove a key-value pair from a dictionary using the subscript syntax. How can we do that?",
								"How can you remove a key-value pair from a dictionary using subscript syntax?"],
					 image: "",
					 optionA: "dict[Key] = nil",
					 optionB: "dict[Key] = []",
					 optionC: "dict[Key] = 0",
					 optionD: "dict[Key].remove()",
					 questionId: 367,
					 helpText: "You can use subscript syntax to remove a key-value pair from a dictionary by assigning a value of nil for that key. Correct answer: dict[Key] = nil"),
			
			Question(question: ["The method that removes the key-value pair if it exists and returns the removed value, or returns nil if no value existed"],
					 image: "",
					 optionA: "removeValue(forKey:)",
					 optionB: "remove(forKey:)",
					 optionC: "removeValue(Key:)",
					 optionD: "deleteValue(forKey:)",
					 questionId: 368,
					 helpText: "You can remove a key-value pair from a dictionary with the removeValue(forKey:) method. This method removes the key-value pair if it exists and returns the removed value, or returns nil if no value existed."),
			
			Question(question: ["What is the value of the \"first\" constant?"],
					 image: "Collections69",
					 optionA: "9",
					 optionB: "10",
					 optionC: "8",
					 optionD: "",
					 questionId: 369,
					 helpText: "Numbers (indices) below 10 can be accompanied by zeros. This stylistic add-on is not strictly necessary, but it can sometimes make your code more readable."),
			
			Question(question: ["Collections defined by the standard library like arrays use an optimization to reduce the performance cost of copying. Within this approach, the elements are copied ...",
								"Swift optimizes the cost of copying of collections defined by the standard library like dictionaries or arrays. How does it copy the elements represented by those types?",
								"Collections defined by the standard library like strings use an optimization to reduce the performance cost of copying. Basically, Swift ensures that the elements are copied ..."],
					 image: "",
					 optionA: "Just before the modification",
					 optionB: "Async in the main thread",
					 optionC: "In the global thread",
					 optionD: "Immediately",
					 questionId: 370,
					 helpText: "Collections defined by the standard library like arrays, dictionaries, and strings use an optimization to reduce the performance cost of copying. Instead of making a copy immediately, these collections share the memory where the elements are stored between the original instance and any copies. If one of the copies of the collection is modified, the elements are copied just before the modification. The behavior you see in your code is always as if a copy took place immediately."),
			
			Question(question: ["What will we get in the console after running the following code?"],
					 image: "Subscripts15",
					 optionA: "Four",
					 optionB: "Three",
					 optionC: "Two",
					 optionD: "We'll get an error",
					 questionId: 371,
					 helpText: "Correct answer: Four. This example defines a variable called numberOfLegs and initializes it with a dictionary literal containing three key-value pairs. The type of the numberOfLegs dictionary is inferred to be [String: Int]. After creating the dictionary, this example uses subscript assignment to add a String key of \"bird\" and an Int value of 2 to the dictionary."),
			
			Question (question: ["What will the addNewBook() function return if our library already has a Book with the book.id we pass?"],
					  image: "Collections72",
					  optionA: "false",
					  optionB: "true",
					  optionC: "Book.id value",
					  optionD: "We will get an error",
					  questionId: 372,
					  helpText: "The updateValue(forKey:) method sets the value for the key if it doesn't exist, or updates the value if the key already exists. For example, for a dictionary that stores String values, the method will return a String? type, or an optional String. This optional value contains the old value for this key, if it existed before the update, or nil if the value did not exist. In our case, since the book is already in our library, the function will return us Book?, which means when comparing with nil (== nil) we get false."),
			
			Question(question: ["What will the deleteBook() function return if our library already has a Book with this book.id?"],
					 image: "Collections73",
					 optionA: "true",
					 optionB: "false",
					 optionC: "Value of book.id",
					 optionD: "",
					 questionId: 373,
					 helpText: "You can remove a key-value pair from a dictionary with the removeValue(forKey:) method. This method removes the key-value pair if it exists and returns the removed value, or returns nil if no value existed. In our case, the book is already in the library, which means that when deleted, its value will be returned to us. When we are comparing it for the inequality nil (!= nil), we get true."),
			
			Question(question: ["What will we get printed out to the console?"],
					 image: "Collections74",
					 optionA: "[1, 2, 3]",
					 optionB: "0, 1, 2",
					 optionC: "[2, 3, 4]",
					 optionD: "3",
					 questionId: 374,
					 helpText: "prefix(_ maxLength: Int) returns a subsequence, up to the specified maximum length, containing the initial elements of the collection, that's why we will get [1, 2, 3]."),
			
			Question(question: ["What will we get in the console?"],
					 image: "Collections75",
					 optionA: "[3, 4, 5]",
					 optionB: "[1, 2, 3]",
					 optionC: "[2, 3, 4]",
					 optionD: "3",
					 questionId: 375,
					 helpText: "suffix(_ maxLength: Int) returns a subsequence, up to the given maximum length, containing the final elements of the collection. That’s why we get [3, 4, 5]. If maxLength exceeds the number of elements of the original sequence, we will get all its elements."),
			
			Question(question: ["Which cities will be combined in the grouped dictionary according to the condition we used?"],
					 image: "Collections76",
					 optionA: "Shanghai and Seoul",
					 optionB: "Shanghai and Karachi",
					 optionC: "Shanghai and Beijing",
					 optionD: "Beijing and Karachi",
					 questionId: 376,
					 helpText: "Shanghai and Seoul. When initializing the dictionary, the input argument grouping is used, which is passed the analyzed keys of the cities dictionary as its value. After the initializer, a closure is specified, according to which the values are grouped (in this case, by the first character of the key)."),
			
			Question(question: ["Can we assign a default value to the dictionary element that will be returned when we are trying to access a key that does not exist?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 377,
					 helpText: "While using the subscript syntax to access elements of the dictionary, nil will be returned if you try to access a name that does not exist. You can specify a default value that will be returned when trying to access a nonexistent element, though. It can be done using the default property specified in the subscript [key, default: value]."),
			
			Question(question: ["What method is used for dictionary mapping?"],
					 image: "",
					 optionA: ".mapValues",
					 optionB: ".map",
					 optionC: ".filter",
					 optionD: ".reduce",
					 questionId: 378,
					 helpText: "Processing (mapping) the values of dictionary elements is done by using the mapValues(_ :) method, into which the closure is passed. Access is performed one by one to the value of each element of the dictionary. Returns a new dictionary containing the keys of this dictionary with the values transformed by the given closure."),
			
			Question(question: ["Do we get a new collection of elements as a result of filtering the dictionary through .filter?",
								"When filtering a dictionary through .filter, the old collection remains unchanged. Is that so?",
								"Is that correct that a new collection of the same type will be returned as a result of filtering a dictionary through .filter?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 379,
					 helpText: "Filtering the dictionary through .filter {} will return a new collection of the same type as the original one. The initial collection remains unchanged."),
			
			Question(question: ["What method can we use to combine two different sequences of values into one dictionary?",
								"This method will allow you to combine two sequences into a single dictionary",
								"With this method you can initialize two sequences of values into one dictionary"],
					 image: "",
					 optionA: "zip(_:_:)",
					 optionB: "Dictionary()",
					 optionC: "mapValues(_:)",
					 optionD: "Subscripting",
					 questionId: 380,
					 helpText: "zip(_:_:) creates a sequence of pairs built out of two underlying sequences, after which it should pass it to the uniqueKeysWithValues property of the Dictionary initializer. The resulting dictionary will contain the values of the first base collection as keys, and the elements of the second base collection as its values.")
		]
	}
	
	
	///
	
	
	static func getDemoQuestions() -> [Question] {
		return [
			Question(question: ["How many basic collection types does Swift provide?",
								"Swift supports exactly that many basic collection types",
								"How many collection types are supported in Swift?"],
					 image: "",
					 optionA: "Three",
					 optionB: "Two",
					 optionC: "Four",
					 optionD: "",
					 questionId: 301,
					 helpText: "Swift provides three primary collection types, known as arrays, sets, and dictionaries, for storing collections of values."),
			
			Question(question: ["Ordered collection of values",
								"Collection with ordered values of the same type",
								"Ordered values combined into a collection"],
					 image: "",
					 optionA: "Array",
					 optionB: "Dictionary",
					 optionC: "Set",
					 optionD: "",
					 questionId: 302,
					 helpText: "Arrays are ordered collections of values. An array stores values of the same type in an ordered list. The same value can appear in an array multiple times at different positions."),
			
			Question(question: ["Unordered collection of unique values",
								"Unique values grouped in an unordered collection",
								"A collection of unordered unique values"],
					 image: "",
					 optionA: "Set",
					 optionB: "Array",
					 optionC: "Dictionary",
					 optionD: "",
					 questionId: 303,
					 helpText: "Sets are unordered collections of unique values."),
			
			Question(question: ["Unordered collection storing key-value pairs",
								"A collection that stores unordered key-value pairs",
								"Unordered key-value pairs are stored in this collection"],
					 image: "",
					 optionA: "Dictionary",
					 optionB: "Set",
					 optionC: "Array",
					 optionD: "",
					 questionId: 304,
					 helpText: "Dictionaries are unordered collections of key-value associations. A dictionary stores associations between keys of the same type and values of the same type in a collection with no defined ordering. Each value is associated with a unique key, which acts as an identifier for that value within the dictionary. Unlike items in an array, items in a dictionary do not have a specified order. You use a dictionary when you need to look up values based on their identifier, in much the same way that a real-world dictionary is used to look up the definition for a particular word."),
			
			Question(question: ["Which type of collection is on the image?"],
					 image: "Collections5",
					 optionA: "Dictionary",
					 optionB: "Set",
					 optionC: "Array",
					 optionD: "",
					 questionId: 305,
					 helpText: "This is a dictionary, a collection of key-values pairs."),
			
			Question(question: ["Can we mistakenly insert a value of the wrong type into a collection?",
								"Does Swift allow using values of several types in an array?",
								"Is it possible to insert a value of the wrong type into the dictionary?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 306,
					 helpText: "Arrays, sets, and dictionaries in Swift are always clear about the types of values and keys that they can store. This means that you cannot insert a value of the wrong type into a collection by mistake. It also means you can be confident about the type of values you will retrieve from a collection."),
			
			Question(question: ["If an array or dictionary is assigned to a variable, can we modify it?",
								"Can we modify a dictionary or array if it assigned to a variable?",
								"Is it possible to change the dictionary if we assigned it to a variable during definition?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "Only adding elements is allowed",
					 optionC: "Only removing elements is allowed",
					 optionD: "No",
					 questionId: 307,
					 helpText: "If you create an array, a set, or a dictionary, and assign it to a variable, the collection that is created will be mutable. This means that you can change (or mutate) the collection after it is created by adding, removing, or changing items in the collection. If you assign an array, a set, or a dictionary to a constant, that collection is immutable, and its size and contents cannot be changed."),
			
			Question(question: ["What type of collection does the image show?",
								"What type of collection is shown in the image?"],
					 image: "Collections8",
					 optionA: "Array",
					 optionB: "Set",
					 optionC: "Dictionary",
					 optionD: "",
					 questionId: 308,
					 helpText: "The image shows an Array, an ordered collection of values available by their indexes."),
			
			Question(question: ["What type of collection is represented in the image?",
								"What type of collection is shown in the image?"],
					 image: "Collections9",
					 optionA: "Set",
					 optionB: "Array",
					 optionC: "Dictionary",
					 optionD: "",
					 questionId: 309,
					 helpText: "This is a set. Sets are unordered collections of unique values."),
			
			Question(question: ["If a collection is assigned to a constant, can we modify it?",
								"Can we modify a dictionary or an array if it is assigned to a constant?"],
					 image: "",
					 optionA: "No",
					 optionB: "Only removing elements",
					 optionC: "Yes",
					 optionD: "",
					 questionId: 310,
					 helpText: "If you assign an array, a set, or a dictionary to a constant, that collection is immutable, and its size and contents cannot be changed. It is good practice to create immutable collections in all cases where the collection does not need to change. Doing so makes it easier for you to reason about your code and enables the Swift compiler to optimize the performance of the collections you create."),
			
			Question(question: ["How do you write the type of a Swift array in full form?",
								"The full form of the Swift’s array type is ... ",
								"Which of these is the full array notation in Swift?"],
					 image: "",
					 optionA: "Array<Element>",
					 optionB: "[Element]",
					 optionC: "Array(Element)",
					 optionD: "",
					 questionId: 311,
					 helpText: "The type of a Swift array is written in full as Array<Element>, where Element is the type of values the array is allowed to store. You can also write the type of an array in shorthand form as [Element]. Although the two forms are functionally identical, the shorthand form is preferred."),
			
			Question(question: ["How do you write an array shorthand form in Swift?",
								"A shorthand form of writing an array in Swift is ... ",
								"The shorthand for Swift’s arrays"],
					 image: "",
					 optionA: "[Element]",
					 optionB: "Array<Element>",
					 optionC: "[Element]()",
					 optionD: "Array(Element)[]",
					 questionId: 312,
					 helpText: "You can write the type of an array in shorthand form as [Element]. Although the two forms (Array<Element> and [Element]) are functionally identical, the shorthand form is preferred and is used throughout this guide when referring to the type of an array."),
			
			Question(question: ["How can you create an empty array using initializer syntax?",
								"How can you create an empty array?",
								"An empty array is initialized this way"],
					 image: "",
					 optionA: "var someInts = [Int]()",
					 optionB: "var someInts = (Int)[]",
					 optionC: "var someInts = [Int()]",
					 optionD: "",
					 questionId: 313,
					 helpText: "You can create an empty array of a certain type using initializer syntax: var someInts = [Int]()"),
			
			Question(question: ["A way to create an array with no elements using an empty array literal",
								"How can you create an empty array?",
								"This is how an empty array can be initialized"],
					 image: "",
					 optionA: "var array: [String] = []",
					 optionB: "var array: String = []",
					 optionC: "",
					 optionD: "",
					 questionId: 314,
					 helpText: "As an alternative to the initializer syntax, you can create an empty array using an empty array literal, written as [ ] (an empty pair of square brackets)."),
			
			Question(question: ["What will be the type of the ints array and what will it contain?",
								"Choose the correct type and content of ints collection",
								"Select the type and content the ints array will have"],
					 image: "Collections15",
					 optionA: "[Double] and [0.0, 0.0, 0.0]",
					 optionB: "[Int] and [0, 0, 0]",
					 optionC: "[Double] and [0, 0, 0]",
					 optionD: "[Int] and [0.0, 0.0, 0.0]",
					 questionId: 315,
					 helpText: "Since the type is not specified, Swift will set the floating-point array to [Double]. Also the array’s initializer specifies that the array should contain 0.0, repeated three times. The correct answer would be [Double], [0.0, 0.0, 0.0]. Swift’s Array type provides an initializer for creating an array of a certain size with all of its values set to the same default value. You pass this initializer a default value of the appropriate type (called repeating): and the number of times that value is repeated in the new array (called count)"),
			
			Question(question: ["How can we create a new array by concatenating two existing arrays with compatible types?",
								"How can we create a new array from two existing ones (if their types are compatible)?"],
					 image: "",
					 optionA: "With addition operator (+)",
					 optionB: "With interpolation",
					 optionC: "With .insert method",
					 optionD: "Logical operator &&",
					 questionId: 316,
					 helpText: "You can create a new array by adding together two existing arrays with compatible types with the addition operator (+). The new array’s type is inferred from the type of the two arrays you add together. You can also add one array to another via firstArray.append(contentsOf: secondArray)."),
			
			Question(question: ["Which option shows how we can create an array using array literal syntax?"],
					 image: "",
					 optionA: "var nums: [Int] = [0, 1, 2, 3]",
					 optionB: "var nums: Int = [0, 1, 2, 3]",
					 optionC: "var nums: [Int] = 0, 1, 2, 3",
					 optionD: "var nums: [Int](0, 1, 2, 3)",
					 questionId: 317,
					 helpText: "You can also initialize an array with an array literal, which is a shorthand way to write one or more values as an array collection. An array literal is written as a list of values, separated by commas, surrounded by a pair of square brackets: [value 1, value 2, value 3]. Example: var number: [Int] = [1, 2, 3, 4, 5]."),
			
			Question(question:["Do you have to write the type of the array if you’re initializing it with an array literal containing values of the same type?",
							   "Is it possible initialize the following array in a shorter form by omitting array type: var array: [Int] = [1, 2]?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 318,
					 helpText: "Thanks to Swift’s type inference, you don’t have to write the type of the array if you’re initializing it with an array literal containing values of the same type, for example var array: [Int] = [1, 2]. The initialization could have been written in a shorter form instead: var array = [1, 2]. Because all values in the array literal are of the same type, Swift can infer that [Int] is the correct type to use for the variable."),
			
			Question(question: ["A quick way to get the number of elements of an array",
								"You can get the number of elements of an array through the ... property",
								"Which property returns the number of elements in an array?"],
					 image: "",
					 optionA: ".count",
					 optionB: ".sort()",
					 optionC: ".prefix()",
					 optionD: ".append()",
					 questionId: 319,
					 helpText: "To find out the number of items in an array, check its read-only count property."),
			
			Question(question: ["What will this code print out?"],
					 image: "Collections20",
					 optionA: "Array is empty",
					 optionB: "Array is not empty",
					 optionC: "Nothing",
					 optionD: "",
					 questionId: 320,
					 helpText: "Use the Boolean isEmpty property as a shortcut for checking whether the count property is equal to 0. In this example, we have an empty ‘array’ array, which means we will pass the check by the first condition and display \"Array is empty\""),
			
			Question(question: ["At what position the element is placed when added to the array via .append(_:)?",
								"Where exactly does the .append(_:) method called on an array add new items?",
								"If we add an element to the array via .append(_:), where will it be put?"],
					 image: "",
					 optionA: "To the end of an array",
					 optionB: "At the beginning of an array",
					 optionC: "In the middle",
					 optionD: "",
					 questionId: 321,
					 helpText: "You can add a new item to the end of an array by calling the array’s append(_:) method."),
			
			Question(question: ["What result will we get after running the code above?"],
					 image: "Collections22",
					 optionA: "We'll get an error",
					 optionB: "[0.1, 1.1, 1.2, 2.2, 3.4]",
					 optionC: "The array won't change",
					 optionD: "",
					 questionId: 322,
					 helpText: "You can add an array with one or more compatible (types) elements using the addition operator (+), but in this case we will run into an error because numbers is a constant."),
			
			Question(question: ["What will the numbers array contain after the code is executed?"],
					 image: "Collections23",
					 optionA: "[1.0, 2.0, 3.0, 4.0, 5.0]",
					 optionB: "[1.0, 2.0, 3, 4, 5]",
					 optionC: "[1, 2, 3, 4, 5]",
					 optionD: "[1.0, 2.0]",
					 questionId: 323,
					 helpText: "The correct answer is [1.0, 2.0, 3.0, 4.0, 5.0]. The addition assignment operator will add the values 3, 4, and 5 to this array, but since the numbers array is of type [Double], its values will be 3.0, 4.0, 5.0."),
			
			Question(question: ["How can you retrieve a value from an array using subscript syntax?"],
					 image: "",
					 optionA: "arrayName[1]",
					 optionB: "arrayName(0)",
					 optionC: "arrayName-2",
					 optionD: "arrayName.3",
					 questionId: 324,
					 helpText: "Retrieve a value from the array by using subscript syntax, passing the index of the value you want to retrieve within square brackets immediately after the name of the array. The first item in the array has an index of 0, not 1. Arrays in Swift are always zero-indexed."),
			
			Question(question: ["What elements will be in the numbers array after this code is executed?",
								"Select the final order of elements of the numbers array after executing the following code",
								"After executing the code above, what will be the order of elements in the numbers array?"],
					 image: "Collections25",
					 optionA: "[1.0, 2.0, 1.0, 4.0]",
					 optionB: "[1.0, 2.0, 3.0, 4.0]",
					 optionC: "[1.0, 2.0, 3.0, 1.0]",
					 optionD: "[1.0, 1.0, 3.0, 4.0]",
					 questionId: 325,
					 helpText: "You can use subscript syntax to change an existing value at a given index. The correct answer is [1.0, 2.0, 1.0, 4.0], since we are initializing a new value to the array element at index [2], starting at 0 this will be the third element (3.0)."),
			
			Question(question: ["What elements will the numbers array contain after this code is executed?",
								"Select how the elements of the numbers array will be ordered after the code above is executed",
								"Once the code is executed, what is the order of elements in the numbers array?"],
					 image: "Collections26",
					 optionA: "[1.0, 4.0, 5.0, 6.0]",
					 optionB: "[1.0, 4, 5, 6]",
					 optionC: "[1.0, 2.0, 3.0, 4.0]",
					 optionD: "[4.0, 5.0, 6.0, 4.0]",
					 questionId: 326,
					 helpText: "You can use subscript syntax to change a range of values at once, even if the replacement set of values has a different length than the range you are replacing. Correct answer: [1.0, 4.0, 5.0, 6.0], since we are changing values from 1 to 3 index, which is 2.0, 3.0, 4.0."),
			
			Question(question: ["What elements will be in the numbers array after this code is executed?",
								"Select the final order of elements of the numbers array after executing this code",
								"After executing the code, what will be the order of elements in the numbers array?"],
					 image: "Collections27",
					 optionA: "[1.0, 2.0, 11.0, 12.0, 13.0, 5.0]",
					 optionB: "[1.0, 2.0, 11.0, 12.0, 5.0]",
					 optionC: "[1.0, 2.0, 11.0, 12.0]",
					 optionD: "[1.0, 2.0, 11.0, 12.0, 13.0]",
					 questionId: 327,
					 helpText: "You can use subscript syntax to change a range of values at once, even if the replacement set of values has a different length than the range you are replacing. The correct answer is [1.0, 2.0, 11.0, 12.0, 13.0, 5.0], since we change the values from 2 to 3 index, which is 3.0, 4.0, but we are inserting three elements instead of the two deleted."),
			
			Question(question: ["Which method inserts an element into the array at a specified index?",
								"To insert an element at a specified index in the array you should use the ... method",
								"What method should you use to insert an element at a specified array index?"],
					 image: "",
					 optionA: "insert(_:at:)",
					 optionB: "append",
					 optionC: "add(_:at:)",
					 optionD: "remove(_ :at:)",
					 questionId: 328,
					 helpText: "To insert an item into the array at a specified index, call the array’s insert(_:at:) method."),
			
			Question(question: ["Which method removes an element from the array at a specified index?"],
					 image: "",
					 optionA: "remove(_ :at:)",
					 optionB: "append(_:at:)",
					 optionC: "add(_:at:)",
					 optionD: "erase(_:at:)",
					 questionId: 329,
					 helpText: "You remove an item from the array with the remove(at:) method. This method removes the item at the specified index and returns the removed item (although you can ignore the returned value if you do not need it)."),
			
			Question(question: ["What happens if you try to access or change the value of an index that is outside the existing bounds of the array?",
								"What will be the result of changing an index value that is outside the existing array boundaries?"],
					 image: "",
					 optionA: "Runtime error",
					 optionB: "We will get a nil",
					 optionC: "Nothing is going to happen",
					 optionD: "We'll get its last element",
					 questionId: 330,
					 helpText: "If you try to access or modify a value for an index that is outside of an array’s existing bounds, you will trigger a runtime error. You can check that an index is valid before using it by comparing it to the array’s count property. The largest valid index in an array is count - 1 because arrays are indexed from zero—however, when count is 0 (meaning the array is empty), there are no valid indexes.")
		]
	}
}
