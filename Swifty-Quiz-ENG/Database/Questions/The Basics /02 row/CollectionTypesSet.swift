
//  Created by Евгений Никитин on 10.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

// MARK:  Вопросы (id) с 301 по 400

class CollectionTypesSet {
    static func getQuestions() -> [Question] {
        return [
            Question(question: ["Сколько основных типов коллекций обеспечивает Swift?",
                                "Swift поддерживает именно столько основных типов коллекций",
                                "Какое количество типов коллекций поддерживается в Swift?"],
                     image: "",
                     optionA: "Три",
                     optionB: "Два",
                     optionC: "Четыре",
                     optionD: "Пять",
                     questionId: 301,
                     helpText: "Swift обеспечивает три основных типа коллекций - это Массивы, Множества и Словари для хранения коллекций значений."),
            
            Question(question: ["Упорядоченная коллекция значений",
                                "Коллекция с упорядоченными значениями",
                                "Упорядоченные значения, объединенные в коллекцию"],
                     image: "",
                     optionA: "Массив",
                     optionB: "Словарь",
                     optionC: "Множество",
                     optionD: "",
                     questionId: 302,
                     helpText: "Массивы - это упорядоченные коллекции значений. Массивы хранят много значений одинакового типа в упорядоченном списке. Одно и то же значение в массиве может появиться несколько раз, в разных позициях."),
            
            Question(question: ["Неупорядоченная коллекция уникальных значений",
                                "Уникальные значения, собранные в неупорядоченную коллекцию",
                                "Коллекция неупорядоченных уникальных значений"],
                     image: "",
                     optionA: "Множество",
                     optionB: "Массив",
                     optionC: "Словарь",
                     optionD: "",
                     questionId: 303,
                     helpText: "Множества - это неупорядоченные коллекции уникальных значений."),
            
            Question(question: ["Неупорядоченная коллекция, хранящая пары ключ-значение",
                                "Коллекция, хранящая неупорядоченные пары ключ-значение",
                                "Неупорядоченные пары ключ-значение хранятся именно в этой коллекции"],
                     image: "",
                     optionA: "Словарь",
                     optionB: "Множество",
                     optionC: "Массив",
                     optionD: "",
                     questionId: 304,
                     helpText: "Словари - это неупорядоченные коллекции, хранящие пары ключ-значение. Словарь представляет собой контейнер, который хранит несколько значений одного и того же типа. Каждое значение связано с уникальным ключом, который выступает в качестве идентификатора этого значения внутри словаря. В отличие от элементов в массиве, элементы в словаре не имеют определенного порядка. Используйте словарь, когда вам нужно искать значения на основе их идентификатора, так же как в реальном мире словарь используется для поиска определения конкретного слова."),
            
            Question(question: ["Какой тип коллекции на изображении?"],
                     image: "Collections5",
                     optionA: "Словарь",
                     optionB: "Множество",
                     optionC: "Массив",
                     optionD: "",
                     questionId: 305,
                     helpText: "На изображении словарь, коллекция пар ключ-значение"),
            
            Question(question: ["Можем ли мы по ошибке вставить значение неверного типа в коллекцию?",
                                "Можем ли мы вставить значение неверного типа в массив?",
                                "Возможно ли вставить значение неверного типа в словарь? "],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 306,
                     helpText: "Массивам, множествам и словарям в Swift всегда понятно, какие типы значений и ключи они могут хранить. Это означает, что вы не можете по ошибке вставить неверное значение в коллекцию. Это также означает, что вы можете быть уверены в типах значений, которые вы получите из коллекции."),
            
            Question(question: ["Если массив или словарь присвоены переменной, можем ли мы их изменять?",
                                "Можем ли мы изменять словарь или массив, если он присвоен переменной?",
                                "Возможно ли изменять словарь, если при создании мы присвоили его переменной?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Только добавлять элементы",
                     optionC: "Только удалять элементы",
                     optionD: "Нет",
                     questionId: 307,
                     helpText: "Когда вы создаете массив или словарь и присваиваете его переменной, то созданная коллекция будет изменяемой. Это означает, что вы можете изменить коллекцию после ее создания путем добавления, удаления, или изменения элементов этой коллекции. И наоборот, когда вы присвоите массив или словарь константе, то он будет неизменяемым, а его размер и содержимое не может быть изменено."),
            
            Question(question: ["Какой тип коллекции на изображении?",
                                "Укажите какой тип коллекции изображен на изображении?",
                                "На этом изображении именно этот тип коллекции"],
                     image: "Collections8",
                     optionA: "Массив",
                     optionB: "Множество",
                     optionC: "Набор",
                     optionD: "Словарь",
                     questionId: 308,
                     helpText: "На изображении массив, упорядоченная коллекция значений, доступных по индексу."),
            
            Question(question: ["Какой тип коллекции на изображении?",
                                "Укажите какой тип коллекции изображен на изображении?",
                                "На этом изображении именно этот тип коллекции"],
                     image: "Collections9",
                     optionA: "Множество",
                     optionB: "Массив",
                     optionC: "Словарь",
                     optionD: "",
                     questionId: 309,
                     helpText: "На изображении множество, неупорядоченная коллекция уникальных значений."),
            
            Question(question: ["Если коллекция присвоена константе, можем ли мы ее изменять?",
                                "Можем ли мы изменять словарь или массив, если он присвоен константе?",
                                "Возможно ли изменять множество, если при создании мы присвоили его константе?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Можем добавлять элементы",
                     optionC: "Можем удалять элементы",
                     optionD: "Да",
                     questionId: 310,
                     helpText: "Когда вы присвоите массив или словарь константе, то он будет неизменяемым, а его размер и содержимое не может быть изменено. Хорошей практикой является создание неизменяемых коллекций во всех случаях, когда коллекцию не нужно менять. Делая это, мы позволяем компилятору Swift оптимизировать производительность наших коллекций."),
            
            Question(question: ["Как пишется полная форма записи массива в Swift?",
                                "Полная форма записи массива в Swift пишется так",
                                "Как нужно писать полную форму записи массива в Swift?"],
                     image: "",
                     optionA: "Array<ElementType>",
                     optionB: "[ElementType]",
                     optionC: "[ElementType]()",
                     optionD: "Array(ElementType)[]",
                     questionId: 311,
                     helpText: "Полная форма записи массива в Swift пишется Array<ElementType>, где ElementType это тип значений, которые могут храниться в массиве."),
            
            Question(question: ["Как пишется сокращенная форма записи массива в Swift?",
                                "Сокращенная форма записи массива в Swift пишется так",
                                "Как нужно писать сокращенную форму записи массива в Swift?"],
                     image: "",
                     optionA: "[ElementType]",
                     optionB: "Array<ElementType>",
                     optionC: "[ElementType]()",
                     optionD: "Array(ElementType)[]",
                     questionId: 312,
                     helpText: "Вы можете также написать массив в сокращенной форме как [ElementType]. Хотя две формы функционально идентичны, краткая форма является предпочтительной."),
            
            Question(question: ["Как можно создать пустой массив с помощью синтаксиса инициализатора?",
                                "Как вы можете создать пустой массив?",
                                "Пустой массив инициализируется именно так"],
                     image: "",
                     optionA: "var array = [String]()",
                     optionB: "var array = (String)[]",
                     optionC: "var array = [String()]",
                     optionD: "var array: [String]?",
                     questionId: 313,
                     helpText: "Вы можете создать пустой массив определенного типа с помощью синтаксиса инициализатора: var array = [String]()."),
            
            Question(question: ["Альтернативный способ создания пустого массива",
                                "Альтернативный вариант, как вы можете создать пустой массив",
                                "Пустой массив может инициализироваться именно так"],
                     image: "",
                     optionA: "var array: [String] = []",
                     optionB: "var array: String = []",
                     optionC: "var array = String()",
                     optionD: "var array: [String]?",
                     questionId: 314,
                     helpText: "В качестве альтернативы синтаксису инизиализатора, вы можете создать пустой массив с помощью пустого литерала массива, который записывается в виде [] (пустой пары квадратных скобок)."),
            
            Question(question: ["Какой тип будет у данного массива ints, и что будет внутри?",
                                "Выберите ответ с правильным типом и содержанием коллекции ints",
                                "Выберите тип и содержание данного массива ints"],
                     image: "Collections15",
                     optionA: "[Double] и [0.0, 0.0, 0.0]",
                     optionB: "[Int] и [0, 0, 0]",
                     optionC: "[Double] и [0, 0, 0]",
                     optionD: "[Int] и [0.0, 0.0, 0.0]",
                     questionId: 315,
                     helpText: "Если не указывать иного, Swift присвоит массиву чисел с плавающей точкой тип [Double], а данный инициализатор массива указывает, что в этом массиве должны быть числа 0.0, повторяющиеся три раза. То есть правильный ответ будет [Double], [0.0, 0.0, 0.0]."),
            
            Question(question: ["Как мы можем создать новый массив, объединив два существующих массива с совместимыми типами?",
                                "Каким образом мы можем создать новый массив из двух существующих (их типа совместимы)?",
                                "Из двух существующих массивов с одинаковым типом необходимо создать новый, как это сделать?"],
                     image: "",
                     optionA: "Сложить (+)",
                     optionB: "Используя интерполяцию",
                     optionC: "Через свойство .insert",
                     optionD: "Логическим оператором И &&",
                     questionId: 316,
                     helpText: "Вы можете создать новый массив, объединив два существующих массива с совместимыми типами с оператором сложения (+). Новый тип массива выводится из типа двух массивов, которые вы объединяете вместе. Так же можно добавить один массив к другому через firstArray.append(contentsOf: secondArray)."),
            
            Question(question: ["Выберите создание массива через синтаксис литерала массива",
                                "Какой из этих способов описывается как «создание массива через литерал массива»?",
                                "Мы можем создать массив с помощью синтаксиса литерала массива именно так"],
                     image: "",
                     optionA: "var nums: [Int] = [0, 1, 2, 3]",
                     optionB: "var nums: Int = [0, 1, 2, 3]",
                     optionC: "var nums: [Int] = 0, 1, 2, 3",
                     optionD: "var nums: [Int](0, 1, 2, 3)",
                     questionId: 317,
                     helpText: "Вы можете инициализировать массив с помощью литерала массива, который является быстрым способом писать одно или несколько значений как набор значений массива. Литерал массива пишется в виде списка значений, разделенных запятыми и окруженными парами скобок: [value 1, value 2, value 3]. Пример: создается массив под названием numbers для хранения Int значений: var number: [Int] = [1, 2, 3, 4, 5]."),
            
            Question(question: ["В каком из этих случаев мы можем не указывать тип массива?",
                                "Выберите вариант, в котором мы можем убрать указание типа массива, и это не вызовет ошибку?",
                                "Выберите вариант, при котором мы можем убрать явное указание типа массива?"],
                     image: "",
                     optionA: "var array: [Int] = [1, 2]",
                     optionB: "var array = [String]()",
                     optionC: "var array = [Int](1, 2, 3)",
                     optionD: "var array = []",
                     questionId: 318,
                     helpText: "Благодаря выводу типов Swift, вы можете не писать тип для массива, который вы инициализируйте с помощью литерала массива, хранящего значения того же типа, например var array: [Int] = [1, 2]. Вместо этого, инициализация array может быть записана в сокращенной форме: var array = [1, 2]. Поскольку все значения внутри литерала массива одинакового типа (Int), Swift может вывести, что [Int] является правильным типом для переменной array."),
            
            Question(question: ["Быстрый способ получить количество элементов массива?",
                                "Получить количество элементов массива можно через это свойство",
                                "Какое свойство поможет вам получить количество элементов массива?"],
                     image: "",
                     optionA: "array.count",
                     optionB: "array.sort()",
                     optionC: "array.prefix()",
                     optionD: "array.append()",
                     questionId: 319,
                     helpText: "Чтобы узнать количество элементов в массиве, проверьте его свойство count."),
            
            Question(question: ["Что выведется в консоль после запуска данного кода?",
                                "Какой результат запуска мы увидим в консоли?",
                                "Выберите вариант, который окажется в консоли после запуска этого кода"],
                     image: "Collections20",
                     optionA: "Array is empty",
                     optionB: "Array is not empty",
                     optionC: "Ничего не выведет",
                     optionD: "Столкнемся с ошибкой",
                     questionId: 320,
                     helpText: "Логическое свойство isEmpty можно использовать в качестве быстрого способа узнать, является ли свойство count равным 0. В данном примере у нас пустой массив array, значит мы пройдем проверку по первому условию и выведем «Array is empty»"),
            
            Question(question: ["Куда добавляется элемент, когда мы вносим его в массив через .append?",
                                "Как добавится элемент, когда мы вставляем его в массив через .append?",
                                "Если мы добавим элемент в массив через .append, куда он поместится?"],
                     image: "",
                     optionA: "В конец массива",
                     optionB: "В начало массива",
                     optionC: "Посередине",
                     optionD: "",
                     questionId: 321,
                     helpText: "Через вызов метода append вы можете добавлять новые элементы в конец массива."),
            
            Question(question: ["Какой результат мы получим, после запуска этого кода?"],
                     image: "Collections22",
                     optionA: "Столкнемся с ошибкой",
                     optionB: "[0.1, 1.1, 1.2, 2.2, 3.4]",
                     optionC: "Массив не изменится",
                     optionD: "Ничего",
                     questionId: 322,
                     helpText: "Добавить массив с одним или несколькими совместимыми (типами) элементами можно с помощью оператора сложения с присвоением (+=), но в данном случае мы столкнемся с ошибкой, поскольку numbers является константой."),
            
            Question(question: ["Что будет содержаться внутри массива numbers после выполнения этого кода?",
                                "Какие значения будут содержаться внутри numbers в результате?",
                                "Выберите верный вариант итогового вида массива numbers"],
                     image: "Collections23",
                     optionA: "[1.0, 2.0, 3.0, 4.0, 5.0]",
                     optionB: "[1.0, 2.0, 3, 4, 5]",
                     optionC: "[1, 2, 3, 4, 5]",
                     optionD: "[1.0, 2.0]",
                     questionId: 323,
                     helpText: "Правильный ответ [1.0, 2.0, 3.0, 4.0, 5.0]. Оператор присваивания со сложением добавит в данный массив значения 3, 4 и 5, но, так как массив numbers имеет тип [Double], значения примут вид 3.0, 4.0, 5.0."),
            
            Question(question: ["Как с помощью синтаксиса сабскриптов извлечь значение из массива?",
                                "В каком из вариантов используется корректное обращение к элементу массива с помощью синтаксиса сабскриптов?",
                                "Как выглядит извлечение из массива с помощью синтаксиса сабскриптов?"],
                     image: "",
                     optionA: "arrayName[1]",
                     optionB: "arrayName(0)",
                     optionC: "arrayName-2",
                     optionD: "arrayName.3",
                     questionId: 324,
                     helpText: "Можно извлечь значение из массива с помощью синтаксиса сабскриптов, поместив индекс значения, который вы хотите получить, внутри квадратных скобок сразу после имени массива. Первый элемент в массиве имеет индекс 0, а не 1. Массивы в Swift всегда начинаются с 0."),
            
            Question(question: ["Какие элементы будут в массиве numbers после выполнения данного кода?",
                                "Выберите итоговый порядок элементов массива numbers после исполнения данного кода",
                                "После выполнения кода, какой порядок элементов будет у массива numbers?"],
                     image: "Collections25",
                     optionA: "[1.0, 2.0, 1.0, 4.0]",
                     optionB: "[1.0, 2.0, 3.0, 4.0]",
                     optionC: "[1.0, 2.0, 3.0, 1.0]",
                     optionD: "[1.0, 1.0, 3.0, 4.0]",
                     questionId: 325,
                     helpText: "Вы можете использовать синтаксис сабскриптов для изменения существующего значения по указанному индексу. Правильный ответ: [1.0, 2.0, 1.0, 4.0], поскольку мы инициализируем новое значение элементу массива, который находится на индексе [2], начиная с 0 это будет третий элемент (3.0)."),
            
            Question(question: ["Какие элементы будут в массиве numbers после выполнения данного кода?",
                                "Выберите итоговый порядок элементов массива numbers после исполнения данного кода",
                                "После выполнения кода, какой порядок элементов будет у массива numbers?"],
                     image: "Collections26",
                     optionA: "[1.0, 4.0, 5.0, 6.0]",
                     optionB: "[1.0, 4, 5, 6]",
                     optionC: "[1.0, 2.0, 3.0, 4.0]",
                     optionD: "[4.0, 5.0, 6.0, 4.0]",
                     questionId: 326,
                     helpText: "Вы можете использовать синтаксис сабскриптов для изменения диапазона значений за раз, даже если набор изменяемых значений имеет разную длину, по сравнению с диапазоном который требуется заменить. Правильный ответ: [1.0, 4.0, 5.0, 6.0], поскольку мы меняем значения с 1 по 3 индекс, а это 2.0, 3.0, 4.0."),
            
            Question(question: ["Какие элементы будут в массиве numbers после выполнения данного кода?",
                                "Выберите итоговый порядок элементов массива numbers после исполнения данного кода",
                                "После выполнения кода, какой порядок элементов будет у массива numbers?"],
                     image: "Collections27",
                     optionA: "[1.0, 2.0, 11.0, 12.0, 13.0, 5.0]",
                     optionB: "[1.0, 2.0, 11.0, 12.0, 5.0]",
                     optionC: "[1.0, 2.0, 11.0, 12.0]",
                     optionD: "[1.0, 2.0, 11.0, 12.0, 13.0]",
                     questionId: 327,
                     helpText: "Вы можете использовать синтаксис сабскриптов для изменения диапазона значений за раз, даже если набор изменяемых значений имеет разную длину, по сравнению с диапазоном который требуется заменить. Правильный ответ: [1.0, 2.0, 11.0, 12.0, 13.0, 5.0], поскольку мы меняем значения с 2 по 3 индекс, а это 3.0, 4.0, но вставляем уже три элемента, вместо удаленных двух."),
            
            Question(question: ["Вызов какого метода поможет вставить элемент в массив на определенный индекс?",
                                "Чтобы вставить элемент на определенный индекс массива, какой мы будем использовать метод?",
                                "Какой метод нужно использовать, чтобы вставить элемент на определенный индекс массива?"],
                     image: "",
                     optionA: "insert(_:at:)",
                     optionB: ".append",
                     optionC: "add(_:at:)",
                     optionD: "remove(_ :at:)",
                     questionId: 328,
                     helpText: "Для вставки элемента по заданному индексу внутрь массива, вызовите его метод insert(_:at:)."),
            
            Question(question: ["Вызов какого метода поможет удалить элемент из массива с определенного индекса?",
                                "Чтобы удалить элемент с определенного индекса массива, какой мы будем использовать метод?",
                                "Какой метод нужно использовать, чтобы удалить элемент с определенного индекса массива?"],
                     image: "",
                     optionA: "remove(_ :at:)",
                     optionB: ".append",
                     optionC: "add(_:at:)",
                     optionD: "insert(_:at:)",
                     questionId: 329,
                     helpText: "Можно удалить элемент из массива с помощью метода remove(at:). Этот метод удаляет элемент с указанным индексом и возвращает удаленный элемент (хотя вы можете проигнорировать возвращаемое значение, если оно вам не нужно)."),
            
            Question(question: ["Что будет, если вы попытаетесь получить доступ или изменить значение индекса, который находится за пределами существующих границ массива?",
                                "Если вы попытаетесь изменить значение индекса, который находится за пределами существующих границ массива, что произойдет?"],
                     image: "",
                     optionA: "Ошибка исполнения",
                     optionB: "Вернется nil",
                     optionC: "Ничего не произойдет",
                     optionD: "Вернется последний элемент",
                     questionId: 330,
                     helpText: "Если вы пытаетесь получить доступ или изменить значение индекса, который находится за пределами существующих границ массива, у вас будет ошибка исполнения. Вы можете проверить, действителен ли индекс, прежде чем его использовать, сравнив его с свойством count массива. За исключением случаев, когда count равен 0 (то есть массив пуст), самый большой валидный индекс в массиве всегда будет count - 1, так как массивы индексируются с нуля."),
            
            Question(question: ["Какие элементы будут содержаться в массиве после выполнения этого кода?",
                                "Выберите какие значения будут содержаться в массиве после исполнения insert и remove?"],
                     image: "Collections30",
                     optionA: "[2, 3, 9, 4, 5]",
                     optionB: "[1, 2, 3, 9, 4, 5]",
                     optionC: "[1, 2, 3, 4, 5]",
                     optionD: "[1, 2, 3, 9, 4]",
                     questionId: 331,
                     helpText: "Сначала numbers.insert(9, at: 3) добавляет девятку на третий индекс, то есть между тройкой и четверкой, после чего numbers.remove(at: 0) удаляет единицу, которая находится на нулевом индексе. Получается [2, 3, 9, 4, 5]."),
            
            Question(question: ["Как мы можем удалить один или несколько последних элементов массива, при этом вернуть оставшийся массив?",
                                "Каким методом вы можете удалить несколько последних значений массива, и вернуть то, что осталось?",
                                "Выберите метод, который позволит вам удалить несколько последних элементов массива и вернуть оставшееся"],
                     image: "",
                     optionA: "array.dropLast()",
                     optionB: "array.removeLast()",
                     optionC: "array.remove(_ :at:)",
                     optionD: "array.deleteLast()",
                     questionId: 332,
                     helpText: "Если вы хотите удалить последний или несколько последних элементов из массива, вы можете использовать метод dropLast(), в скобках необходимо указать количество элементов, которые вы хотите удалить. После реализации данного метода вам вернется оставшаяся последовательность."),
            
            Question(question: ["Каким методом мы можем удалить последний элемент массива, и сразу вернуть его?",
                                "Какой метод удаляет последний элемент массива, и возвращает его?",
                                "Этим методом можно удалить последний элемент массива и вернуть его"],
                     image: "",
                     optionA: "array.removeLast()",
                     optionB: "array.remove(_ :at:)",
                     optionC: "array.dropLast()",
                     optionD: "array.deleteLast()",
                     questionId: 333,
                     helpText: "Если вы хотите удалить последний элемент из массива, то можно использовать метод removeLast() вместо remove(at:), чтобы избежать необходимости запроса свойства count для массива. Также как и метод remove(at:), removeLast() возвращает удаленный элемент."),
            
            Question(question: ["Какими будут значения переменных first и second?",
                                "Выберите, какими будут значения переменных first и second"],
                     image: "Collections34",
                     optionA: "[1, 2, 3] и 4",
                     optionB: "[1, 2, 3, 4] и 4",
                     optionC: "[1, 2, 3, 4, 5] и 5",
                     optionD: "[1, 2, 3, 4] и 5",
                     questionId: 334,
                     helpText: "Первое выражение var first = numbers.dropLast() присвоит переменной first массив с оставшимися элементами, это [1, 2, 3, 4]. Второе выражение var second = first.removeLast() присвоит переменной second последний элемент массива first, то есть цифру 4, но при этом он удалит ее из этой переменной, и там останется только [1, 2, 3]. Правильный ответ: [1, 2, 3], 4." ),
            
            Question(question: ["Каким образом можно выполнить самое просто итерирование массива?",
                                "Этим способом можно выполнить простое итерирование массива, возвращая только элементы без индексов",
                                "Как мы можем выполнить просто итерирование массива, чтобы возвращать только элементы без индексов?"],
                     image: "",
                     optionA: "цикл for-in",
                     optionB: "цикл while",
                     optionC: "enumerated()",
                     optionD: "Через сабскрипт [i]",
                     questionId: 335,
                     helpText: "Вы можете выполнить итерацию по всему набору значений внутри массива с помощью цикла for-in. Но если вам нужен целочисленный индекс каждого значения так же как и само значение, используйте вместо этого глобальную функцию enumerated() для итерации по массиву. Функция enumerated() возвращает кортеж для каждого элемента массива, собрав вместе индекс и значение для этого элемента."),
            
            Question(question: ["Каким образом мы можем итерировать массив, чтобы вернуть кортежи значений, содержащие индекс и значение, находящееся на этом индексе?",
                                "Этим способом можно итерировать массив, возвращая кортежи значений, состоящие из индекса и значения, находящегося на этом индексе",
                                "С помощью этой глобальной функции мы можем итерировать массив и вернуть кортежи, состоящие из индексов и значений, находящихся на этих индексах."],
                     image: "",
                     optionA: "for-in и enumerated()",
                     optionB: "for-in и sorted()",
                     optionC: "repeat-while",
                     optionD: "while",
                     questionId: 336,
                     helpText: "Если вам нужен целочисленный индекс каждого значения так же как и само значение, используйте глобальную функцию enumerated() для итерации по массиву. Функция enumerated() возвращает кортеж для каждого элемента массива, собрав вместе индекс и значение для этого элемента. При этом вы можете разложить кортеж во временные константы или переменные в рамках итерации: for (index, value) in someArray.enumerated() { print(index, value) }"),
            
            Question(question: ["Какие значения мы получим в консоль после запуска?",
                                "Что эта программа выведет в консоль?",
                                "Какие данные мы получим в консоль после запуска?"],
                     image: "Collections37",
                     optionA: "0 - 0.1 и 1 - 0.2",
                     optionB: "1 - 0.1 и 2 - 0.2",
                     optionC: "Ничего не получим",
                     optionD: "index - value и index - value",
                     questionId: 337,
                     helpText: "0 - 0.1 и 1 - 0.2"),
            
            Question(question: ["Если принципиально важно, чтобы значения в коллекции не повторялись, какой тип вы будете использовать?",
                                "Какой тип коллекции вы будете использовать, если важно, чтобы значения внутри не повторялись?",
                                "Какую коллекцию вы будете использовать, чтобы внутри все значения были уникальными?"],
                     image: "",
                     optionA: "Множество",
                     optionB: "Массив",
                     optionC: "Словарь",
                     optionD: "",
                     questionId: 338,
                     helpText: "Множество хранит различные значения одного типа в виде коллекции в неупорядоченной форме. Вы можете использовать множества как альтернативы массиву, когда порядок для вас значения не имеет или когда вам нужно быть уверенным в том, что значения внутри коллекции не повторяются."),
            
            Question(question: ["Каким должен быть тип значения, чтобы он мог храниться в множестве?",
                                "Тип значений должен быть именно таким, чтобы иметь возможность храниться в множестве",
                                "Каким будет тип значения, если он хранится в множестве?"],
                     image: "",
                     optionA: "Булевым",
                     optionB: "Хешируемым",
                     optionC: "Числовым",
                     optionD: "Вычисляемым",
                     questionId: 339,
                     helpText: "Тип значений должен быть хешируемым для того, чтобы мог храниться в множестве, таким образом тип должен предоставлять возможность для вычисления собственного значения хеша. Тип значения хеша Int должен быть для всех объектов одинаковым, чтобы можно было провести сравнение что если a == b, то и a.hashValue == b.hashValue. Вы можете использовать ваш собственный тип в качестве типа значения множества или типа ключа словаря, подписав его под протокол Hashable из стандартной библиотеки Swift."),
            
            Question(question: ["Как в Swift записывается тип множества?",
                                "Так записывают тип множества в Swift",
                                "Как мы должны записывать тип множества в Swift?"],
                     image: "",
                     optionA: "Set<ElementType>",
                     optionB: "Set(ElementType)",
                     optionC: "Set[ElementType]",
                     optionD: "(Set<ElementType>)",
                     questionId: 340,
                     helpText: "Тип множества Swift записывается как Set<ElementType>, ElementType является типом, который хранится в множестве."),
            
            Question(question: ["Имеют ли множества сокращенную форму записи, если да, то какую?",
                                "Есть ли у множеств сокращенная форма записи? Если да, то какая? ",
                                "Можем ли мы записать множество в сокращенной форме, если да, то как?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да, [Set]",
                     optionC: "Да, <Set>",
                     optionD: "Да, (Set)",
                     questionId: 341,
                     helpText: "В отличии от массивов множества не имеют сокращенной формы записи. Кроме случаев инициализации через литерал массива, где содержатся элементы одного и того-же типа, в таком случае можно писать просто Set, без указания конкретного типа."),
            
            Question(question: ["Как создать пустое множество конкретного типа?",
                                "Как вы можете создать пустое множество конкретного типа, используя синтаксис инициализатора?",
                                "Через синтаксис инициализатора мы можем создать пустое множество конкретного типа, как?"],
                     image: "",
                     optionA: "var names = Set<String>()",
                     optionB: "var names = Array<String>[]",
                     optionC: "var names = Dictionary<String>()",
                     optionD: "var names = (Set { String })",
                     questionId: 342,
                     helpText: "Вы можете создать пустое множество конкретного типа, используя синтаксис инициализатора: var name = Set<String>(). Тип переменной name будет выведен из типа инициализатора как Set<String>."),
            
            Question(question: ["Если контекст дает информацию о типе, можем ли мы создать пустое множество при помощи литерала пустого массива?",
                                "Если у нас есть явное указание типа, можем ли мы обнулить множество, используя литера массива (пустые квадратные скобки)?",
                                "Можем ли мы создать пустое множество, используя литерал пустого массива (пустые квадратные скобки), если у нас есть явно указанный тип этого множества?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 343,
                     helpText: "Альтернативно, если контекст предоставляет информацию о типе, например как аргумент функции или просто явное указание типа переменной или константы, то вы можете создать пустое множество при помощи пустого литерала массива."),
            
            Question(question: ["Можем ли мы инициализировать множество при помощи литерала массива?",
                                "Можем ли мы с помощью литерала массива инициализировать множество?"],
                     image: "",
                     optionA: "Да, let ints: Set<Int> = [1, 2]",
                     optionB: "Нет, не можем",
                     optionC: "Да, let ints: Set<Int>([1, 2])",
                     optionD: "Да, let ints = Set<Int[1, 2]>",
                     questionId: 344,
                     helpText: "Вы можете инициализировать множество при помощи литерала массива, чтобы использовать его в качестве сокращенной записи нескольких элементов множества. Для этого вы должны явно указать что это множество определенных типов значений (записывается как Set<Type>). Где Type - это любые стандартные типы Int, String, Double или Bool (или любой другой хешируемый тип значений)."),
            
            Question(question: ["Какой тип будет присвоен этому множеству?",
                                "Как будет выглядеть полная запись типа этого множества?",
                                "Выберите тип этого множества"],
                     image: "Collections45",
                     optionA: "Set<String>",
                     optionB: "Character",
                     optionC: "String",
                     optionD: "Set<Character>",
                     questionId: 345,
                     helpText: "Любому знаку присваивается тип String, если не указать иного (Character). А так как это множество, то правильный ответ будет Set<String>."),
            
            Question(question: ["Если попытаться удалить элемент множества, которого в нем нет, что произойдет?",
                                "При удалении несуществующего элемента множества через remove(_:), что мы получим?",
                                "Если мы попытаемся удалить элемент из множества, но его там не окажется, что мы получим?"],
                     image: "",
                     optionA: "nil",
                     optionB: "Последний элемент множества",
                     optionC: "Первый элемент множества",
                     optionD: "",
                     questionId: 346,
                     helpText: "Вы можете удалить элемент из множества, используя метод remove(_:), который удаляет элемент, который является членом множества и возвращает удаленное значение или nil, если удаляемого элемента нет."),
            
            Question(question: ["У множества нет порядка, поэтому, чтобы удобнее его итерировать, используется этот метод с циклом for-in",
                                "Какой метод используется для порядкового итерирования множества через цикл for-in?",
                                "Итерация множества по порядку через цикл for-in будет удобнее после применения этого метода"],
                     image: "",
                     optionA: ".sorted()",
                     optionB: ".sort()",
                     optionC: ".filter()",
                     optionD: ".flatMap()",
                     questionId: 347,
                     helpText: "Множества в Swift не имеют определенного порядка. Для того, чтобы провести итерацию по множеству в определенном порядке, вам нужно использовать метод sorted(), который возвращает вам элементы коллекции в виде отсортированного массива, используя оператор <."),
            
            Question(question: ["Создание нового множества из всех значений двух множеств?"],
                     image: "Collections48",
                     optionA: "union(_:)",
                     optionB: "intersection(_:)",
                     optionC: "subtracting(_:)",
                     optionD: "symmetricDifference(_:)",
                     questionId: 348,
                     helpText: "Используйте метод union(_:) для создания нового множества, состоящего из всех значений двух входных множеств. Если в множествах значения повторяются - они не будут повторяться в новом множестве (все значения внутри множества уникальны). Допустим, есть одно множество one = [0, 1, 2, 3, 4, 5], и есть второе множество two = [3, 4, 5, 6], при выполнении one.union(two).sorted() мы получим [0, 1, 2, 3, 4, 5, 6]."),
            
            Question(question: ["Как создать новое множество только из общих значений двух множеств?"],
                     image: "Collections49",
                     optionA: "intersection(_:)",
                     optionB: "union(_:)",
                     optionC: "subtracting(_:)",
                     optionD: "symmetricDifference(_:)",
                     questionId: 349,
                     helpText: "Используйте метод intersection(_:) для создания нового множества из общих значений двух входных множеств. Допустим, есть одно множество one = [0, 1, 2, 3, 4, 5], и есть второе множество two = [3, 4, 5, 6], при выполнении one.intersection(two).sorted() мы получим [3, 4, 5]"),
            
            Question(question: ["Как из значений, не принадлежащих указанному множеству, создать новое множество?",
                                "Создать множество из значений, не принадлежащих указанному множеству, можно так",
                                "Как создать новое множество из значений, не принадлежащих указанному множеству?"],
                     image: "Collections50",
                     optionA: "subtracting(_:)",
                     optionB: "intersection(_:)",
                     optionC: "union(_:)",
                     optionD: "symmetricDifference(_:)",
                     questionId: 350,
                     helpText: "Используйте метод subtracting(_:) для создания множества со значениями не принадлежащих указанному множеству из двух входных. Допустим, есть одно множество one = [0, 1, 2, 3, 4, 5], и есть второе множество two = [3, 4, 5, 6], при выполнении one.subtracting(two).sorted() мы получим [0, 1, 2]."),
            
            Question(question: ["Метод создания множества из неповторяющихся значений двух входных множеств?"],
                     image: "Collections51",
                     optionA: "symmetricDifference(_:)",
                     optionB: "intersection(_:)",
                     optionC: "subtracting(_:)",
                     optionD: "union(_:)",
                     questionId: 351,
                     helpText: "Используйте метод symmetricDifference(_:) для создания нового множества из значений, которые не повторяются в двух входных множествах. Допустим, есть одно множество one = [0, 1, 2, 3, 4, 5], и есть второе множество two = [3, 4, 5, 6], при выполнении one.symmetricDifference(two).sorted() мы получим [0, 1, 2, 6]."),
            
            Question(question: ["Какое из этих множеств является надмножеством другого множества?",
                                "Выберите множество, которое является надмножеством"],
                     image: "Collections52",
                     optionA: "a",
                     optionB: "b",
                     optionC: "c",
                     optionD: "На картинке нет надмножеств",
                     questionId: 352,
                     helpText: "Иллюстрация отображает три множества a, b и c. Множество a является надмножеством множества b, так как содержит все его элементы."),
            
            Question(question: ["Какое из этих множеств является подмножеством другого множества?",
                                "Выберите множество, которое является подмножеством"],
                     image: "Collections52",
                     optionA: "b",
                     optionB: "a",
                     optionC: "c",
                     optionD: "На картинке нет подмножеств",
                     questionId: 353,
                     helpText: "Иллюстрация отображает три множества a, b и c. Множество b является подмножеством множества a потому, что все его элементы находятся в a."),
            
            Question(question: ["Какие из этих множеств являются разделенными?",
                                "На картинке есть два разделенных множества, какие?",
                                "Выберите два множества, которые можно назвать разделенными"],
                     image: "Collections52",
                     optionA: "b и c",
                     optionB: "a и b",
                     optionC: "c и a",
                     optionD: "Здесь нет разделенных",
                     questionId: 354,
                     helpText: "Иллюстрация отображает три множества a, b и c. Множества b и c называются разделенными, так как у них нет общих элементов."),
            
            Question(question: ["Какой метод поможет определить, все ли значения множества содержатся в указанном множестве?",
                                "Этот метод поможет узнать, все ли значения множества содержатся в указанном множестве"],
                     image: "",
                     optionA: "isSubset(of:)",
                     optionB: "isSuperset(of:)",
                     optionC: "isStrictSubset(of:)",
                     optionD: "isStrictSuperset(of:)",
                     questionId: 355,
                     helpText: "Используйте метод isSubset(of:) для определения все ли значения множества содержатся в указанном множестве. Например, let one: Set = [1, 2], let two: Set = [1, 2, 3, 4, 5], one.isSubset(of: two) вернет true, потому что все значения множества one содержатся в множестве two. Фактически мы определяем, является ли множество подмножеством указанного множества."),
            
            Question(question: ["Какой метод поможет определить, содержит ли множество все значения указанного множества?",
                                "Этот метод поможет узнать, содержит ли множество все значения указанного множества"],
                     image: "",
                     optionA: "isSuperset(of:)",
                     optionB: "isSubset(of:)",
                     optionC: "isStrictSubset(of:)",
                     optionD: "isStrictSuperset(of:)",
                     questionId: 356,
                     helpText: "Используйте метод isSuperset(of:), чтобы определить содержит ли множество все значения указанного множества. Например, let one: Set = [1, 2], let two: Set = [1, 2, 3, 4, 5], two.isSuperset(of: one) вернет true, потому что все значения множества one содержатся в множестве two. Фактически мы определяем, является ли множество надмножеством указанного множества."),
            
            Question(question: ["Как правильно пишется тип словаря в полной форме?",
                                "Выберите вариант, где корректно указан тип словаря в полной форме",
                                "В полной форме тип словаря записывается именно так"],
                     image: "",
                     optionA: "Dictionary<KeyType, ValueType>",
                     optionB: "Dictionary<KeyType>, <ValueType>",
                     optionC: "Dictionary(KeyType, ValueType)",
                     optionD: "<Dictionary(KeyType, ValueType)>",
                     questionId: 357,
                     helpText: "В Swift тип словаря в полной форме пишется как Dictionary<KeyType, ValueType>, где KeyType это тип значения который используется как ключ словаря, а ValueType это тип значения который словарь может хранить для этих ключей. Тип словаря KeyType должен подчиняться протоколу Hashable, как тип значения множества."),
            
            Question(question: ["У типа словаря есть краткая форма записи? Если да, то какая?",
                                "Есть ли краткая форма записи у словаря? Если да, то какая?"],
                     image: "",
                     optionA: "Да, [KeyType: ValueType]",
                     optionB: "Да, KeyType: ValueType",
                     optionC: "Да, <KeyType, ValueType>",
                     optionD: "Нет",
                     questionId: 358,
                     helpText: "Вы можете написать словарь в сокращенной форме как [KeyType: ValueType]. Хотя две формы функционально идентичны, краткая форма является предпочтительной и используется в данном руководстве при обращении к типу словаря."),
            
            Question(question: ["Как мы можем создать пустой словарь определенного типа с помощью синтаксиса инициализатора?",
                                "Создать пустой словарь определенного типа с помощью синтаксиса инициализатора мы можем именно так",
                                "Выберите вариант корректного создания пустого словаря с помощью синтаксиса инициализатора"],
                     image: "",
                     optionA: "var names = [Int: String]()",
                     optionB: "var names = Int: String[]",
                     optionC: "var names: [Int: String] = ()",
                     optionD: "var names: (Int: String) = []",
                     questionId: 359,
                     helpText: "Подобно массивам вы можете создать пустой словарь определенного типа с помощью синтаксиса инициализатора: var names = [Int: String](). В этом примере создается пустой словарь с типом [Int: String] для хранения удобных для восприятия имен числовых значений. Его ключи имеют тип Int, а значения - String."),
            
            Question(question: ["Как пишется литерал пустого словаря?",
                                "Литерал пустого словаря пишется именно так",
                                "Выберите вариант правильного написания литерала пустого словаря"],
                     image: "",
                     optionA: "[:]",
                     optionB: "[]",
                     optionC: "[](:)",
                     optionD: "{:}",
                     questionId: 360,
                     helpText: "Если контекст уже предоставляет информацию о типе (ранее мы уже инициализировали значения), вы можете создать пустой словарь с помощью литерала пустого словаря, который пишется как [:] ( двоеточие внутри пары квадратных скобок)."),
            
            Question(question: ["Выберите правильное создание словаря через литерал словаря",
                                "Словарь создается литералом словаря именно так",
                                "Какой из вариантов показывает правильно создание словаря через литерал словаря?"],
                     image: "",
                     optionA: "var a: [Int: String] = [0: \"Name\"]",
                     optionB: "var b = [Int: String](1: \"Name\")",
                     optionC: "var c: (Int: String)[0: \"Name\"]",
                     optionD: "var d: <Int: String>[0: \"Name\"]",
                     questionId: 361,
                     helpText: "Вы можете инициализировать словарь с помощью литерала словаря, который имеет схожий синтаксис с литералом массива. Литерал словаря это краткий способ написать одну или несколько пар ключ-значение в виде коллекций словаря. В литерале словаря, ключ и значение в каждой паре ключ-значение разделено двоеточием. Пары написаны как список, разделенный запятыми и окруженный парой квадратных скобок."),
            
            Question(question: ["Какой тип Swift присвоит этому словарю?",
                                "Swift присвоит этому словарю такой тип",
                                "Выберите какой тип присвоит этому словарю Swift"],
                     image: "Collections62",
                     optionA: "[Double : String]",
                     optionB: "[Int : Character]",
                     optionC: "[Int : String]",
                     optionD: "[Float : String]",
                     questionId: 362,
                     helpText: "Правильный ответ [Double : String], поскольку стандартно присваивается тип Double любому числу с плавающей точкой, без явного указания типа. Вторая часть, значение словаря, имеет тип String."),
            
            Question(question: ["Каким образом можно добавлять и изменять элементы словаря через синтаксис индексов?",
                                "Как через синтаксис индексов можно добавлять и изменять значения словаря?"],
                     image: "",
                     optionA: "dictionary[Key] = Value",
                     optionB: "dictionary.Key(Value)",
                     optionC: "dictionary.Key = [Value]",
                     optionD: "Значения словаря неизменяемы",
                     questionId: 363,
                     helpText: "Вы можете добавить новый элемент в словарь с помощью синтаксиса индексов. Используйте новый ключ соответствующего типа в качестве индекса, а затем присвойте новое значение соответствующего типа. Вы также можете использовать синтаксис индексов для изменения значения связанного с определенным ключом. Правильный ответ: dictionary[Key] = Value."),
            
            Question(question: ["Альтернативный способ установить или обновить значение для определенного ключа словаря",
                                "Установить или обновить значение для определенного ключа словаря можно таким способом",
                                "Как без использования синтаксиса индексов установить или обновить значение для определенного ключа словаря?"],
                     image: "",
                     optionA: "updateValue(forKey:)",
                     optionB: "update(key:)",
                     optionC: "changeValue(forKey:)",
                     optionD: "change(key:)",
                     questionId: 364,
                     helpText: "В качестве альтернативы индексам, можно использовать метод словаря updateValue(forKey:), чтобы установить или обновить значение для определенного ключа. Метод updateValue(forKey:) устанавливает значение для ключа если оно не существует, или обновляет значение, если этот ключ уже существует. Однако, в отличие от индексов, метод updateValue(forKey:) возвращает старое значение после выполнения обновления. Это позволяет вам проверить состоялось ли обновление или нет."),
            
            Question(question: ["Если при применении updateValue(forKey:) значение не существовало, что нам вернется?",
                                "Что вернется, если при применении updateValue(forKey:) к словарю, данное значение не существовало?"],
                     image: "",
                     optionA: "nil",
                     optionB: "0",
                     optionC: "Ничего",
                     optionD: "Опциональный тип",
                     questionId: 365,
                     helpText: "Метод updateValue(forKey:) возвращает опциональное значение соответствующее типу значения словаря. Например, для словаря, который хранит String значения, метод вернет String? тип, или опциональный String. Это опциональное значение содержит старое значение для этого ключа, если оно существовало до обновления, либо nil если значение не существовало."),
            
            Question(question: ["Если мы попытаемся получить доступ в несуществующему значению словаря через синтаксис индексов, что мы получим?",
                                "Что вернется при попытке получить доступ к несуществующему значению словаря через синтаксис индексов?"],
                     image: "",
                     optionA: "nil",
                     optionB: "Ничего",
                     optionC: "Рандомное значение",
                     optionD: "Столкнемся с ошибкой",
                     questionId: 366,
                     helpText: "Поскольку есть вероятность запросить ключ для несуществующего значения, индекс словаря возвращает опциональное значение соответствующее типу значений словаря. Если словарь содержит значение для запрошенного ключа, индекс возвращает опциональное значение, содержащее существующее значение для этого ключа. В противном случае индекс возвращает nil."),
            
            Question(question: ["Как мы можем удалить пару ключ-значение из словаря с помощью синтаксиса индексов?",
                                "Мы можем удалить пару ключ-значение из словаря с использованием синтаксиса индексов, как?",
                                "Каким образом, используя синтаксис индексов, вы можете удалить из словаря пару ключ-значение?"],
                     image: "",
                     optionA: "dict[Key] = nil",
                     optionB: "dict[Key] = []",
                     optionC: "dict[Key] = 0",
                     optionD: "dict[Key].remove()",
                     questionId: 367,
                     helpText: "Вы можете использовать синтаксис индексов для удаления пары ключ-значение из словаря путем присвоения nil значению для этого ключа."),
            
            Question(question: ["Этот метод удаляет пару ключ-значение если она существует и затем возвращает значение, либо возвращает nil если значения не существует",
                                "Метод, который удаляет пару ключ-значение если она существует, а затем возвращает значение, либо возвращает nil если значения не существует"],
                     image: "",
                     optionA: "removeValue(forKey:)",
                     optionB: "remove(forKey:)",
                     optionC: "removeValue(Key:)",
                     optionD: "deleteValue(forKey:)",
                     questionId: 368,
                     helpText: "Можно удалить пару ключ-значение из словаря с помощью метода removeValue(forKey:). Этот метод удаляет пару ключ-значение если она существует и затем возвращает значение, либо возвращает nil если значения не существует."),
            
            Question(question: ["Какое значение будет у константы first?"],
                     image: "Collections69",
                     optionA: "9",
                     optionB: "10",
                     optionC: "8",
                     optionD: "Столкнемся с ошибкой",
                     questionId: 369,
                     helpText: "Числам (индексам) ниже 10 можно приписывать нули. В этой стилистической надстройке нет прямой необходимости, но иногда она может сделать код более читаемым."),
            
            Question(question: ["У стандартных типов коллекций в Swift есть оптимизация, позволяющая сократить затраты на копирование большого количества элементов, из-за нее элементы копируются... ",
                                "Чтобы минимизировать затраты на копирование большого количества элементов у типов коллекций (массив, словарь, строка), в Swift используется данная оптимизация: \"Элементы копируются...\""],
                     image: "",
                     optionA: "Только после модификации",
                     optionB: "Не копируются",
                     optionC: "В глобальном потоке",
                     optionD: "Специальным алгоритмом",
                     questionId: 370,
                     helpText: "Коллекции, определенные стандартной библиотекой, такие как массивы, словари и строки, используют оптимизацию для снижения затрат на копирование. Вместо того, чтобы немедленно сделать копию, эти коллекции совместно используют память, в которой элементы хранятся между исходным экземпляром и любыми копиями. Если одна из копий коллекции модифицирована, элементы копируются непосредственно перед изменением."),
            
            Question(question: ["Какое значение мы получим в консоль?"],
                     image: "Subscripts15",
                     optionA: "4",
                     optionB: "3",
                     optionC: "2",
                     optionD: "Столкнемся с ошибкой",
                     questionId: 371,
                     helpText: "Правильный ответ: 4. В примере мы объявляем переменную numberOfLegs и инициализируем ее с помощью литерала словаря, который содержит три пары ключ-значение. Тип словаря numberOfLegs выводится как [String: Int]. После того как словарь создан, в этом примере используется сабскриптное присваивание для добавления ключа типа String “птичка“, значения типа Int 2."),
            
            Question(question: ["Что вернет функция addNewBook(), если в нашей library уже будет Book с таким book.id?"],
                     image: "Collections72",
                     optionA: "false",
                     optionB: "true",
                     optionC: "Значение book.id",
                     optionD: "Столкнемся с ошибкой",
                     questionId: 372,
                     helpText: "Метод updateValue(forKey:) устанавливает значение для ключа если оно не существует, или обновляет значение, если этот ключ уже существует. Например, для словаря, который хранит String значения, метод вернет String? тип, или опциональный String. Это опциональное значение содержит старое значение для этого ключа, если оно существовало до обновления, либо nil если значение не существовало. В нашем случае, так как книга уже находится в нашей library, функция вернет нам уже имевшуюся там Book?, а значит при сравнении с nil (== nil) мы получим false."),
            
            Question(question: ["Что вернет функция deleteBook(), если в нашей library уже будет Book с таким book.id?"],
                     image: "Collections73",
                     optionA: "true",
                     optionB: "false",
                     optionC: "Значение book.id",
                     optionD: "",
                     questionId: 373,
                     helpText: "Можно удалить пару ключ-значение из словаря с помощью метода removeValue(forKey:). Этот метод удаляет пару ключ-значение если она существует и затем возвращает значение, либо возвращает nil если значения не существует. В нашем случае, книга уже находится в библиотеке, а значит при удалении нам вернется ее значение. При сравнении на неравенство nil (!= nil) мы получим true."),
            
            Question(question: ["Что мы получим в консоль?",
                                "Какие значения мы получим в консоль?"],
                     image: "Collections74",
                     optionA: "[1, 2, 3]",
                     optionB: "0, 1, 2",
                     optionC: "[2, 3, 4]",
                     optionD: "3",
                     questionId: 374,
                     helpText: "prefix(_ maxLength: Int) возвращает последовательность, состоящую из исходных элементов коллекции, в количестве maxLength, указанном пользователем, начиная с начала исходной последовательности. То есть мы получим [1, 2, 3]."),
            
            Question(question: ["Что мы получим в консоль?"],
                     image: "Collections75",
                     optionA: "[3, 4, 5]",
                     optionB: "[1, 2, 3]",
                     optionC: "[2, 3, 4]",
                     optionD: "3",
                     questionId: 375,
                     helpText: "suffix(_ maxLength: Int) возвращает последовательность, состоящую из исходных элементов коллекции, в количестве maxLength, указанном пользователем, начиная с конца исходной последовательности. То есть мы получим [3, 4, 5]. Если maxLength превышает количество элементов исходной последовательности - мы получим все ее элементы."),
            
            Question(question: ["Какие города объединятся в словаре grouped при группировке словаря по такому признаку?"],
                     image: "Collections76",
                     optionA: "Shanghai и Seoul",
                     optionB: "Shanghai и Karachi",
                     optionC: "Shanghai и Beijing",
                     optionD: "Beijing и Karachi",
                     questionId: 376,
                     helpText: "Shanghai и Seoul. При инициализации словаря используется входной аргумент grouping, в качестве значения которому передается анализируемые ключи словаря cities. После инициализатора указывается замыкание, в соответствии с которым и производится группировка значений (в данном случае по первому символу ключа)."),

            Question(question: ["Можем ли мы присваивать значение по умолчанию для элемента словаря, при попытке обратиться по несуществующему имени?",
                                "Чтобы избежать nil, при попытке обратиться к несуществующему элементу словаря, мы можем присвоить дефолтное значение при обращении. Так ли это?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 377,
                     helpText: "Если вы используете доступ к элементам словаря через сабскрипт, то при попытке обратиться по неcуществующему имени вам будет возвращен nil. Теперь вы можете указать значение по умолчанию, которое будет возвращено при попытке доступа к несуществующему элементу. Для этого служит свойство default, указываемое в сабскрипте. [key, default: value]."),

            Question(question: ["Какое ключевое слово используется для маппинга словаря?",
                                "Ключевое слово, которое используется при маппинге словарей?"],
                     image: "",
                     optionA: ".mapValues",
                     optionB: ".map",
                     optionC: ".filter",
                     optionD: ".reduce",
                     questionId: 378,
                     helpText: "Обработка (маппинг) значений элементов словарей делается с помощью метода mapValues(_:), в который передается замыкание. Доступ осуществляется поочередно к значению каждого элемента словаря."),

            Question(question: ["В результате словаря мы получим новую коллекцию элементов или изменим старую?",
                                "При фильтрации словаря старая коллекция остается неизменной. Так ли это?",
                                "Результатом фильтрации словаря является новая коллекция того же типа, это правда?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 379,
                     helpText: "В результате фильтрации словаря через .filter {} нам вернется новая коллекция того же типа, что и исходная. Старая коллекция остается неизменной."),

            Question(question: ["С помощью какой функции мы можем объединить две разные последовательности значений в один словарь?",
                                "Эта функция позволит вам объединить две последовательности в один словарь",
                                "С помощью этой функции вы можете проинициализировать две последовательности значений в один словарь"],
                     image: "",
                     optionA: "zip(_:_:)",
                     optionB: "Dictionary()",
                     optionC: "mapValues(_:)",
                     optionD: "Subscripting",
                     questionId: 380,
                     helpText: "Функция zip(_:_:) возвращает последовательность пар, основанную на двух базовых последовательностях, после чего должна передавать его свойству uniqueKeysWithValues инициализатора Dictionary. Результирующий словарь будет содержать в качестве ключей значения первой базовой коллекции, а в качестве значения - элементы второй базовой коллекции."),

//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 381,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 382,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 383,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 384,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 385,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 386,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 387,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 388,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 389,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 390,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 391,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 392,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 393,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 394,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 395,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 396,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 397,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 398,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 399,
//                     helpText: ""),
//
//            Question(question: ["",
//                                "",
//                                ""],
//                     image: "",
//                     optionA: "",
//                     optionB: "",
//                     optionC: "",
//                     optionD: "",
//
//                     questionId: 400,
//                     helpText: "")
        ]
    }
}
