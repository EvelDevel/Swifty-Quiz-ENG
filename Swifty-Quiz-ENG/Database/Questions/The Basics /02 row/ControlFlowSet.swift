
//  Created by Евгений Никитин on 11.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

// MARK: 05 - Вопросы (id) с 401 по 500

class ControlFlowSet {
	static func getQuestions() -> [Question] {
		return [
			Question (question: ["How many ways to loop through blocks of code does Swift support?",
								 "Swift provides this many ways to loop through blocks of code"],
					  image: "",
					  optionA: "Three",
					  optionB: "Two",
					  optionC: "Four",
					  optionD: "",
					  questionId: 401,
					  helpText: "Three: for-in, while, repeat-while."),
			
			Question(question: ["What is the for-in loop normally used for?",
								"The for-in loop is normally used for ..."],
					 image: "",
					 optionA: "Iterating over a sequence",
					 optionB: "Perfoming a single pass through the loop",
					 optionC: "Storing key-values pairs",
					 optionD: "Iterating while condition is true",
					 questionId: 402,
					 helpText: "You use the for-in loop to iterate over a sequence, such as items in an array, ranges of numbers, or characters in a string."),
			
			Question(question: ["We can decompose the members of the returned value as explicitly named constants when iterating over that collection type",
								"The returned single value of that collection type can be decomposed into separate constants while iterating over it",
								"Iterating over which collection returns a tuple of values that can be decomposed into separate constants?"],
					 image: "",
					 optionA: "Dictionary",
					 optionB: "Set",
					 optionC: "Array",
					 optionD: "",
					 questionId: 403,
					 helpText: "You can iterate over a dictionary to access its key-value pairs. Each item in the dictionary is returned as a (key, value) tuple when the dictionary is iterated, and you can decompose the (key, value) tuple’s members as explicitly named constants for use within the body of the for-in loop."),
			
			Question(question: ["In the given code snippet, is index a variable or a constant?"],
					 image: "ControlFlow4",
					 optionA: "Variable",
					 optionB: "Constant",
					 optionC: "",
					 optionD: "",
					 questionId: 404,
					 helpText: "Index is a constant whose value is automatically set at the start of each iteration of the loop. As such, index does not have to be declared before it is used. It is implicitly declared simply by its inclusion in the loop declaration, without the need for a let declaration keyword."),
			
			Question(question: ["Select the line that will be printed to the console last?"],
					 image: "ControlFlow4",
					 optionA: "5 + 5 = 10",
					 optionB: "3 + 5 = 8",
					 optionC: "4 + 5 = 9",
					 optionD: "2 + 5 = 7",
					 questionId: 405,
					 helpText: "Correct answer: 5 + 5 = 10. The sequence being iterated over is a range of numbers from 1 to 5, inclusive, as indicated by the use of the closed range operator (...). The value of index is set to the first number in the range (1), and the statements inside the loop are executed. In this case, the loop contains only one statement, which prints an entry from the five-times table for the current value of the index. After the statement is executed, the value of index is updated to contain the second value in the range (2), and the print(_:separator:terminator:) function is called again. This process continues until the end of the range is reached."),
			
			Question(question: ["Can we ignore \"example\" here?"],
					 image: "ControlFlow6",
					 optionA: "Yes, by using an underscore",
					 optionB: "Yes, by using space instead of name",
					 optionC: "Yes, use the colon sign instead",
					 optionD: "No, we can't ignore it",
					 questionId: 406,
					 helpText: "For this calculation, the individual counter values each time through the loop are unnecessary—the code simply executes the loop the correct number of times. The underscore character (_) used in place of a loop variable causes the individual values to be ignored and does not provide access to the current value during each iteration of the loop."),
			
			Question(question: ["Which range operator should we use to include the lower bound but not the upper bound?",
								"The operator that lets us include only the lower bound of a range",
								"How can we exclude the upper bound of a range while iterating through a for-in loop?"],
					 image: "",
					 optionA: "..<",
					 optionB: "...",
					 optionC: "..>",
					 optionD: "",
					 questionId: 407,
					 helpText: "Use the half-open range operator (..<) to include the lower bound but not the upper bound."),
			
			Question(question: ["What values will we get in the console?",
								"What values will be printed to the console?"],
					 image: "ControlFlow8",
					 optionA: "2, 4, 6",
					 optionB: "0, 2, 4, 6",
					 optionC: "2, 4, 6, 8",
					 optionD: "4, 6",
					 questionId: 408,
					 helpText: "Correct answer: 2, 4, 6. You might want fewer tick marks in your UI. If, for example, you prefer one mark every 5 minutes instead, use the stride(from:to:by:) function to skip the unwanted marks. This function does not capture the last value of the range (8)."),
			
			Question(question: ["What values will we get in the console?",
								"What values will be printed to the console?"],
					 image: "ControlFlow9",
					 optionA: "2, 4, 6, 8",
					 optionB: "0, 2, 4, 6",
					 optionC: "2, 4, 6",
					 optionD: "4, 6, 8",
					 questionId: 409,
					 helpText: "Closed ranges are also available, by using stride(from:through:by:), so the correct answer: 2, 4, 6, 8. The \"through\" inside this method tells us that the last value in the range will also be captured and printed to the console."),
			
			Question(question: ["A while loop performs a set of statements until ... ",
								"The while loop executes a set of instructions until as long as ... ",
								"What must happen in a while loop for it to stop executing its set of instructions?"],
					 image: "",
					 optionA: "Condition becomes false",
					 optionB: "Upper bound of the range is reached",
					 optionC: "It runs out of items in collection",
					 optionD: "",
					 questionId: 410,
					 helpText: "A while loop performs a set of statements until a condition becomes false. These kinds of loops are best used when the number of iterations is not known before the first iteration begins. Swift provides two kinds of while loops: while evaluates its condition at the start of each pass through the loop, repeat-while evaluates its condition at the end of each pass through the loop."),
			
			Question(question: ["The first iteration of the while loop will be executed only in this case",
								"The first iteration of the while loop will run ... ",
								"On what condition will the first iteration of the while loop be executed?"],
					 image: "",
					 optionA: "If the condition is true",
					 optionB: "If the condition is false",
					 optionC: "In any case",
					 optionD: "",
					 questionId: 411,
					 helpText: "A while loop starts by evaluating a single condition. If the condition is true, a set of statements is repeated until the condition becomes false."),
			
			Question(question: ["The first iteration of the repeat-while loop will be executed only in this case",
								"The first iteration of the repeat-while loop will run ... ",
								"When will the first iteration of the repeat-while loop start executing?"],
					 image: "",
					 optionA: "In any case",
					 optionB: "If the condition is true",
					 optionC: "If the condition is false",
					 optionD: "",
					 questionId: 412,
					 helpText: "Repeat-while loop performs a single pass through the loop block first, before considering the loop’s condition. It then continues to repeat the loop until the condition is false."),
			
			Question(question: ["Which way to add conditional branches is preferable if we need to evaluate simple conditions with only a few possible outcomes?"],
					 image: "",
					 optionA: "if statement",
					 optionB: "switch statement",
					 optionC: "",
					 optionD: "",
					 questionId: 413,
					 helpText: "Swift provides two ways to add conditional branches to your code: the if statement and the switch statement. Typically, you use the if statement to evaluate simple conditions with only a few possible outcomes. The switch statement is better suited to more complex conditions with multiple possible permutations and is useful in situations where pattern matching can help select an appropriate code branch to execute."),
			
			Question(question: ["The if statement executes a set of statements only if ...",
								"The if statement will execute the set of instructions only in the following case",
								"When will the body of the if statement be executed?"],
					 image: "",
					 optionA: "The condition is true",
					 optionB: "The condition is false",
					 optionC: "In any case",
					 optionD: "",
					 questionId: 414,
					 helpText: "In its simplest form, the if statement has a single if condition. It executes a set of statements only if that condition is true."),
			
			Question(question: ["If the condition in an if statement is false, which keyword can you use to proceed?",
								"How can you introduce an additional branch to an if statement?",
								"Which of the following keywords adds an alternative to an if statement?"],
					 image: "",
					 optionA: "else",
					 optionB: "optional",
					 optionC: "another",
					 optionD: "but",
					 questionId: 415,
					 helpText: "The if statement can provide an alternative set of statements, known as an else clause, for situations when the if condition is false. These statements are indicated by the else keyword."),
			
			Question(question: ["Once Swift finds a case that matches the value we are comparing in a switch statement, will it proceed to compare the value against the rest of available cases?",
								"If we’ve already got a match inside a switch statement, will the rest of cases be also checked anyway?",
								"Does Swift run through all the matching patterns of a switch statement even though one of them has already been matched?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "Yes, there’s a default case",
					 optionD: "",
					 questionId: 416,
					 helpText: "A switch statement considers a value and compares it against several possible matching patterns. It then executes an appropriate block of code, based on the first pattern that matches successfully. A switch statement provides an alternative to the if statement for responding to multiple potential states."),
			
			Question(question: ["Is the default case inside a switch statement always required?",
								"Is it necessary to use the default case inside a switch statement every time?",
								"Are we obliged to provide each switch statement with a default case?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 417,
					 helpText: "Every switch statement must be exhaustive. That is, every possible value of the type being considered must be matched by one of the switch cases. If it’s not appropriate to provide a case for every possible value, you can define a default case to cover any values that are not addressed explicitly. This default case is indicated by the default keyword, and must always appear last."),
			
			Question(question: ["What is the difference between the way switch statements work in Swift and in Objective-C?",
								"Switch statements in Swift and Objective-C have one important difference, which one?"],
					 image: "",
					 optionA: "No implicit fallthrough",
					 optionB: "Default cases",
					 optionC: "Limited number of cases",
					 optionD: "",
					 questionId: 418,
					 helpText: "In contrast with switch statements in C and Objective-C, switch statements in Swift do not fall through the bottom of each case and into the next one by default. Instead, the entire switch statement finishes its execution as soon as the first matching switch case is completed, without requiring an explicit break statement. This makes the switch statement safer and easier to use than the one in C and avoids executing more than one switch case by mistake."),
			
			Question(question: ["Can we use a break statement inside a switch case?",
								"Although break statement is not required in switch cases in Swift, can we still use it without causing any errors?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 419,
					 helpText: "Although break is not required in Swift, you can use a break statement to match and ignore a particular case or to break out of a matched case before that case has completed its execution."),
			
			Question(question: ["What must each switch statement case contain?",
								"Choose what must be contained inside each switch statement case"],
					 image: "",
					 optionA: "At least one executable statement",
					 optionB: "One condition and one statement",
					 optionC: "An operator that returns Bool",
					 optionD: "A fallthrough keyword",
					 questionId: 420,
					 helpText: "The body of each case must contain at least one executable statement. If any case does not contain any executable statements Swift reports that as compile-time error."),
			
			Question(question: ["What separates values inside a compound case in a switch statement?",
								"You can use compound cases inside a switch statement, how can you separate their values?"],
					 image: "",
					 optionA: "Comma",
					 optionB: "Backslash",
					 optionC: "Space",
					 optionD: "Semicolon",
					 questionId: 421,
					 helpText: "To make a switch with a single case that matches at least one of several values, combine the the values into a compound case, separating the values with commas: case  \"a\", \"A\""),
			
			Question(question: ["What will we get into the console?"],
					 image: "ControlFlow23",
					 optionA: "2",
					 optionB: "1",
					 optionC: "3",
					 optionD: "4",
					 questionId: 422,
					 helpText: "Correct answer: 2. You can use tuples to test multiple values in the same switch statement. Each element of the tuple can be tested against a different value or interval of values. Alternatively, use the underscore character (_), also known as the wildcard pattern, to match any possible value. Our example takes an (x, y) point, expressed as a simple tuple of type (Int, Int), and categorizes it on the graph that follows the example."),
			
			Question(question: ["If multiple matches are possible in a switch, which one will be used?"],
					 image: "",
					 optionA: "The first matching case",
					 optionB: "A random matching case",
					 optionC: "The last matching case",
					 optionD: "",
					 questionId: 423,
					 helpText: "Unlike C, Swift allows multiple switch cases to consider the same value or values. However, if multiple matches are possible, the first matching case is always used, and so all other matching cases would be ignored."),
			
			Question(question: ["After the value binding, what value will we get at the end of the following code?"],
					 image: "ControlFlow25",
					 optionA: "2",
					 optionB: "0",
					 optionC: "2, 0",
					 optionD: "",
					 questionId: 424,
					 helpText: "A switch case can name the value or values it matches to temporary constants or variables, for use in the body of the case. This behavior is known as value binding, because the values are bound to temporary constants or variables within the case’s body. The three switch cases declare placeholder constants x and y, which temporarily take on one or both tuple values from anotherPoint. The first case, case (let x, 0), matches any point with a y value of 0 and assigns the point’s x value to the temporary constant x. Similarly, the second case, case (0, let y), matches any point with an x value of 0 and assigns the point’s y value to the temporary constant y. After the temporary constants are declared, they can be used within the case’s code block. Here, they are used to print the categorization of the point."),
			
			Question(question: ["Why does the following switch statement not have a default case?",
								"In the given code snippet, the default case is not used. Why?",
								"This is why we don’t use the default case here"],
					 image: "ControlFlow25",
					 optionA: "This statement is exhaustive",
					 optionB: "It’s required, so we’ll get an error",
					 optionC: "Because of the value binding",
					 optionD: "",
					 questionId: 425,
					 helpText: "This switch statement does not have a default case. The final case, case let (x, y), declares a tuple of two placeholder constants that can match any value. Because anotherPoint is always a tuple of two values, this case matches all possible remaining values, and a default case is not needed to make the switch statement exhaustive."),
			
			Question(question: ["Can we combine multiple switch cases that share the same body?",
								"Can patterns be written over multiple lines after the same case keyword if the list is long?"],
					 image: "ControlFlow28",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 426,
					 helpText: "Multiple switch cases that share the same body can be combined by writing several patterns after the case keyword, with a comma between each of the patterns. If any of the patterns match, then the case is considered to match. The patterns can be written over multiple lines if the list is long."),
			
			Question(question: ["Can compound cases include value bindings?",
								"Is value bindings available in compound cases?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 427,
					 helpText: "Compound cases can include value bindings. All of the patterns of a compound case have to include the same set of value bindings, and each binding has to get a value of the same type from all of the patterns in the compound case. This ensures that, no matter which part of the compound case matched, the code in the body of the case can always access a value for the bindings and that the value always has the same type."),
			
			Question(question: ["Given the following code, what result will we get?"],
					 image: "ControlFlow30",
					 optionA: "9",
					 optionB: "0",
					 optionC: "default",
					 optionD: "",
					 questionId: 428,
					 helpText: "The case above has two patterns: (let x, 0) matches points on the x-axis and (0, let x) matches points on the y-axis. Both patterns include a binding for x and x is an integer in both patterns—which means that the code in the body of the case can always access a value for x."),
			
			Question(question: ["How many control transfer statements are available in Swift?",
								"The number of control transfer statements available in Swift",
								"How many control transfer statements does Swift support?"],
					 image: "",
					 optionA: "Five",
					 optionB: "Four",
					 optionC: "Three",
					 optionD: "Twenty two",
					 questionId: 429,
					 helpText: "Control transfer statements change the order in which your code is executed, by transferring control from one piece of code to another. Swift has five control transfer statements: continue, break, fallthrough, return, throw."),
			
			Question(question: ["Which control transfer statement tells the loop to stop what it is doing and start again at the beginning of the next iteration?",
								"The control transfer operator that tells the loop: \"I finished with the current iteration, we can move on to the next one\""],
					 image: "",
					 optionA: "continue",
					 optionB: "break",
					 optionC: "fallthrough",
					 optionD: "return",
					 questionId: 430,
					 helpText: "The continue statement tells a loop to stop what it is doing and start again at the beginning of the next iteration through the loop. It says “I am done with the current loop iteration” without leaving the loop altogether."),
			
			Question(question: ["Which control transfer statement ends execution of an entire control flow statement immediately?",
								"The control transfer operator that ends execution of an entire control flow statement immediately"],
					 image: "",
					 optionA: "break",
					 optionB: "continue",
					 optionC: "fallthrough",
					 optionD: "",
					 questionId: 431,
					 helpText: "The break statement ends execution of an entire control flow statement immediately. The break statement can be used inside a switch or loop statement when you want to terminate the execution of the switch or loop statement earlier than would otherwise be the case."),
			
			Question(question: ["When a break control statement is called inside a loop, will the next iteration occur?",
								"Will the next iteration occur if a break control statement is executed inside a loop?",
								"If a break control statement is called inside a loop, a new loop iteration starts immediately. Is that correct?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 432,
					 helpText: "When used inside a loop statement, break ends the loop’s execution immediately and transfers control to the code after the loop’s closing brace (}). No further code from the current iteration of the loop is executed, and no further iterations of the loop are started."),
			
			Question(question: ["What happens when a break statement is executed inside a switch case?",
								"What will happen if a switch case comes across the break keyword?",
								"If a switch case contains no code but a single break keyword, what will happen?"],
					 image: "",
					 optionA: "Switch statement ends immediately",
					 optionB: "Switch moving on to the next case",
					 optionC: "We start the process over again",
					 optionD: "We will get an error",
					 questionId: 433,
					 helpText: "When used inside a switch statement, break causes the switch statement to end its execution immediately and to transfer control to the code after the switch statement’s closing brace (}). This behavior can be used to match and ignore one or more cases in a switch statement. Because Swift’s switch statement is exhaustive and does not allow empty cases, it is sometimes necessary to deliberately match and ignore a case in order to make your intentions explicit. You do this by writing the break statement as the entire body of the case you want to ignore. When that case is matched by the switch statement, the break statement inside the case ends the switch statement’s execution immediately."),
			
			Question(question: ["A switch case that contains only a comment is reported as a compile-time error. Is that true?",
								"Comments are not statements and do not cause a switch case to be ignored. Is that correct?",
								"Can you ignore an empty switch statement using the break keyword?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 434,
					 helpText: "A switch case that contains only a comment is reported as a compile-time error. Comments are not statements and do not cause a switch case to be ignored. Always use a break statement to ignore a switch case."),
			
			Question(question: ["Which control transfer statement will let you pass to the next case inside a switch even though the current case was matched?",
								"The control transfer statement that explicitly makes Swift fall into the next case inside a switch"],
					 image: "",
					 optionA: "fallthrough",
					 optionB: "continue",
					 optionC: "throw",
					 optionD: "return",
					 questionId: 435,
					 helpText: "In Swift, switch statements don’t fall through the bottom of each case and into the next one. That is, the entire switch statement completes its execution as soon as the first matching case is completed. If you need C-style fallthrough behavior, you can opt in to this behavior on a case-by-case basis with the fallthrough keyword."),
			
			Question(question: ["Can you nest loops in Swift?",
								"Can we nest switch statements in Swift?",
								"Can you nest loops and conditional statements inside other loops and conditional statements?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 436,
					 helpText: "In Swift, you can nest loops and conditional statements inside other loops and conditional statements to create complex control flow structures. However, loops and conditional statements can both use the break statement to end their execution prematurely."),
			
			Question(question: ["The guard instruction only executes the code inside the brackets when its condition is ...?",
								"An early exit instruction guard executes the code inside its brackets depending on the Boolean value of its condition. Which one?"],
					 image: "",
					 optionA: "false",
					 optionB: "true",
					 optionC: "",
					 optionD: "",
					 questionId: 437,
					 helpText: "A guard statement, like an if statement, executes statements depending on the Boolean value of an expression. You use a guard statement to require that a condition must be true in order for the code after the guard statement to be executed. Unlike an if statement, a guard statement always has an else clause—the code inside the else clause is executed if the condition is not true."),
			
			Question(question: ["If the guard statement’s condition is met, will the code inside the guard statement be executed?",
								"If the guard’s condition returns true, will the else code block be executed?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 438,
					 helpText: "If the guard statement’s condition is met, code execution continues after the guard statement’s closing brace. Any variables or constants that were assigned values using an optional binding as part of the condition are available for the rest of the code block that the guard statement appears in. If that condition is not met, the code inside the else branch is executed. That branch must transfer control to exit the code block in which the guard statement appears. It can do this with a control transfer statement such as return, break, continue, or throw, or it can call a function or method that doesn’t return, such as fatalError(_:file:line:)."),
			
			Question(question: ["Is it preferable to use an if statement or a guard statement?",
								"Which statement should you consider using first?"],
					 image: "",
					 optionA: "guard",
					 optionB: "if",
					 optionC: "",
					 optionD: "",
					 questionId: 439,
					 helpText: "Using a guard statement for requirements improves the readability of your code, compared to doing the same check with an if statement. It lets you write the code that’s typically executed without wrapping it in an else block, and it lets you keep the code that handles a violated requirement next to the requirement."),
			
			Question(question: ["What value will we get at the end of the following code?"],
					 image: "ControlFlow42",
					 optionA: "2",
					 optionB: "0",
					 optionC: "1",
					 optionD: "3",
					 questionId: 440,
					 helpText: "Correct answer: 2. When we will definitely get into the first case of the switch-case, we will change the value of the variable and then fall into the next case using the fallthrough operator, and there we will change the value of the variable a second time.")
		]
	}
	
	
	
	
	/// 
	
	
	static func getDemoQuestions() -> [Question] {
		return [
			Question (question: ["How many ways to loop through blocks of code does Swift support?",
								 "Swift provides this many ways to loop through blocks of code"],
					  image: "",
					  optionA: "Three",
					  optionB: "Two",
					  optionC: "Four",
					  optionD: "",
					  questionId: 401,
					  helpText: "Three: for-in, while, repeat-while."),
			
			Question(question: ["What is the for-in loop normally used for?",
								"The for-in loop is normally used for ..."],
					 image: "",
					 optionA: "Iterating over a sequence",
					 optionB: "Perfoming a single pass through the loop",
					 optionC: "Storing key-values pairs",
					 optionD: "Iterating while condition is true",
					 questionId: 402,
					 helpText: "You use the for-in loop to iterate over a sequence, such as items in an array, ranges of numbers, or characters in a string."),
			
			Question(question: ["We can decompose the members of the returned value as explicitly named constants when iterating over that collection type",
								"The returned single value of that collection type can be decomposed into separate constants while iterating over it",
								"Iterating over which collection returns a tuple of values that can be decomposed into separate constants?"],
					 image: "",
					 optionA: "Dictionary",
					 optionB: "Set",
					 optionC: "Array",
					 optionD: "",
					 questionId: 403,
					 helpText: "You can also iterate over a dictionary to access its key-value pairs. Each item in the dictionary is returned as a (key, value) tuple when the dictionary is iterated, and you can decompose the (key, value) tuple’s members as explicitly named constants for use within the body of the for-in loop."),
			
			Question(question: ["In the given code snippet, is index a variable or a constant?"],
					 image: "ControlFlow4",
					 optionA: "Variable",
					 optionB: "Constant",
					 optionC: "",
					 optionD: "",
					 questionId: 404,
					 helpText: "Index is a constant whose value is automatically set at the start of each iteration of the loop. As such, index does not have to be declared before it is used. It is implicitly declared simply by its inclusion in the loop declaration, without the need for a let declaration keyword."),
			
			Question(question: ["Select the line that will be printed to the console last?"],
					 image: "ControlFlow4",
					 optionA: "5 + 5 = 10",
					 optionB: "3 + 5 = 8",
					 optionC: "4 + 5 = 9",
					 optionD: "2 + 5 = 7",
					 questionId: 405,
					 helpText: "Correct answer: 5 + 5 = 10. The sequence being iterated over is a range of numbers from 1 to 5, inclusive, as indicated by the use of the closed range operator (...). The value of index is set to the first number in the range (1), and the statements inside the loop are executed. In this case, the loop contains only one statement, which prints an entry from the five-times table for the current value of the index. After the statement is executed, the value of index is updated to contain the second value in the range (2), and the print(_:separator:terminator:) function is called again. This process continues until the end of the range is reached."),
			
			Question(question: ["Can we ignore \"example\" here?"],
					 image: "ControlFlow6",
					 optionA: "Yes, by using an underscore",
					 optionB: "Yes, by using space instead of name",
					 optionC: "Yes, use the colon sign instead",
					 optionD: "No, we can't ignore it",
					 questionId: 406,
					 helpText: "For this calculation, the individual counter values each time through the loop are unnecessary—the code simply executes the loop the correct number of times. The underscore character (_) used in place of a loop variable causes the individual values to be ignored and does not provide access to the current value during each iteration of the loop."),
			
			Question(question: ["Which range operator should we use to include the lower bound but not the upper bound?",
								"The operator that lets us include only the lower bound of a range",
								"How can we exclude the upper bound of a range while iterating through a for-in loop?"],
					 image: "",
					 optionA: "..<",
					 optionB: "...",
					 optionC: "..>",
					 optionD: "",
					 questionId: 407,
					 helpText: "Use the half-open range operator (..<) to include the lower bound but not the upper bound."),
			
			Question(question: ["What values will we get in the console?",
								"What values will be printed to the console?"],
					 image: "ControlFlow8",
					 optionA: "2, 4, 6",
					 optionB: "0, 2, 4, 6",
					 optionC: "2, 4, 6, 8",
					 optionD: "4, 6",
					 questionId: 408,
					 helpText: "Correct answer: 2, 4, 6. You might want fewer tick marks in your UI. If, for example, you prefer one mark every 5 minutes instead, use the stride(from:to:by:) function to skip the unwanted marks. This function does not capture the last value of the range (8)."),
			
			Question(question: ["What values will we get in the console?",
								"What values will be printed to the console?"],
					 image: "ControlFlow9",
					 optionA: "2, 4, 6, 8",
					 optionB: "0, 2, 4, 6",
					 optionC: "2, 4, 6",
					 optionD: "4, 6, 8",
					 questionId: 409,
					 helpText: "Closed ranges are also available, by using stride(from:through:by:), so the correct answer: 2, 4, 6, 8. The \"through\" inside this method tells us that the last value in the range will also be captured and printed to the console."),
			
			Question(question: ["A while loop performs a set of statements until ... ",
								"The while loop executes a set of instructions until as long as ... ",
								"What must happen in a while loop for it to stop executing its set of instructions?"],
					 image: "",
					 optionA: "Condition becomes false",
					 optionB: "Upper bound of the range is reached",
					 optionC: "It runs out of items in collection",
					 optionD: "",
					 questionId: 410,
					 helpText: "A while loop performs a set of statements until a condition becomes false. These kinds of loops are best used when the number of iterations is not known before the first iteration begins. Swift provides two kinds of while loops: while evaluates its condition at the start of each pass through the loop, repeat-while evaluates its condition at the end of each pass through the loop."),
			
			Question(question: ["The first iteration of the while loop will be executed only in this case",
								"The first iteration of the while loop will run ... ",
								"On what condition will the first iteration of the while loop be executed?"],
					 image: "",
					 optionA: "If the condition is true",
					 optionB: "If the condition is false",
					 optionC: "In any case",
					 optionD: "",
					 questionId: 411,
					 helpText: "A while loop starts by evaluating a single condition. If the condition is true, a set of statements is repeated until the condition becomes false."),
			
			Question(question: ["The first iteration of the repeat-while loop will be executed only in this case",
								"The first iteration of the repeat-while loop will run ... ",
								"When will the first iteration of the repeat-while loop start executing?"],
					 image: "",
					 optionA: "In any case",
					 optionB: "If the condition is true",
					 optionC: "If the condition is false",
					 optionD: "",
					 questionId: 412,
					 helpText: "Repeat-while loop performs a single pass through the loop block first, before considering the loop’s condition. It then continues to repeat the loop until the condition is false."),
			
			Question(question: ["Which way to add conditional branches is preferable if we need to evaluate simple conditions with only a few possible outcomes?"],
					 image: "",
					 optionA: "if statement",
					 optionB: "switch statement",
					 optionC: "",
					 optionD: "",
					 questionId: 413,
					 helpText: "Swift provides two ways to add conditional branches to your code: the if statement and the switch statement. Typically, you use the if statement to evaluate simple conditions with only a few possible outcomes. The switch statement is better suited to more complex conditions with multiple possible permutations and is useful in situations where pattern matching can help select an appropriate code branch to execute."),
			
			Question(question: ["The if statement executes a set of statements only if ...",
								"The if statement will execute the set of instructions only in the following case",
								"When will the body of the if statement be executed?"],
					 image: "",
					 optionA: "The condition is true",
					 optionB: "The condition is false",
					 optionC: "In any case",
					 optionD: "",
					 questionId: 414,
					 helpText: "In its simplest form, the if statement has a single if condition. It executes a set of statements only if that condition is true."),
			
			Question(question: ["If the condition in an if statement is false, which keyword can you use to proceed?",
								"How can you introduce an additional branch to an if statement?",
								"Which of the following keywords adds an alternative to an if statement?"],
					 image: "",
					 optionA: "else",
					 optionB: "optional",
					 optionC: "another",
					 optionD: "but",
					 questionId: 415,
					 helpText: "The if statement can provide an alternative set of statements, known as an else clause, for situations when the if condition is false. These statements are indicated by the else keyword."),
			
			Question(question: ["Once Swift finds a case that matches the value we are comparing in a switch statement, will it proceed to compare the value against the rest of available cases?",
								"If we’ve already got a match inside a switch statement, will the rest of cases be also checked anyway?",
								"Does Swift run through all the matching patterns of a switch statement even though one of them has already been matched?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "Yes, there’s a default case",
					 optionD: "",
					 questionId: 416,
					 helpText: "A switch statement considers a value and compares it against several possible matching patterns. It then executes an appropriate block of code, based on the first pattern that matches successfully. A switch statement provides an alternative to the if statement for responding to multiple potential states."),
			
			Question(question: ["Is the default case inside a switch statement always required?",
								"Is it necessary to use the default case inside a switch statement every time?",
								"Are we obliged to provide each switch statement with a default case?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 417,
					 helpText: "Every switch statement must be exhaustive. That is, every possible value of the type being considered must be matched by one of the switch cases. If it’s not appropriate to provide a case for every possible value, you can define a default case to cover any values that are not addressed explicitly. This default case is indicated by the default keyword, and must always appear last."),
			
			Question(question: ["What is the difference between the way switch statements work in Swift and in Objective-C?",
								"Switch statements in Swift and Objective-C have one important difference, which one?"],
					 image: "",
					 optionA: "No implicit fallthrough",
					 optionB: "Default cases",
					 optionC: "Limited number of cases",
					 optionD: "",
					 questionId: 418,
					 helpText: "In contrast with switch statements in C and Objective-C, switch statements in Swift do not fall through the bottom of each case and into the next one by default. Instead, the entire switch statement finishes its execution as soon as the first matching switch case is completed, without requiring an explicit break statement. This makes the switch statement safer and easier to use than the one in C and avoids executing more than one switch case by mistake."),
			
			Question(question: ["Can we use a break statement inside a switch case?",
								"Although break statement is not required in switch cases in Swift, can we still use it without causing any errors?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 419,
					 helpText: "Although break is not required in Swift, you can use a break statement to match and ignore a particular case or to break out of a matched case before that case has completed its execution."),
			
			Question(question: ["What must each switch statement case contain?",
								"Choose what must be contained inside each switch statement case"],
					 image: "",
					 optionA: "At least one executable statement",
					 optionB: "One condition and one statement",
					 optionC: "An operator that returns Bool",
					 optionD: "A fallthrough keyword",
					 questionId: 420,
					 helpText: "The body of each case must contain at least one executable statement. If any case does not contain any executable statements Swift reports that as compile-time error."),
			
			Question(question: ["What separates values inside a compound case in a switch statement?",
								"You can use compound cases inside a switch statement, how can you separate their values?"],
					 image: "",
					 optionA: "Comma",
					 optionB: "Backslash",
					 optionC: "Space",
					 optionD: "Semicolon",
					 questionId: 421,
					 helpText: "To make a switch with a single case that matches at least one of several values, combine the the values into a compound case, separating the values with commas: case  \"a\", \"A\""),
			
			Question(question: ["What will we get into the console?"],
					 image: "ControlFlow23",
					 optionA: "2",
					 optionB: "1",
					 optionC: "3",
					 optionD: "4",
					 questionId: 422,
					 helpText: "Correct answer: 2. You can use tuples to test multiple values in the same switch statement. Each element of the tuple can be tested against a different value or interval of values. Alternatively, use the underscore character (_), also known as the wildcard pattern, to match any possible value. Our example takes an (x, y) point, expressed as a simple tuple of type (Int, Int), and categorizes it on the graph that follows the example."),
			
			Question(question: ["If multiple matches are possible in a switch, which one will be used?"],
					 image: "",
					 optionA: "The first matching case",
					 optionB: "A random matching case",
					 optionC: "The last matching case",
					 optionD: "",
					 questionId: 423,
					 helpText: "Unlike C, Swift allows multiple switch cases to consider the same value or values. However, if multiple matches are possible, the first matching case is always used, and so all other matching cases would be ignored."),
			
			Question(question: ["After the value binding, what value will we get at the end of the following code?"],
					 image: "ControlFlow25",
					 optionA: "2",
					 optionB: "0",
					 optionC: "2, 0",
					 optionD: "",
					 questionId: 424,
					 helpText: "A switch case can name the value or values it matches to temporary constants or variables, for use in the body of the case. This behavior is known as value binding, because the values are bound to temporary constants or variables within the case’s body. The three switch cases declare placeholder constants x and y, which temporarily take on one or both tuple values from anotherPoint. The first case, case (let x, 0), matches any point with a y value of 0 and assigns the point’s x value to the temporary constant x. Similarly, the second case, case (0, let y), matches any point with an x value of 0 and assigns the point’s y value to the temporary constant y. After the temporary constants are declared, they can be used within the case’s code block. Here, they are used to print the categorization of the point."),
			
			Question(question: ["Why does the following switch statement not have a default case?",
								"In the given code snippet, the default case is not used. Why?",
								"This is why we don’t use the default case here"],
					 image: "ControlFlow25",
					 optionA: "This statement is exhaustive",
					 optionB: "It’s required, so we’ll get an error",
					 optionC: "Because of the value binding",
					 optionD: "",
					 questionId: 425,
					 helpText: "This switch statement does not have a default case. The final case, case let (x, y), declares a tuple of two placeholder constants that can match any value. Because anotherPoint is always a tuple of two values, this case matches all possible remaining values, and a default case is not needed to make the switch statement exhaustive."),
			
			Question(question: ["Can we combine multiple switch cases that share the same body?",
								"Can patterns be written over multiple lines after the same case keyword if the list is long?"],
					 image: "ControlFlow28",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 426,
					 helpText: "Multiple switch cases that share the same body can be combined by writing several patterns after the case keyword, with a comma between each of the patterns. If any of the patterns match, then the case is considered to match. The patterns can be written over multiple lines if the list is long."),
			
			Question(question: ["Can compound cases include value bindings?",
								"Is value bindings available in compound cases?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 427,
					 helpText: "Compound cases can include value bindings. All of the patterns of a compound case have to include the same set of value bindings, and each binding has to get a value of the same type from all of the patterns in the compound case. This ensures that, no matter which part of the compound case matched, the code in the body of the case can always access a value for the bindings and that the value always has the same type."),
			
			Question(question: ["Given the following code, what result will we get?"],
					 image: "ControlFlow30",
					 optionA: "9",
					 optionB: "0",
					 optionC: "default",
					 optionD: "",
					 questionId: 428,
					 helpText: "The case above has two patterns: (let x, 0) matches points on the x-axis and (0, let x) matches points on the y-axis. Both patterns include a binding for x and x is an integer in both patterns—which means that the code in the body of the case can always access a value for x."),
			
			Question(question: ["How many control transfer statements are available in Swift?",
								"The number of control transfer statements available in Swift",
								"How many control transfer statements does Swift support?"],
					 image: "",
					 optionA: "Five",
					 optionB: "Four",
					 optionC: "Three",
					 optionD: "Twenty two",
					 questionId: 429,
					 helpText: "Control transfer statements change the order in which your code is executed, by transferring control from one piece of code to another. Swift has five control transfer statements: continue, break, fallthrough, return, throw."),
			
			Question(question: ["Which control transfer statement tells the loop to stop what it is doing and start again at the beginning of the next iteration?",
								"The control transfer operator that tells the loop: \"I finished with the current iteration, we can move on to the next one\""],
					 image: "",
					 optionA: "continue",
					 optionB: "break",
					 optionC: "fallthrough",
					 optionD: "return",
					 questionId: 430,
					 helpText: "The continue statement tells a loop to stop what it is doing and start again at the beginning of the next iteration through the loop. It says “I am done with the current loop iteration” without leaving the loop altogether.")
		]
	}
}
