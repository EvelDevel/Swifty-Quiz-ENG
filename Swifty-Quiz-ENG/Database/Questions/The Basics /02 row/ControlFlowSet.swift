
//  Created by Евгений Никитин on 11.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

// MARK: 05 - Вопросы (id) с 401 по 500

class ControlFlowSet {
	static func getQuestions() -> [Question] {
		return [
			Question (question: ["How many different loops does Swift support?",
								 "Swift supports this many different loops"],
					  image: "",
					  optionA: "Three",
					  optionB: "Two",
					  optionC: "Four",
					  optionD: "",
					  questionId: 401,
					  helpText: "Three: for-in, while, repeat-while."),
			
			Question(question: ["What is the for-in loop used for?",
								"The for-in loop is used for this"],
					 image: "",
					 optionA: "To iterate over a sequence",
					 optionB: "To performs a single pass through the loop",
					 optionC: "To performs a set of statements",
					 optionD: "",
					 questionId: 402,
					 helpText: "You use the for-in loop to iterate over a sequence, such as items in an array, ranges of numbers, or characters in a string."),
			
			Question(question: ["When iterating over which collection, can we decompose the returned value as explicitly named constants?",
								"When iterating over this collection, the returned value can be decomposed into separate constants",
								"When iterating over which collection, we return a tuple of values that can be decomposed into separate constants?"],
					 image: "",
					 optionA: "Dictionary",
					 optionB: "Set",
					 optionC: "Array",
					 optionD: "",
					 questionId: 403,
					 helpText: "You can also iterate over a dictionary to access its key-value pairs. Each item in the dictionary is returned as a (key, value) tuple when the dictionary is iterated, and you can decompose the (key, value) tuple’s members as explicitly named constants for use within the body of the for-in loop."),
			
			Question(question: ["In this example, is index a variable or a constant?"],
					 image: "ControlFlow4",
					 optionA: "Variable",
					 optionB: "Constant",
					 optionC: "",
					 optionD: "",
					 questionId: 404,
					 helpText: "In example, index is a constant whose value is automatically set at the start of each iteration of the loop. As such, index does not have to be declared before it is used. It is implicitly declared simply by its inclusion in the loop declaration, without the need for a let declaration keyword."),
			
			Question(question: ["Select the last line to be printed to the console?"],
					 image: "ControlFlow4",
					 optionA: "5 + 5 = 10",
					 optionB: "3 + 5 = 8",
					 optionC: "4 + 5 = 9",
					 optionD: "2 + 5 = 7",
					 questionId: 405,
					 helpText: "Correct answer: 5 + 5 = 10. The sequence being iterated over is a range of numbers from 1 to 5, inclusive, as indicated by the use of the closed range operator (...). The value of index is set to the first number in the range (1), and the statements inside the loop are executed. In this case, the loop contains only one statement, which prints an entry from the five-times table for the current value of index. After the statement is executed, the value of index is updated to contain the second value in the range (2), and the print(_:separator:terminator:) function is called again. This process continues until the end of the range is reached."),
			
			Question(question: ["Can we ignore \"example\" for this calculation?"],
					 image: "ControlFlow6",
					 optionA: "Yes, by underscore",
					 optionB: "Yes, by space instead of name",
					 optionC: "Yes, use the colon sign instead",
					 optionD: "No, we can't ignore it",
					 questionId: 406,
					 helpText: "For this calculation, the individual counter values each time through the loop are unnecessary—the code simply executes the loop the correct number of times. The underscore character (_) used in place of a loop variable causes the individual values to be ignored and does not provide access to the current value during each iteration of the loop."),
			
			///  407 - Пожалуйста помоги с переводом двух формулировок (2 и 3)
			
			Question(question: ["Which range operator we must use while iterating to include the lower bound but not the upper bound?",
								"При итерации через цикл, этот оператор поможет выключить верхнюю границу диапазона",
								"Как мы можем исключить верхнюю границу диапазона при итерации через  for-in?"],
					 image: "",
					 optionA: "..<",
					 optionB: "...",
					 optionC: "..>",
					 optionD: "",
					 questionId: 407,
					 helpText: "Use the half-open range operator (..<) to include the lower bound but not the upper bound."),
			
			/// Пожалуйста, если будет возможность, добавь по формулировке следующим двум вопросам
			
			Question(question: ["What values will we get in the console?"],
					 image: "ControlFlow8",
					 optionA: "2, 4, 6",
					 optionB: "0, 2, 4, 6",
					 optionC: "2, 4, 6, 8",
					 optionD: "4, 6",
					 questionId: 408,
					 helpText: "Correct answer: 2, 4, 6. You might want fewer tick marks in your UI. If, for example, you prefer one mark every 5 minutes instead, use the stride(from:to:by:) function to skip the unwanted marks. This function does not capture the last value of the range (8)."),
			
			Question(question: ["What values will we get in the console?"],
					 image: "ControlFlow9",
					 optionA: "2, 4, 6, 8",
					 optionB: "0, 2, 4, 6",
					 optionC: "2, 4, 6",
					 optionD: "4, 6, 8",
					 questionId: 409,
					 helpText: "Closed ranges are also available, by using stride(from:through:by:) instead. Correct answer: 2, 4, 6, 8, The \"through\" inside this method tells us that the last value in the range will also be captured and printed to the console."),
			
			/// Здесь удален 410 вопрос с "как на английском"
			
			Question(question: ["A while loop performs a set of statements until ...",
								"The while loop executes a set of instructions until this happens",
								"What must happen for the while loop to stop executing its set of instructions?"],
					 image: "",
					 optionA: "Condition becomes false",
					 optionB: "Reached the upper bound of the range",
					 optionC: "Out of items in collection",
					 optionD: "",
					 questionId: 411,
					 helpText: "A while loop performs a set of statements until a condition becomes false. These kinds of loops are best used when the number of iterations is not known before the first iteration begins. Swift provides two kinds of while loops: while evaluates its condition at the start of each pass through the loop, repeat-while evaluates its condition at the end of each pass through the loop."),
			
			/// Авто-перевод через гугл-транслейт
			
			Question(question: ["The first iteration of the while loop will be executed only in this case",
								"The first iteration of the while loop will run ...",
								"When will the first iteration of the while loop start executing?"],
					 image: "",
					 optionA: "If the condition is true",
					 optionB: "If the condition is false",
					 optionC: "In any case",
					 optionD: "",
					 questionId: 412,
					 helpText: "A while loop starts by evaluating a single condition. If the condition is true, a set of statements is repeated until the condition becomes false."),
			
			Question(question: ["The first iteration of the repeat-while loop will be executed only in this case",
								"The first iteration of the repeat-while loop will run ...",
								"When will the first iteration of the repeat-while loop start executing?"],
					 image: "",
					 optionA: "In any case",
					 optionB: "If the condition is true",
					 optionC: "If the condition is false",
					 optionD: "",
					 questionId: 413,
					 helpText: "Repeat-while loop performs a single pass through the loop block first, before considering the loop’s condition. It then continues to repeat the loop until the condition is false."),
			
			Question(question: ["Swift provides two ways to add conditional branches to your code: the if statement and the switch statement. Which one we prefer to use to evaluate simple conditions with only a few possible outcomes?"],
					 image: "",
					 optionA: "if statement",
					 optionB: "switch statement",
					 optionC: "",
					 optionD: "",
					 questionId: 414,
					 helpText: "Swift provides two ways to add conditional branches to your code: the if statement and the switch statement. Typically, you use the if statement to evaluate simple conditions with only a few possible outcomes. The switch statement is better suited to more complex conditions with multiple possible permutations and is useful in situations where pattern matching can help select an appropriate code branch to execute."),
			
			Question(question: ["If statement executes a set of statements only if ...",
								"The if statement will execute the set of instructions only in this case",
								"When will the body of the if statement be executed?"],
					 image: "",
					 optionA: "The condition is true",
					 optionB: "The condition is false",
					 optionC: "In any case",
					 optionD: "",
					 questionId: 415,
					 helpText: "In its simplest form, the if statement has a single if condition. It executes a set of statements only if that condition is true."),
			
			Question(question: ["If the condition is false in the if statement, you can use this keyword to proceed",
								"Additional branch of if statement you indicate with this keyword",
								"Additional if statements are specified via this keyword"],
					 image: "",
					 optionA: "else",
					 optionB: "also",
					 optionC: "another",
					 optionD: "but",
					 questionId: 416,
					 helpText: "The if statement can provide an alternative set of statements, known as an else clause, for situations when the if condition is false. These statements are indicated by the else keyword."),
			
			/// Помоги пожалуйста с формулировками 417, вообще не могу никак перевести. Они на русском то мутные, эти формулировки.
			
			Question(question: ["Если внутри инструкции switch, при сравнении по шаблонам мы нашли совпадение - пройдет ли сравнение дальше, по остальным шаблонам?",
								"Будут ли проверяться все оставшиеся шаблоны внутри инструкции switch, если мы уже нашли совпадение?",
								"Если мы нашли совпадение внутри switch, будут ли проверяться все оставшиеся шаблоны на совпадение?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "Yes, default case will execute",
					 optionD: "",
					 questionId: 417,
					 helpText: "A switch statement considers a value and compares it against several possible matching patterns. It then executes an appropriate block of code, based on the first pattern that matches successfully. A switch statement provides an alternative to the if statement for responding to multiple potential states."),
			
			Question(question: ["Is the default case inside a switch statement always required?",
								"Is the default case inside a switch required to use every time?",
								"Are we obliged to write the default case inside the switch-case every time?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 418,
					 helpText: "Every switch statement must be exhaustive. That is, every possible value of the type being considered must be matched by one of the switch cases. If it’s not appropriate to provide a case for every possible value, you can define a default case to cover any values that are not addressed explicitly. This default case is indicated by the default keyword, and must always appear last."),
			
			/// Здесь в 419 я не уверен, что в вопросах отражена суть того, что нам нужно выбрать именно отличие свича в Свифт (особенно во 2ом)
			
			Question(question: ["What is the difference between the switch-case statement in Swift and the switch-case in Objective-C?",
								"Switch-case in Swift and Objective-C has one important difference, which one?"],
					 image: "",
					 optionA: "No implicit fallthrough",
					 optionB: "No default cases",
					 optionC: "Limited number of cases",
					 optionD: "",
					 questionId: 419,
					 helpText: "In contrast with switch statements in C and Objective-C, switch statements in Swift do not fall through the bottom of each case and into the next one by default. Instead, the entire switch statement finishes its execution as soon as the first matching switch case is completed, without requiring an explicit break statement. This makes the switch statement safer and easier to use than the one in C and avoids executing more than one switch case by mistake."),
			
			Question(question: ["Can we use a break statement inside a switch-case?",
								"Although the break statement is not required inside a switch in Swift, can we use it?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 420,
					 helpText: "Although break is not required in Swift, you can use a break statement to match and ignore a particular case or to break out of a matched case before that case has completed its execution."),
			
			/// 421 - Пожалуйста глянь хелп текст, там место про "свит выдаст ошибку компиляции" не очень корректно я думаю (as)
			
			Question(question: ["What must be contained within each switch statement case?",
								"Inside each switch statement case this must be contained"],
					 image: "",
					 optionA: "At least one executable statement",
					 optionB: "One condition and one statement",
					 optionC: "At least one comparison",
					 optionD: "Required print() statement",
					 questionId: 421,
					 helpText: "The body of each case must contain at least one executable statement. If any case does not contain any executable statements Swift reports that as compile-time error."),
			
			Question(question: ["What separates values inside a compound case in a switch statement?",
								"You can use compound cases inside a switch statement, how can you separate their values?"],
					 image: "",
					 optionA: "Comma",
					 optionB: "Backslash",
					 optionC: "Underscore",
					 optionD: "Semicolon",
					 questionId: 422,
					 helpText: "To make a switch with a single case that matches both \"a\" and \"A\", combine the two values into a compound case, separating the values with commas."),
			
			Question(question: ["What will we get into console?"],
					 image: "ControlFlow23",
					 optionA: "2",
					 optionB: "1",
					 optionC: "3",
					 optionD: "4",
					 questionId: 423,
					 helpText: "Correct answer: 2. You can use tuples to test multiple values in the same switch statement. Each element of the tuple can be tested against a different value or interval of values. Alternatively, use the underscore character (_), also known as the wildcard pattern, to match any possible value. Our example takes an (x, y) point, expressed as a simple tuple of type (Int, Int), and categorizes it on the graph that follows the example."),
			
			Question(question: ["If multiple matches are possible in Switch, which one will be used?"],
					 image: "",
					 optionA: "Will use the first match",
					 optionB: "Will use random matching case",
					 optionC: "Will use the last match",
					 optionD: "",
					 questionId: 424,
					 helpText: "Unlike C, Swift allows multiple switch cases to consider the same value or values. However, if multiple matches are possible, the first matching case is always used, and so all other matching cases would be ignored."),
			
			Question(question: ["After this value binding, what value will we get in console?"],
					 image: "ControlFlow25",
					 optionA: "2",
					 optionB: "0",
					 optionC: "2, 0",
					 optionD: "",
					 questionId: 425,
					 helpText: "A switch case can name the value or values it matches to temporary constants or variables, for use in the body of the case. This behavior is known as value binding, because the values are bound to temporary constants or variables within the case’s body. The three switch cases declare placeholder constants x and y, which temporarily take on one or both tuple values from anotherPoint. The first case, case (let x, 0), matches any point with a y value of 0 and assigns the point’s x value to the temporary constant x. Similarly, the second case, case (0, let y), matches any point with an x value of 0 and assigns the point’s y value to the temporary constant y. After the temporary constants are declared, they can be used within the case’s code block. Here, they are used to print the categorization of the point."),
			
			Question(question: ["Why this switch statement doesn't have a default case?",
								"The default case is not used. Why?",
								"This is why we are not using the default case here"],
					 image: "ControlFlow25",
					 optionA: "This statement is exhaustive",
					 optionB: "Bacause it's not required",
					 optionC: "Bacause of the value binding",
					 optionD: "",
					 questionId: 426,
					 helpText: "This switch statement does not have a default case. The final case, case let (x, y), declares a tuple of two placeholder constants that can match any value. Because anotherPoint is always a tuple of two values, this case matches all possible remaining values, and a default case is not needed to make the switch statement exhaustive."),
			
			Question(question: ["Can we combine multiple switch cases that share the same body?",
								"Can patterns be written over multiple lines if the list is long?"],
					 image: "ControlFlow28",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 428,
					 helpText: "Multiple switch cases that share the same body can be combined by writing several patterns after case, with a comma between each of the patterns. If any of the patterns match, then the case is considered to match. The patterns can be written over multiple lines if the list is long."),
			
			Question(question: ["Can compound cases include value bindings?",
								"Compound cases can include value bindings. Is that true?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 429,
					 helpText: "Compound cases can include value bindings. All of the patterns of a compound case have to include the same set of value bindings, and each binding has to get a value of the same type from all of the patterns in the compound case. This ensures that, no matter which part of the compound case matched, the code in the body of the case can always access a value for the bindings and that the value always has the same type."),
			
			Question(question: ["What will we get in the console?"],
					 image: "ControlFlow30",
					 optionA: "9",
					 optionB: "0",
					 optionC: "default",
					 optionD: "",
					 questionId: 430,
					 helpText: "The case above has two patterns: (let x, 0) matches points on the x-axis and (0, let x) matches points on the y-axis. Both patterns include a binding for x and x is an integer in both patterns—which means that the code in the body of the case can always access a value for x."),
			
			Question(question: ["How many control transfer statements are there in Swift?",
								"There are exactly so many control transfer statements in Swift",
								"How many control transfer statements does Swift support?"],
					 image: "",
					 optionA: "Five",
					 optionB: "Four",
					 optionC: "Three",
					 optionD: "Twenty two",
					 questionId: 431,
					 helpText: "Control transfer statements change the order in which your code is executed, by transferring control from one piece of code to another. Swift has five control transfer statements: continue, break, fallthrough, return, throw."),
			
			Question(question: ["Which control transfer statement tells the loop to stop what it is doing and start again at the beginning of the next iteration?",
								"This control transfer operator tells the loop: \"I finished with the current iteration, we can move on to the next one\""],
					 image: "",
					 optionA: "continue",
					 optionB: "break",
					 optionC: "fallthrough",
					 optionD: "return",
					 questionId: 432,
					 helpText: "The continue statement tells a loop to stop what it is doing and start again at the beginning of the next iteration through the loop. It says “I am done with the current loop iteration” without leaving the loop altogether."),
			
			Question(question: ["Which control transfer statement ends execution of an entire control flow statement immediately?",
								"This control transfer operator ends execution of an entire control flow statement immediately"],
					 image: "",
					 optionA: "break",
					 optionB: "continue",
					 optionC: "fallthrough",
					 optionD: "",
					 questionId: 433,
					 helpText: "The break statement ends execution of an entire control flow statement immediately. The break statement can be used inside a switch or loop statement when you want to terminate the execution of the switch or loop statement earlier than would otherwise be the case."),
			
			Question(question: ["When a break control statement is executed inside a loop, will the next iteration occur?",
								"Will the next iteration occur if a break control statement is executed inside a loop?",
								"If a break control statement is executed inside a loop, a new iteration starts. Is that true?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 434,
					 helpText: "When used inside a loop statement, break ends the loop’s execution immediately and transfers control to the code after the loop’s closing brace (}). No further code from the current iteration of the loop is executed, and no further iterations of the loop are started."),
			
			Question(question: ["When a break statement is executed inside a switch-case, what happens?",
								"What happens if a break control statement is executed inside a switch-case?",
								"If a control statement break is executed inside a switch, what happens next?"],
					 image: "",
					 optionA: "Switch statement ends immediately",
					 optionB: "Switch moving on to the next case",
					 optionC: "We start over again",
					 optionD: "",
					 questionId: 435,
					 helpText: "When used inside a switch statement, break causes the switch statement to end its execution immediately and to transfer control to the code after the switch statement’s closing brace (}). This behavior can be used to match and ignore one or more cases in a switch statement. Because Swift’s switch statement is exhaustive and does not allow empty cases, it is sometimes necessary to deliberately match and ignore a case in order to make your intentions explicit. You do this by writing the break statement as the entire body of the case you want to ignore. When that case is matched by the switch statement, the break statement inside the case ends the switch statement’s execution immediately."),
			
			Question(question: ["A switch case that contains only a comment is reported as a compile-time error. Is that true?",
								"Comments are not statements and do not cause a switch case to be ignored. Is that true?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 436,
					 helpText: "A switch case that contains only a comment is reported as a compile-time error. Comments are not statements and do not cause a switch case to be ignored. Always use a break statement to ignore a switch case."),
			
			Question(question: ["Which control transfer statement will help you to fall into the next case inside a switch?",
								"This control transfer statement will help you implement falling into the next case inside a switch"],
					 image: "",
					 optionA: "fallthrough",
					 optionB: "continue",
					 optionC: "throw",
					 optionD: "return",
					 questionId: 437,
					 helpText: "In Swift, switch statements don’t fall through the bottom of each case and into the next one. That is, the entire switch statement completes its execution as soon as the first matching case is completed. If you need C-style fallthrough behavior, you can opt in to this behavior on a case-by-case basis with the fallthrough keyword."),
			
			Question(question: ["Can you nest loops in Swift?",
								"Can we nest switch-case in Swift?",
								"Can you nest loops and conditional statements inside other loops and conditional statements?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 438,
					 helpText: "In Swift, you can nest loops and conditional statements inside other loops and conditional statements to create complex control flow structures. However, loops and conditional statements can both use the break statement to end their execution prematurely."),
			
			Question(question: ["The guard instruction only executes the code inside the brackets when its condition is ...?",
								"An early exit instruction guard executes the code inside its brackets depending on the boolean value of its condition. Which one?"],
					 image: "",
					 optionA: "false",
					 optionB: "true",
					 optionC: "",
					 optionD: "",
					 questionId: 439,
					 helpText: "A guard statement, like an if statement, executes statements depending on the Boolean value of an expression. You use a guard statement to require that a condition must be true in order for the code after the guard statement to be executed. Unlike an if statement, a guard statement always has an else clause—the code inside the else clause is executed if the condition is not true."),
			
			Question(question: ["If the guard statement’s condition is met, will the code inside the guard statement be executed?",
								"If the guard condition gives us true, will the else code block be executed?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 440,
					 helpText: "If the guard statement’s condition is met, code execution continues after the guard statement’s closing brace. Any variables or constants that were assigned values using an optional binding as part of the condition are available for the rest of the code block that the guard statement appears in. If that condition is not met, the code inside the else branch is executed. That branch must transfer control to exit the code block in which the guard statement appears. It can do this with a control transfer statement such as return, break, continue, or throw, or it can call a function or method that doesn’t return, such as fatalError(_:file:line:)."),
			
			Question(question: ["Is it preferable to use an if statement or a guard statement?",
								"Preferred to use an if statement or a guard statement?"],
					 image: "",
					 optionA: "guard",
					 optionB: "if",
					 optionC: "",
					 optionD: "",
					 questionId: 441,
					 helpText: "Using a guard statement for requirements improves the readability of your code, compared to doing the same check with an if statement. It lets you write the code that’s typically executed without wrapping it in an else block, and it lets you keep the code that handles a violated requirement next to the requirement."),
			
			Question(question: ["What value will the result have?"],
					 image: "ControlFlow42",
					 optionA: "2",
					 optionB: "0",
					 optionC: "1",
					 optionD: "3",
					 questionId: 442,
					 helpText: "Correct answer: 2. When we will definitely get into the first case of the switch-case, we will change the value of the variable and then fall into the next case using the falltrough operator, and there we will change the value of the variable a second time.")
		]
	}
	
	
	/// 
	
	
	static func getDemoQuestions() -> [Question] {
		return [
			Question (question: ["How many different loops does Swift support?",
								 "Swift supports this many different loops"],
					  image: "",
					  optionA: "Three",
					  optionB: "Two",
					  optionC: "Four",
					  optionD: "",
					  questionId: 401,
					  helpText: "Three: for-in, while, repeat-while."),
			
			Question(question: ["What is the for-in loop used for?",
								"The for-in loop is used for this"],
					 image: "",
					 optionA: "To iterate over a sequence",
					 optionB: "To performs a single pass through the loop",
					 optionC: "To performs a set of statements",
					 optionD: "",
					 questionId: 402,
					 helpText: "You use the for-in loop to iterate over a sequence, such as items in an array, ranges of numbers, or characters in a string."),
			
			Question(question: ["When iterating over which collection, can we decompose the returned value as explicitly named constants?",
								"When iterating over this collection, the returned value can be decomposed into separate constants",
								"When iterating over which collection, we return a tuple of values that can be decomposed into separate constants?"],
					 image: "",
					 optionA: "Dictionary",
					 optionB: "Set",
					 optionC: "Array",
					 optionD: "",
					 questionId: 403,
					 helpText: "You can also iterate over a dictionary to access its key-value pairs. Each item in the dictionary is returned as a (key, value) tuple when the dictionary is iterated, and you can decompose the (key, value) tuple’s members as explicitly named constants for use within the body of the for-in loop."),
			
			Question(question: ["In this example, is index a variable or a constant?"],
					 image: "ControlFlow4",
					 optionA: "Variable",
					 optionB: "Constant",
					 optionC: "",
					 optionD: "",
					 questionId: 404,
					 helpText: "In example, index is a constant whose value is automatically set at the start of each iteration of the loop. As such, index does not have to be declared before it is used. It is implicitly declared simply by its inclusion in the loop declaration, without the need for a let declaration keyword."),
			
			Question(question: ["Select the last line to be printed to the console?"],
					 image: "ControlFlow4",
					 optionA: "5 + 5 = 10",
					 optionB: "3 + 5 = 8",
					 optionC: "4 + 5 = 9",
					 optionD: "2 + 5 = 7",
					 questionId: 405,
					 helpText: "Correct answer: 5 + 5 = 10. The sequence being iterated over is a range of numbers from 1 to 5, inclusive, as indicated by the use of the closed range operator (...). The value of index is set to the first number in the range (1), and the statements inside the loop are executed. In this case, the loop contains only one statement, which prints an entry from the five-times table for the current value of index. After the statement is executed, the value of index is updated to contain the second value in the range (2), and the print(_:separator:terminator:) function is called again. This process continues until the end of the range is reached."),
			
			Question(question: ["Can we ignore \"example\" for this calculation?"],
					 image: "ControlFlow6",
					 optionA: "Yes, by underscore",
					 optionB: "Yes, by space instead of name",
					 optionC: "Yes, use the colon sign instead",
					 optionD: "No, we can't ignore it",
					 questionId: 406,
					 helpText: "For this calculation, the individual counter values each time through the loop are unnecessary—the code simply executes the loop the correct number of times. The underscore character (_) used in place of a loop variable causes the individual values to be ignored and does not provide access to the current value during each iteration of the loop."),
			
			///  407 - Пожалуйста помоги с переводом двух формулировок (2 и 3)
			
			Question(question: ["Which range operator we must use while iterating to include the lower bound but not the upper bound?",
								"При итерации через цикл, этот оператор поможет выключить верхнюю границу диапазона",
								"Как мы можем исключить верхнюю границу диапазона при итерации через  for-in?"],
					 image: "",
					 optionA: "..<",
					 optionB: "...",
					 optionC: "..>",
					 optionD: "",
					 questionId: 407,
					 helpText: "Use the half-open range operator (..<) to include the lower bound but not the upper bound."),
			
			/// Пожалуйста, если будет возможность, добавь по формулировке следующим двум вопросам
			
			Question(question: ["What values will we get in the console?"],
					 image: "ControlFlow8",
					 optionA: "2, 4, 6",
					 optionB: "0, 2, 4, 6",
					 optionC: "2, 4, 6, 8",
					 optionD: "4, 6",
					 questionId: 408,
					 helpText: "Correct answer: 2, 4, 6. You might want fewer tick marks in your UI. If, for example, you prefer one mark every 5 minutes instead, use the stride(from:to:by:) function to skip the unwanted marks. This function does not capture the last value of the range (8)."),
			
			Question(question: ["What values will we get in the console?"],
					 image: "ControlFlow9",
					 optionA: "2, 4, 6, 8",
					 optionB: "0, 2, 4, 6",
					 optionC: "2, 4, 6",
					 optionD: "4, 6, 8",
					 questionId: 409,
					 helpText: "Closed ranges are also available, by using stride(from:through:by:) instead. Correct answer: 2, 4, 6, 8, The \"through\" inside this method tells us that the last value in the range will also be captured and printed to the console."),
			
			/// Здесь удален 410 вопрос с "как на английском"
			
			Question(question: ["A while loop performs a set of statements until ...",
								"The while loop executes a set of instructions until this happens",
								"What must happen for the while loop to stop executing its set of instructions?"],
					 image: "",
					 optionA: "Condition becomes false",
					 optionB: "Reached the upper bound of the range",
					 optionC: "Out of items in collection",
					 optionD: "",
					 questionId: 411,
					 helpText: "A while loop performs a set of statements until a condition becomes false. These kinds of loops are best used when the number of iterations is not known before the first iteration begins. Swift provides two kinds of while loops: while evaluates its condition at the start of each pass through the loop, repeat-while evaluates its condition at the end of each pass through the loop."),
			
			/// Авто-перевод через гугл-транслейт
			
			Question(question: ["The first iteration of the while loop will be executed only in this case",
								"The first iteration of the while loop will run ...",
								"When will the first iteration of the while loop start executing?"],
					 image: "",
					 optionA: "If the condition is true",
					 optionB: "If the condition is false",
					 optionC: "In any case",
					 optionD: "",
					 questionId: 412,
					 helpText: "A while loop starts by evaluating a single condition. If the condition is true, a set of statements is repeated until the condition becomes false."),
			
			Question(question: ["The first iteration of the repeat-while loop will be executed only in this case",
								"The first iteration of the repeat-while loop will run ...",
								"When will the first iteration of the repeat-while loop start executing?"],
					 image: "",
					 optionA: "In any case",
					 optionB: "If the condition is true",
					 optionC: "If the condition is false",
					 optionD: "",
					 questionId: 413,
					 helpText: "Repeat-while loop performs a single pass through the loop block first, before considering the loop’s condition. It then continues to repeat the loop until the condition is false."),
			
			Question(question: ["Swift provides two ways to add conditional branches to your code: the if statement and the switch statement. Which one we prefer to use to evaluate simple conditions with only a few possible outcomes?"],
					 image: "",
					 optionA: "if statement",
					 optionB: "switch statement",
					 optionC: "",
					 optionD: "",
					 questionId: 414,
					 helpText: "Swift provides two ways to add conditional branches to your code: the if statement and the switch statement. Typically, you use the if statement to evaluate simple conditions with only a few possible outcomes. The switch statement is better suited to more complex conditions with multiple possible permutations and is useful in situations where pattern matching can help select an appropriate code branch to execute."),
			
			Question(question: ["If statement executes a set of statements only if ...",
								"The if statement will execute the set of instructions only in this case",
								"When will the body of the if statement be executed?"],
					 image: "",
					 optionA: "The condition is true",
					 optionB: "The condition is false",
					 optionC: "In any case",
					 optionD: "",
					 questionId: 415,
					 helpText: "In its simplest form, the if statement has a single if condition. It executes a set of statements only if that condition is true."),
			
			Question(question: ["If the condition is false in the if statement, you can use this keyword to proceed",
								"Additional branch of if statement you indicate with this keyword",
								"Additional if statements are specified via this keyword"],
					 image: "",
					 optionA: "else",
					 optionB: "also",
					 optionC: "another",
					 optionD: "but",
					 questionId: 416,
					 helpText: "The if statement can provide an alternative set of statements, known as an else clause, for situations when the if condition is false. These statements are indicated by the else keyword."),
			
			/// Помоги пожалуйста с формулировками 417, вообще не могу никак перевести. Они на русском то мутные, эти формулировки.
			
			Question(question: ["Если внутри инструкции switch, при сравнении по шаблонам мы нашли совпадение - пройдет ли сравнение дальше, по остальным шаблонам?",
								"Будут ли проверяться все оставшиеся шаблоны внутри инструкции switch, если мы уже нашли совпадение?",
								"Если мы нашли совпадение внутри switch, будут ли проверяться все оставшиеся шаблоны на совпадение?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "Yes, default case will execute",
					 optionD: "",
					 questionId: 417,
					 helpText: "A switch statement considers a value and compares it against several possible matching patterns. It then executes an appropriate block of code, based on the first pattern that matches successfully. A switch statement provides an alternative to the if statement for responding to multiple potential states."),
			
			Question(question: ["Is the default case inside a switch statement always required?",
								"Is the default case inside a switch required to use every time?",
								"Are we obliged to write the default case inside the switch-case every time?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 418,
					 helpText: "Every switch statement must be exhaustive. That is, every possible value of the type being considered must be matched by one of the switch cases. If it’s not appropriate to provide a case for every possible value, you can define a default case to cover any values that are not addressed explicitly. This default case is indicated by the default keyword, and must always appear last."),
			
			/// Здесь в 419 я не уверен, что в вопросах отражена суть того, что нам нужно выбрать именно отличие свича в Свифт (особенно во 2ом)
			
			Question(question: ["What is the difference between the switch-case statement in Swift and the switch-case in Objective-C?",
								"Switch-case in Swift and Objective-C has one important difference, which one?"],
					 image: "",
					 optionA: "No implicit fallthrough",
					 optionB: "No default cases",
					 optionC: "Limited number of cases",
					 optionD: "",
					 questionId: 419,
					 helpText: "In contrast with switch statements in C and Objective-C, switch statements in Swift do not fall through the bottom of each case and into the next one by default. Instead, the entire switch statement finishes its execution as soon as the first matching switch case is completed, without requiring an explicit break statement. This makes the switch statement safer and easier to use than the one in C and avoids executing more than one switch case by mistake."),
			
			Question(question: ["Can we use a break statement inside a switch-case?",
								"Although the break statement is not required inside a switch in Swift, can we use it?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 420,
					 helpText: "Although break is not required in Swift, you can use a break statement to match and ignore a particular case or to break out of a matched case before that case has completed its execution."),
			
			/// 421 - Пожалуйста глянь хелп текст, там место про "свит выдаст ошибку компиляции" не очень корректно я думаю (as)
			
			Question(question: ["What must be contained within each switch statement case?",
								"Inside each switch statement case this must be contained"],
					 image: "",
					 optionA: "At least one executable statement",
					 optionB: "One condition and one statement",
					 optionC: "At least one comparison",
					 optionD: "Required print() statement",
					 questionId: 421,
					 helpText: "The body of each case must contain at least one executable statement. If any case does not contain any executable statements Swift reports that as compile-time error."),
			
			Question(question: ["What separates values inside a compound case in a switch statement?",
								"You can use compound cases inside a switch statement, how can you separate their values?"],
					 image: "",
					 optionA: "Comma",
					 optionB: "Backslash",
					 optionC: "Underscore",
					 optionD: "Semicolon",
					 questionId: 422,
					 helpText: "To make a switch with a single case that matches both \"a\" and \"A\", combine the two values into a compound case, separating the values with commas."),
			
			Question(question: ["What will we get into console?"],
					 image: "ControlFlow23",
					 optionA: "2",
					 optionB: "1",
					 optionC: "3",
					 optionD: "4",
					 questionId: 423,
					 helpText: "Correct answer: 2. You can use tuples to test multiple values in the same switch statement. Each element of the tuple can be tested against a different value or interval of values. Alternatively, use the underscore character (_), also known as the wildcard pattern, to match any possible value. Our example takes an (x, y) point, expressed as a simple tuple of type (Int, Int), and categorizes it on the graph that follows the example."),
			
			Question(question: ["If multiple matches are possible in Switch, which one will be used?"],
					 image: "",
					 optionA: "Will use the first match",
					 optionB: "Will use random matching case",
					 optionC: "Will use the last match",
					 optionD: "",
					 questionId: 424,
					 helpText: "Unlike C, Swift allows multiple switch cases to consider the same value or values. However, if multiple matches are possible, the first matching case is always used, and so all other matching cases would be ignored."),
			
			Question(question: ["After this value binding, what value will we get in console?"],
					 image: "ControlFlow25",
					 optionA: "2",
					 optionB: "0",
					 optionC: "2, 0",
					 optionD: "",
					 questionId: 425,
					 helpText: "A switch case can name the value or values it matches to temporary constants or variables, for use in the body of the case. This behavior is known as value binding, because the values are bound to temporary constants or variables within the case’s body. The three switch cases declare placeholder constants x and y, which temporarily take on one or both tuple values from anotherPoint. The first case, case (let x, 0), matches any point with a y value of 0 and assigns the point’s x value to the temporary constant x. Similarly, the second case, case (0, let y), matches any point with an x value of 0 and assigns the point’s y value to the temporary constant y. After the temporary constants are declared, they can be used within the case’s code block. Here, they are used to print the categorization of the point."),
			
			Question(question: ["Why this switch statement doesn't have a default case?",
								"The default case is not used. Why?",
								"This is why we are not using the default case here"],
					 image: "ControlFlow25",
					 optionA: "This statement is exhaustive",
					 optionB: "Bacause it's not required",
					 optionC: "Bacause of the value binding",
					 optionD: "",
					 questionId: 426,
					 helpText: "This switch statement does not have a default case. The final case, case let (x, y), declares a tuple of two placeholder constants that can match any value. Because anotherPoint is always a tuple of two values, this case matches all possible remaining values, and a default case is not needed to make the switch statement exhaustive."),
			
			Question(question: ["Can we combine multiple switch cases that share the same body?",
								"Can patterns be written over multiple lines if the list is long?"],
					 image: "ControlFlow28",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 428,
					 helpText: "Multiple switch cases that share the same body can be combined by writing several patterns after case, with a comma between each of the patterns. If any of the patterns match, then the case is considered to match. The patterns can be written over multiple lines if the list is long."),
			
			Question(question: ["Can compound cases include value bindings?",
								"Compound cases can include value bindings. Is that true?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 429,
					 helpText: "Compound cases can include value bindings. All of the patterns of a compound case have to include the same set of value bindings, and each binding has to get a value of the same type from all of the patterns in the compound case. This ensures that, no matter which part of the compound case matched, the code in the body of the case can always access a value for the bindings and that the value always has the same type."),
			
			Question(question: ["What will we get in the console?"],
					 image: "ControlFlow30",
					 optionA: "9",
					 optionB: "0",
					 optionC: "default",
					 optionD: "",
					 questionId: 430,
					 helpText: "The case above has two patterns: (let x, 0) matches points on the x-axis and (0, let x) matches points on the y-axis. Both patterns include a binding for x and x is an integer in both patterns—which means that the code in the body of the case can always access a value for x."),
			
			Question(question: ["How many control transfer statements are there in Swift?",
								"There are exactly so many control transfer statements in Swift",
								"How many control transfer statements does Swift support?"],
					 image: "",
					 optionA: "Five",
					 optionB: "Four",
					 optionC: "Three",
					 optionD: "Twenty two",
					 questionId: 431,
					 helpText: "Control transfer statements change the order in which your code is executed, by transferring control from one piece of code to another. Swift has five control transfer statements: continue, break, fallthrough, return, throw."),
			
			Question(question: ["Which control transfer statement tells the loop to stop what it is doing and start again at the beginning of the next iteration?",
								"This control transfer operator tells the loop: \"I finished with the current iteration, we can move on to the next one\""],
					 image: "",
					 optionA: "continue",
					 optionB: "break",
					 optionC: "fallthrough",
					 optionD: "return",
					 questionId: 432,
					 helpText: "The continue statement tells a loop to stop what it is doing and start again at the beginning of the next iteration through the loop. It says “I am done with the current loop iteration” without leaving the loop altogether.")
		]
	}
}
