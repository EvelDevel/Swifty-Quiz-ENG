
//  Created by Евгений Никитин on 12.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

// MARK: 18 - Вопросы (id) с 1701 по 1800

class ARCSet {
	static func getQuestions() -> [Question] {
		return [
			Question(question: ["The main task for Automatic Reference Counting in Swift?",
								"Automatic Reference Counting in Swift is need for that"],
					 image: "",
					 optionA: "Track and manage your app’s memory usage",
					 optionB: "Declare the instances",
					 optionC: "Delayed declaration",
					 optionD: "It is just a counter",
					 questionId: 1701,
					 helpText: "Swift uses Automatic Reference Counting (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you do not need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed."),
			
			Question(question: ["To which instances ARC applies?",
								"Reference counting applies only to that instances"],
					 image: "",
					 optionA: "Instances of classes",
					 optionB: "Instances of structures",
					 optionC: "Instances of enumirations",
					 optionD: "",
					 questionId: 1702,
					 helpText: "Reference counting applies only to instances of classes. Structures and enumerations are value types, not reference types, and are not stored and passed by reference."),
			
			/// Пожалуйста проверь здесь варианты ответов под микроскопом, че-то уже не варила голова на этом моменте (шел снизу вверх)
			
			Question(question: ["ARC will not deallocate an instance as long as ..."],
					 image: "",
					 optionA: "we have at least one active reference",
					 optionB: "we have more than two strong reference",
					 optionC: "we have weak references to that instance",
					 optionD: "",
					 questionId: 1703,
					 helpText: "if ARC were to deallocate an instance that was still in use, it would no longer be possible to access that instance’s properties, or call that instance’s methods. Indeed, if you tried to access the instance, your app would most likely crash. To make sure that instances don’t disappear while they are still needed, ARC tracks how many properties, constants, and variables are currently referring to each class instance. ARC will not deallocate an instance as long as at least one active reference to that instance still exists."),
			
			Question(question: ["Whenever you assign a class instance to a property, constant, or variable, that property, constant, or variable makes ___",
								"That reference keeps a firm hold on the instance",
								"That reference does not allow instance to be deallocated for as long as that ___ reference remains"],
					 image: "",
					 optionA: "Strong reference",
					 optionB: "Weak reference",
					 optionC: "Medium-rare reference",
					 optionD: "",
					 questionId: 1704,
					 helpText: "Whenever you assign a class instance to a property, constant, or variable, that property, constant, or variable makes a strong reference to the instance. The reference is called a “strong” reference because it keeps a firm hold on that instance, and does not allow it to be deallocated for as long as that strong reference remains."),
			
			/// Если сможешь придумай еще одну формулировку на 1705
			
			Question(question: ["It can happen if two class instances hold a strong reference to each other, such that each instance keeps the other alive"],
					 image: "",
					 optionA: "Strong reference cycle",
					 optionB: "Weak reference closure",
					 optionC: "Reference chaining",
					 optionD: "",
					 questionId: 1705,
					 helpText: "It is possible to write code in which an instance of a class never gets to a point where it has zero strong references. This can happen if two class instances hold a strong reference to each other, such that each instance keeps the other alive. This is known as a strong reference cycle."),
			
			Question(question: ["This keyword indicate weak reference",
								"With which reference you can indicate weak reference",
								"Keyword for weak reference"],
					 image: "",
					 optionA: "weak",
					 optionB: "strong",
					 optionC: "unowned",
					 optionD: "week",
					 questionId: 1706,
					 helpText: "Correct answer: weak. Weak and unowned references enable one instance in a reference cycle to refer to the other instance without keeping a strong hold on it. The instances can then refer to each other without creating a strong reference cycle."),
			
			/// Пожалуйста проверь здесь варианты ответов, поплыл что-то с временами
			
			Question(question: ["What the strong reference cycle can cause?",
								"The strong reference cycle can cause this"],
					 image: "",
					 optionA: "A memory leak",
					 optionB: "Deleting Instances",
					 optionC: "Runtime error",
					 optionD: "Instance diallocation",
					 questionId: 1707,
					 helpText: "The strong reference cycle prevents instances from ever being deallocated, causing a memory leak in your app."),
			
			Question(question: ["Which references enable one instance in a reference cycle to refer to the other instance without keeping a strong hold on it?"],
					 image: "",
					 optionA: "Weak and Unowed",
					 optionB: "Strong and Weak",
					 optionC: "Medium and Unowed",
					 optionD: "Unowes and Strong",
					 questionId: 1708,
					 helpText: "Weak and unowned references enable one instance in a reference cycle to refer to the other instance without keeping a strong hold on it. The instances can then refer to each other without creating a strong reference cycle."),
			
			Question(question: ["Use this reference when the other instance has a shorter lifetime"],
					 image: "",
					 optionA: "Weak",
					 optionB: "Unowed",
					 optionC: "Strong",
					 optionD: "The strongest",
					 questionId: 1709,
					 helpText: "Use a weak reference when the other instance has a shorter lifetime—that is, when the other instance can be deallocated first. In the Apartment example above, it’s appropriate for an apartment to be able to have no tenant at some point in its lifetime, and so a weak reference is an appropriate way to break the reference cycle in this case."),
			
			Question(question: ["Which reference should we use when the other instance has the same lifetime or a longer lifetime?"],
					 image: "",
					 optionA: "Unowed reference",
					 optionB: "Strong reference",
					 optionC: "Weak reference",
					 optionD: "",
					 questionId: 1710,
					 helpText: "Use an unowned reference when the other instance has the same lifetime or a longer lifetime."),
			
			Question(question: ["How can weak reference avoid a reference becoming part of a strong reference cycle?",
								"Weak reference helps avoid a strong reference cycle, how exactly?"],
					 image: "",
					 optionA: "It doesn't stop ARC from disposing",
					 optionB: "It does keep a strong hold on the instance",
					 optionC: "Because it's awesome",
					 optionD: "",
					 questionId: 1711,
					 helpText: "A weak reference is a reference that does not keep a strong hold on the instance it refers to, and so does not stop ARC from disposing of the referenced instance. This behavior prevents the reference from becoming part of a strong reference cycle. You indicate a weak reference by placing the weak keyword before a property or variable declaration."),
			
			Question(question: ["Should we declare weak references as variables or constants?",
								"Do we declare weak references in our code as constants, or as variables?"],
					 image: "",
					 optionA: "As variables",
					 optionB: "As constants",
					 optionC: "It is our decision",
					 optionD: "As optional constants",
					 questionId: 1712,
					 helpText: "Because a weak reference does not keep a strong hold on the instance it refers to, it’s possible for that instance to be deallocated while the weak reference is still referring to it. Therefore, ARC automatically sets a weak reference to nil when the instance that it refers to is deallocated. And, because weak references need to allow their value to be changed to nil at runtime, they are always declared as variables, rather than constants, of an optional type."),
			
			Question(question: ["Can you check for the existence of a value in the weak reference?",
								"You can check for the existence of a value in the weak reference. Is that true?",
								"You can check for the existence of a value in the weak reference, just like any other optional value. Is that true?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1713,
					 helpText: "You can check for the existence of a value in the weak reference, just like any other optional value, and you will never end up with a reference to an invalid instance that no longer exists."),
			
			Question(question: ["Are property observers called when ARC sets a weak reference to nil?",
								"Property observers are called when ARC sets a weak reference to nil. Is that true?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 1714,
					 helpText: "Property observers aren’t called when ARC sets a weak reference to nil."),
			
			Question(question: ["Unlike a weak reference, an unowned reference is ..."],
					 image: "",
					 optionA: "Expected to always have a value",
					 optionB: "Optional",
					 optionC: "Does keep a strong hold",
					 optionD: "",
					 questionId: 1715,
					 helpText: "Like a weak reference, an unowned reference does not keep a strong hold on the instance it refers to. Unlike a weak reference, an unowned reference is expected to always have a value. As a result, marking a value as unowned doesn’t make it optional, and ARC never sets an unowned reference’s value to nil."),
			
			Question(question: ["You indicate an unowned reference by placing the ___ keyword",
								"With which keyword can you indicate the unowed reference?",
								"Unowes reference indicate with this keyword"],
					 image: "",
					 optionA: "unowned",
					 optionB: "weak",
					 optionC: "strong",
					 optionD: "static",
					 questionId: 1716,
					 helpText: "You indicate an unowned reference by placing the unowned keyword before a property or variable declaration."),
			
			/// Самописный текст и перевод 1717 - 1718
			
			Question(question: ["Is the unowned reference optional?",
								"The unowed referece is optional. Is that true?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 1717,
					 helpText: "Since the unowned reference is not optional, you don't need to unwrap it every time you want to use it. You can refer to the unowned reference directly."),
			
			Question(question: ["Can ARC set an unowned reference to nil?",
								"ARC can set an unowned reference to nil. Is that true?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 1718,
					 helpText: "ARC cannot set an unowned reference to nil when the instance it refers to is deallocated, since non-optional variables cannot be nil."),
			
			Question(question: ["If you try to access the value of an unowned reference after that instance has been deallocated, you’ll get this ___",
								"What is going to happen, if you try to access the value of an unowned reference after that instance has been deallocated?"],
					 image: "",
					 optionA: "Runtime error",
					 optionB: "Compilation error",
					 optionC: "Nothing",
					 optionD: "We will get nil",
					 questionId: 1719,
					 helpText: "Use an unowned reference only when you are sure that the reference always refers to an instance that has not been deallocated. If you try to access the value of an unowned reference after that instance has been deallocated, you’ll get a runtime error."),
			
			Question(question: ["Can the reference cycle occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance?",
								"A strong reference cycle can also occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance. Is that true?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1720,
					 helpText: "A strong reference cycle can also occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance. This capture might occur because the closure’s body accesses a property of the instance, such as self.someProperty, or because the closure calls a method on the instance, such as self.someMethod(). In either case, these accesses cause the closure to “capture” self, creating a strong reference cycle. This strong reference cycle occurs because closures, like classes, are reference types. When you assign a closure to a property, you are assigning a reference to that closure."),
			
			Question(question: ["You can resolve a strong reference cycle between a closure and a class instance doing this ___",
								"What can you do, if you want resolve a strong reference cycle between a closure and a class instance?"],
					 image: "",
					 optionA: "Defining a capture list",
					 optionB: "Use lazy properties",
					 optionC: "Use strong references",
					 optionD: "Use weak references",
					 questionId: 1721,
					 helpText: "You resolve a strong reference cycle between a closure and a class instance by defining a capture list as part of the closure’s definition. A capture list defines the rules to use when capturing one or more reference types within the closure’s body."),
			
			Question(question: ["Within which braces you need to written the capture list?",
								"The capture list is written within a pair of these braces"],
					 image: "",
					 optionA: "[capture list]",
					 optionB: "{capture list}",
					 optionC: "(capture list)",
					 optionD: "",
					 questionId: 1722,
					 helpText: "Each item in a capture list is a pairing of the weak or unowned keyword with a reference to a class instance (such as self) or a variable initialized with some value (such as delegate = self.delegate). These pairings are written within a pair of square braces, separated by commas."),
			
			Question(question: ["If a closure does not specify a parameter list or return type because they can be inferred from context, where do we need to place the capture list?",
								"Where do we need to place the capture list, if a closure does not specify a parameter list or return type?"],
					 image: "",
					 optionA: "Before the in keyword",
					 optionB: "After the in keyword",
					 optionC: "",
					 optionD: "",
					 questionId: 1723,
					 helpText: "If a closure does not specify a parameter list or return type because they can be inferred from context, place the capture list at the very start of the closure, followed by the in keyword."),
			
			Question(question: ["If the captured reference will never become nil, should we choose an unowned reference, or a weak reference?",
								"We will choose unowed or weak reference if the captured reference will never become nil?"],
					 image: "",
					 optionA: "Unowed reference",
					 optionB: "Weak reference",
					 optionC: "It doesn't matter",
					 optionD: "",
					 questionId: 1724,
					 helpText: "If the captured reference will never become nil, it should always be captured as an unowned reference, rather than a weak reference.")
		]
	}
}
