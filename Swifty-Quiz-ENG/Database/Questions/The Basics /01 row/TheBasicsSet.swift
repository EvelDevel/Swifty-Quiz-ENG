
//  Created by Евгений Никитин on 15.04.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

// MARK:  Вопросы (id) с 1 по 100

class TheBasicsSet {
    static func getQuestions() -> [Question] {
        return [
            Question(question: ["С какой буквы, согласно хорошей практики, должно начинаться имя переменной в Swift?",
                                "Рекомендуется писать имя переменной или константы именно с этой буквы",
                                "С какой буквы рекомендуется писать имена переменных или констант в Swift?"],
                     image: "",
                     optionA: "Со строчной",
                     optionB: "С заглавной",
                     optionC: "По желанию",
                     optionD: "",
                     questionId: 1,
                     helpText: "Хорошей практикой является использование названий свойств и методов в CamelCase. То есть названия начинаются со строчной буквы (Lower Camel Case). Если название состоит из нескольких слов, то только первое начинается со строчной буквы. Названия типов рекомендуется писать с заглавной буквы (Upper Camel Case)."),
            
            Question(question: ["Как называется создание нового объекта, с которым планируется взаимодействие?",
                                "Создание нового объекта, с которым планируется взаимодействие"],
                     image: "",
                     optionA: "Объявление",
                     optionB: "Модифицикация",
                     optionC: "Инициализация",
                     optionD: "",
                     questionId: 2,
                     helpText: "Объявление - создание нового объекта с которым планируется взаимодействие. Инициализация - присвоение объявленному объекту определенного значения."),
            
            Question(question: ["Какими должны быть имена переменных?",
                                "Какими должны быть имена констант или переменных?",
                                "Мы должны придумывать именно такими имена переменных или констант"],
                     image: "",
                     optionA: "Уникальными",
                     optionB: "Универсальными",
                     optionC: "Односложными",
                     optionD: "",
                     questionId: 3,
                     helpText: "Переменные и константы должны иметь уникальные имена. Нельзя использовать в программе несколько переменных и (или) констант с одними и теми же именами. Причем хорошей практикой является использование названий в так называемом верблюжьем регистре или CamelCase. То есть названия начинаются со строчной буквы. Если название состоит из нескольких слов, то только первое из них начинается со строчной буквы."),
            
            Question(question: ["Должны ли вы употреблять var и let каждый раз, когда обращаетесь к созданной переменной или константе?",
                                "Каждый раз обращаясь к переменной или константе вы обязаны указывать операторы var или let. Так ли это?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "Только let",
                     optionD: "",
                     questionId: 63,
                     helpText: "Операторы var и let необходимо задействовать только при объявлении параметра. В дальнейшем при обращении к объявленным переменным и константам требуется использовать только их имена."),
            
            Question(question: ["Можете ли вы создать переменную с именем, уже занятым другой переменной?",
                                "Можем ли мы присвоить константе имя, занятое другой константой?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 64,
                     helpText: "Имена должны быть уникальными. Нельзя создавать переменную или константу с именем, уже занятым другой переменной или константой."),
            
            Question(question: ["Как называется завершенная команда языка Swift?",
                                "В Swift завершенная команда называется именно так"],
                     image: "",
                     optionA: "Выражение",
                     optionB: "Переменная",
                     optionC: "Константа",
                     optionD: "Предложение",
                     questionId: 4,
                     helpText: "Завершенная команда в языке Swift называется выражением. Swift, как и любой другой язык программирования, выполняет свои функции с помощью команд, которые отдает (пишет) разработчик. Файл с кодом обычно состоит из совокупности выражений, написанных на множестве строк."),
            
            Question(question: ["Возможно ли объявить нескольких констант в одну строку?",
                                "Можем ли мы объявить сразу две переменные в одну строку?",
                                "Возможно ли объявление двух и более переменных или констант в одну строку?"],
                     image: "",
                     optionA: "Да, через запятую",
                     optionB: "Да, через обратный слеш",
                     optionC: "Нет, каждая с новой строки",
                     optionD: "Да, через двоеточие",
                     questionId: 5,
                     helpText: "Мы можем определить сразу несколько переменных и констант на одной строке. В этом случае они должны разделяться запятой."),
            
            Question(question: ["Можем ли мы менять значение переменной?",
                                "Изменяется ли значение, присвоенное переменной?",
                                "Возможно ли поменять значение, присвоенное переменной?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "Да, но только внутри цикла",
                     optionD: "",
                     questionId: 6,
                     helpText: "Отличительной особенностью переменных является то, что мы можем изменять их значение многократно во время работы программы."),
            
            Question(question: ["Именованный участок памяти, значение которого можно установить только один раз и нельзя изменить в дальнейшем",
                                "Значение этого именованного участка памяти можно установить только один раз, без возможности менять его в дальнейшем" ],
                     image: "",
                     optionA: "Константа",
                     optionB: "Постоянная",
                     optionC: "Лямбда",
                     optionD: "",
                     questionId: 7,
                     helpText: "Константы подобны переменным, они также хранят некоторое значение, за тем исключением, что определяются с помощью ключевого слова let, и мы не можем после их инициализации изменить их значение. Таким образом, если значение некоторой переменной в течении программы меняться не будет, то вместо этой переменной лучше использовать константу."),
            
            Question(question: ["Ключевое слово, которое используется для определения константы",
                                "Какое ключевое слово используется для определения константы?",
                                "Этим ключевым словом можно определить константу"],
                     image: "",
                     optionA: "let",
                     optionB: "set",
                     optionC: "var",
                     optionD: "",
                     questionId: 8,
                     helpText: "Константы подобны переменным, они также хранят некоторое значение, за тем исключением, что определяются с помощью ключевого слова let, и мы не можем после их инициализации изменить их значение. Таким образом, если значение некоторой переменной в течении программы меняться не будет, то вместо этой переменной лучше использовать константу."),
            
            Question(question: ["В каком случае данные в константе могут перезаписываться?",
                                "Исключение, при котором данные в константе могут перезаписываться"],
                     image: "",
                     optionA: "Внутри цикла",
                     optionB: "Только во ViewDidLoad()",
                     optionC: "Внутри функции",
                     optionD: "",
                     questionId: 9,
                     helpText: "Исключением является использование в цикле, где константа каждую итерацию будет перезаписываться."),
            
            Question(question: ["Какое ключевое слово используется для определения переменной?",
                                "Ключевое слово, которое используется для определения переменной",
                                "Этим ключевым словом можно определить переменную"],
                     image: "",
                     optionA: "var",
                     optionB: "let",
                     optionC: "func",
                     optionD: "set",
                     questionId: 10,
                     helpText: "Для определения переменной используется ключевое слово var. Отличительной особенностью переменных является то, что мы можем изменять их значение многократно во время работы программы"),
            
            Question(question: ["Как оформляется справочный комментарий?"],
                     image: "",
                     optionA: "/** Комментарий */",
                     optionB: "// Комментарий",
                     optionC: "/// Комментарий",
                     optionD: "// MARK: Комментарий",
                     questionId: 66,
                     helpText: "Помимо стандартный комментариев, которые вы могли видеть в любом языке программирования, Swift позволяет интегрировать комментарии в справочную систему. Такой вид комментариев необходим, когда вы разрабатываете библиотеку функций. Оформляются они следующим образом: /** Комментарий */. После написания справочного комментария к функции, вы можете с зажатой клавишей Alt нажать на ее имя, чтобы получить справку."),
            
            Question(question: ["Именованный участок в памяти, в котором хранится некоторое значение",
                                "Как называется именованный участок в памяти, в котором хранится некоторое значение?",
                                "Поименованная, либо адресуемая иным способом область памяти, адрес которой можно использовать для осуществления доступа к данным"],
                     image: "",
                     optionA: "Переменная или Константа",
                     optionB: "Структура",
                     optionC: "Строка",
                     optionD: "Библиотека",
                     questionId: 11,
                     helpText: "Для хранения данных в Swift, как и в других языках программирования, используются переменные и константы. Переменная или константа представляет собой именованный участок в памяти, в котором хранится некоторое значение."),
            
            Question(question: ["Тип данных, отвечающий за хранение отдельных Unicode-символов",
                                "Какой тип хранит отдельные символы?",
                                "Отдельные Unicode-символы хранятся именно в этом типе данных"],
                     image: "",
                     optionA: "Character",
                     optionB: "Float",
                     optionC: "Bool",
                     optionD: "String",
                     questionId: 12,
                     helpText: "Для работы с текстом применяются два типа данных: Character и String. Character отвечает за хранение отдельных Unicode-символов, а String - за хранение произвольной текстовой информации."),
            
            Question(question: ["Тип данных, отвечающий за хранение произвольной текстовой информации",
                                "Какой тип данных хранит произвольный текст?",
                                "Произвольный строковый литерал можно хранить именно в этом типе"],
                     image: "",
                     optionA: "String",
                     optionB: "Bool",
                     optionC: "Character",
                     optionD: "",
                     questionId: 13,
                     helpText: "Для работы с текстом применяются два типа данных: Character и String. Character отвечает за хранение отдельных Unicode-символов, а String - за хранение произвольной текстовой информации."),
            
            Question(question: ["Если мы точно уверены, что значение переменной меняться не будет, что нам нужно использовать?",
                                "Если мы уверены, что значение переменной не будет меняться, что нам нужно объявить вместо этого?"],
                     image: "",
                     optionA: "Константу",
                     optionB: "Переменную",
                     optionC: "Литерал",
                     optionD: "Структуру",
                     questionId: 14,
                     helpText: "Кроме переменных для хранения данных в программе могут использоваться константы. Константы подобны переменным, они также хранят некоторое значение, за тем исключением, что определяются с помощью ключевого слова let и мы не можем после их инициализации изменить их значение. Таким образом, если значение некоторой переменной в течении программы меняться не будет, то вместо этой переменной лучше использовать константу."),
            
            Question(question: ["Какой тип данных хранит числа, не содержащие дробной части (например 42 или -23)?",
                                "В каком типе хранятся целые числа со знаком?",
                                "Любые целые числа без дробной части хранятся именно в этом типе"],
                     image: "",
                     optionA: "Int",
                     optionB: "UInt",
                     optionC: "Float",
                     optionD: "Double",
                     questionId: 15,
                     helpText: "Int: целое число со знаком, например, 1, -30, 458. На 32-разрядных платформах эквивалентен Int32, а на 64-разрядных - Int64."),
            
            Question(question: ["Все типы в Swift пишутся с ...",
                                "С какой буквы надо писать все типы в Свифт?",
                                "Именно с этой буквы пишутся все типы в Swift"],
                     image: "",
                     optionA: "Заглавной буквы",
                     optionB: "На наше усмотрение",
                     optionC: "Строчной буквы",
                     optionD: "",
                     questionId: 16,
                     helpText: "Все типы в Swift пишутся с заглавной буквы, просто запомните это."),
            
            Question(question: ["Как получить доступ к минимальному и максимальному значению каждого типа целого числа?",
                                "Как получить минимальное и максимальное число у Int или UInt?",
                                "Именно через эти свойства мы можем получить доступ к максимальному и минимальному числу Int и UInt"],
                     image: "",
                     optionA: "min и max",
                     optionB: "first и last",
                     optionC: "count",
                     optionD: "first и max",
                     questionId: 17,
                     helpText: "Вы можете получить минимальное и максимальное значение каждого числа с помощью свойств min и max."),
            
            Question(question: ["Какой тип может хранить более длинные дробные числа?",
                                "В каком типе с плавающей точкой может храниться более длинная дробная часть?",
                                "Именно в этом типе может храниться наибольшее число десятичных знаков"],
                     image: "",
                     optionA: "Double",
                     optionB: "Float",
                     optionC: "UInt",
                     optionD: "",
                     questionId: 18,
                     helpText: "Double является 64 битным числом с плавающей точкой – его следует использовать, когда значения должны быть очень большими или особенно точными. Он имеет точность в 15 десятичных знаков, тогда как Float – только 6."),
            
            Question(question: ["Какой тип хранит только положительные целые числа?",
                                "Тип, хранящий только целые числа без знака",
                                "В этом типе могут храниться только положительные целые числа"],
                     image: "",
                     optionA: "UInt",
                     optionB: "Float",
                     optionC: "Int",
                     optionD: "Double",
                     questionId: 19,
                     helpText: "Swift предусматривает беззнаковый тип целого числа - UInt (Unsigned integer), который имеет тот же размер, что и разрядность системы. Используйте UInt только когда вам действительно нужен тип беззнакового целого числа. Если это не так, использовать Int предпочтительнее даже когда известно, что значения будут неотрицательными. Постоянное использование Int для целых чисел способствует совместимости, кода позволяет избежать преобразования между разными типами чисел и соответствует выводу типа целого числа."),
            
            Question(question: ["Фиксированная последовательность символов, окруженная двойными кавычками",
                                "Последовательность произвольных символов внутри двойных кавычек",
                                "Этот литерал состоит из какой-либо последовательности символов"],
                     image: "",
                     optionA: "Строковый литерал",
                     optionB: "Числовой литерал",
                     optionC: "Пустой литерал массива",
                     optionD: "",
                     questionId: 20,
                     helpText: "Фиксированная последовательность символов, окруженная двойными кавычками, называется строковым литералом. Обычно используется как начальное значение для инициализации константы или переменной, при этом тип можно объявить неявно."),
            
            Question(question: ["Фиксированная последовательность цифр",
                                "Последовательность цифр, начинающаяся с префиксного оператора «-» или «+»",
                                "Как называется любой из этих примеров: «-2234», «10», «0»?"],
                     image: "",
                     optionA: "Числовой литерал",
                     optionB: "Оператор",
                     optionC: "Строковый литерал",
                     optionD: "Случайное число",
                     questionId: 21,
                     helpText: "Фиксированная последовательность цифр, начинающаяся либо с цифры, либо с префиксного оператора «минус» или «плюс», называется числовым литералом."),
            
            Question(question: ["Как можно объявлять тип данных?",
                                "В Swift можно объявить тип данных несколькими способами, как?",
                                "Именно так в Swift можно объявлять тип данных у константы или переменной"],
                     image: "",
                     optionA: "Явно или Неявно",
                     optionB: "Неявно",
                     optionC: "Внятно или Невнятно",
                     optionD: "",
                     questionId: 22,
                     helpText: "Явно, указывая тип данных при объявлении переменной, через двоеточие. Либо неявно, инициализируя значение в переменной или константе (из которого XCode поймет, какой тип данных присвоить этому значению)."),
            
            Question(question: ["Можно ли использовать переменную с явным, не опциональным типом данных, до ее инициализации?",
                                "Есть переменная с явным, не опциональным типом данных, можете ли вы использовать ее до инициализации?",
                                "Можно ли использовать переменную до инициализации, если она не является опционалом?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 23,
                     helpText: "Использование переменной или константы до ее инициализации в Swift невозможно (кроме значений с опциональными типами)."),
            
            Question(question: ["Какой тип может хранить любое целое число в пределах от -2 147 483 648 до 2 147 483 647?",
                                "Тип, умеющий хранить любое целое число от -2 147 483 648 до 2 147 483 647?",
                                "Именно этот тип может хранить любое целое число от -2 147 483 648 до 2 147 483 647"],
                     image: "",
                     optionA: "Int32",
                     optionB: "Decimal",
                     optionC: "Uint32",
                     optionD: "Int64",
                     questionId: 24,
                     helpText: "Значения от -2 147 483 648 до 2 147 483 647 соответствуют Int32."),
            
            Question(question: ["Если в коде не указать размер целого числа, каким оно будет?",
                                "Каким будет размер числа, если не указать конкретное значение при явном объявлении типа?",
                                "Каким установится размер целого числа, если в коде не указать его явно?"],
                     image: "",
                     optionA: "Согласно разрядности системы",
                     optionB: "32",
                     optionC: "64",
                     optionD: "128",
                     questionId: 25,
                     helpText: "Если не указано иного, то размер числа всегда соответствует разрядности системы."),
            
            Question(question: ["Как называется объявление переменной с присваиванием ей значения?",
                                "Объявление переменной с присваиванием ей значения",
                                "Присвоение объявленному объекту начального значения"],
                     image: "",
                     optionA: "Инициализация",
                     optionB: "Возведение",
                     optionC: "Объявление",
                     optionD: "",
                     questionId: 26,
                     helpText: "Инициализация - подготовительный процесс экземпляра класса, структуры или перечисления для дальнейшего использования. Этот процесс включает в себя установку начальных значений для каждого свойства хранения этого экземпляра и проведение любых настроек или инициализации, которые нужны до того, как экземпляр будет использоваться."),
            
            Question(question: ["Какую точность в десятичных знаках имеет тип Double?",
                                "Сколько десятичных цифр может хранить тип Double?",
                                "Double может хранить именно столько цифр после запятой"],
                     image: "",
                     optionA: "15 десятичных цифр",
                     optionB: "6 десятичных цифр",
                     optionC: "12 десятичных цифр",
                     optionD: "18 десятичных цифр",
                     questionId: 27,
                     helpText: "Double является 64 битным числом с плавающей точкой. Он имеет точность в 15 десятичных знаков."),
            
            Question(question: ["Какую точность в десятичных знаках имеет тип Float?",
                                "Сколько десятичных цифр может хранить тип Float?",
                                "Float может хранить именно столько цифр после запятой"],
                     image: "",
                     optionA: "6 десятичных цифр",
                     optionB: "4 десятичных цифр",
                     optionC: "12 десятичных цифр",
                     optionD: "10 десятичных цифр",
                     questionId: 28,
                     helpText: "Float имеет точность в 6 десятичных знаков."),
            
            Question(question: ["Если равноценно использование обоих типов с плавающей точкой, использование какого предпочтительнее?",
                                "В случаях, где возможно использование обоих типов (Float и Double), какой предпочтительнее?",
                                "В ситуациях, где нужна бОльшая точность вычислений, какой тип необходимо использовать?"],
                     image: "",
                     optionA: "Double",
                     optionB: "Float",
                     optionC: "Character",
                     optionD: "String",
                     questionId: 29,
                     helpText: "Double имеет точность минимум 15 десятичных цифр, в то время как точность Float может быть всего лишь 6 десятичных цифр. Соответствующий тип числа с плавающей точкой используется в зависимости от характера и диапазона значений, с которыми вы должны работать в коде. В случаях, где возможно использование обоих типов, предпочтительным считается Double."),
            
            Question(question: ["Можете ли вы передать тип Int, если некоторая часть кода ожидает тип String?",
                                "Если некоторая часть кода ожидает тип String, можете ли вы передать Character?",
                                "Можете ли вы передать положительное число типа Int32, если некоторая часть кода ожидает Uint32?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "В некоторых случаях",
                     optionD: "",
                     questionId: 30,
                     helpText: "Swift - язык со строгой типизацией. Язык со строгой типизацией призывает вас иметь четкое представление о типах значений, с которыми может работать ваш код. Если часть вашего кода ожидает String (например), вы не сможете передать ему Int (или любой другой тип, кроме String) по ошибке."),
            
            Question(question: ["Cколько двойных кавычек нужно ставить при открытии и закрытии многострочного строкового литерала?",
                                "Какое количество двойных кавычек ставится при открытии многострочного строкового литерала?",
                                "При закрытии открытии многострочного строкового литерала ставится именно столько двойных кавычек"],
                     image: "",
                     optionA: "По три",
                     optionB: "По две",
                     optionC: "По одной",
                     optionD: "По четыре",
                     questionId: 31,
                     helpText: "Если вам нужно создать строку, которая поддерживает многострочный вид, используйте литерал многострочной строки - последовательность символов, обернутых в три двойные кавычки. Многострочный литерал строки включает в себя все строки между тремя открывающими и тремя закрывающими кавычками. Строка начинается на первой строке после открывающих кавычек, а заканчивается на строке предшествующей закрывающим кавычкам."),
            
            Question(question: ["Каким символом осуществляется перенос строки в многострочном строковом литерале (в коде), позволяющий не отображать символ переноса строки в качестве части значения этой строки?",
                                "Этот символ может перенести строку многострочного литерала только внутри кода (для лучшего чтения), не отображая перенос строки как часть значения этой строки"],
                     image: "",
                     optionA: "Обратный слеш",
                     optionB: "Звездочка",
                     optionC: "Тире",
                     optionD: "",
                     questionId: 32,
                     helpText: "Если вы хотите использовать символ переноса строки для того, чтобы сделать ваш код более читаемым, но вы не хотите чтобы символ переноса строки отображался в качестве части значения строки, то вам нужно использовать символ обратного слеша в конце этих строк. Проще говоря, если вы хотите перенести строку внутри кода, чтобы сделать его более читаемым, но не хотите, чтобы после компиляции эта строка также перенеслась."),
            
            Question(question: ["Как можно инициализировать пустую строку?",
                                "Как инициализируется пустой тип String?",
                                "Инициализация пустой строки происходит именно таким(ими) способом(ами)"],
                     image: "",
                     optionA: "= String()",
                     optionB: "= [String]",
                     optionC: "= (String)",
                     optionD: "",
                     questionId: 33,
                     helpText: "Чтобы создать пустое String значение в качестве отправной точки для создания более длинных строк, либо присвойте литерал пустой строки к переменной, либо инициализируйте объект String c помощью синтаксиса инициализации: = String()."),
            
            Question(question: ["Способ создать новое значение типа String из разных констант, переменных, литералов и выражений, включая их значения в строковый литерал",
                                "Создание нового String-значения из разных констант, переменных, литералов и выражений, включая их значения в строковый литерал",
                                "Включение разных значений в String, используя обратный слеш и круглые скобки, называется?"],
                     image: "",
                     optionA: "Интерполяция",
                     optionB: "Конкатенация",
                     optionC: "Объединение строк",
                     optionD: "Вкрапление значений",
                     questionId: 34,
                     helpText: "Интерполяция строк - способ создать новое значение типа String из разных констант, переменных, литералов и выражений, включая их значения в строковый литерал. Каждый элемент, который вы вставляете в строковый литерал, должен быть помещен в скобки и находиться внутри двойных кавычек литерала, а перед открывающей скобкой должен стоять знак обратного слэша."),
            
            Question(question: ["Каким образом можно добавить значение типа Character к переменной типа String?",
                                "Как мы можем добавить один Character к переменной типа String?",
                                "Используя какой метод мы можем добавить Character к переменной String?"],
                     image: "",
                     optionA: "Используя String append",
                     optionB: "Конкатенация",
                     optionC: "Приведение типов",
                     optionD: "Через оператор сложения",
                     questionId: 35,
                     helpText: "Вы можете добавить значение типа Character к переменной типа String, используя метод String append. Вы не можете добавить String или Character к уже существующей переменной типа Character, потому что значение типа Character должно состоять только из одиночного символа."),
            
            Question(question: ["Можно ли сравнивать две строки?",
                                "Возможно ли сравнение двух значений типа String?",
                                "Можем ли мы сравнить два значения String?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Только ==",
                     optionC: "Только !=",
                     optionD: "Нет",
                     questionId: 36,
                     helpText: "Swift предусматривает три способа сравнения текстовых значений: равенство строк и символов, равенство префиксов, и равенство суффиксов. Равенство строк и символов проверяется оператором равенства (==) и оператором неравенства (!=). Два String значения (или два Character значения) считаются равными, если их расширенные наборы графем канонически эквивалентны. Расширенные наборы графем канонически эквивалентны, если они имеют один и тот же языковой смысл и внешний вид, даже если они изначально состоят из разных скалярных величин Юникода."),
            
            Question(question: ["Что вернется, при сравнении двух String?",
                                "Какой тип вернется в результате сравнения двух String значений?",
                                "Что мы получим после сравнения двух Character?"],
                     image: "",
                     optionA: "Bool",
                     optionB: "String",
                     optionC: "Character",
                     optionD: "1 или 0",
                     questionId: 37,
                     helpText: "При сравнении String или Character возвращается Bool-значение (true или false)."),
            
            Question(question: ["Какой тип будет присвоен переменной с изображения?",
                                "Какой тип будет присвоен при подобной неявной типизации?"],
                     image: "TheBasics36",
                     optionA: "Double",
                     optionB: "Float",
                     optionC: "Decimal",
                     optionD: "",
                     questionId: 38,
                     helpText: "При неявной типизации, числу с плавающей точкой присваивается тип Double, так как он является предпочтительным выбором."),
            
            Question(question: ["Что мы получим, при попытке запустить этот код?"],
                     image: "TheBasics37",
                     optionA: "Столкнемся с ошибкой",
                     optionB: "Ничего не произойдет",
                     optionC: "Переменной присваивается число",
                     optionD: "Переменная обнуляется",
                     questionId: 39,
                     helpText: "Swift является типобезопасным языком со строгой типизацией, поэтому после того, как мы присвоили переменной тип, мы не можем его изменить. Так, в этом случае мы столкнемся с ошибкой. Ошибка возникает, так как переменная name ожидает строковый литерал, а число с плавающей точкой не является строкой и не соответствует переменной name по типу."),
            
            Question(question: ["Набор символов, зарезервированный языком программирования?",
                                "Зарезервированные языком программирования наборы символов, которые не могут быть использованы в качестве идентификаторов"],
                     image: "",
                     optionA: "Ключевое слово",
                     optionB: "Функция",
                     optionC: "Замыкание",
                     optionD: "Идентификатор",
                     questionId: 40,
                     helpText: "Ключевые слова зарезервированы и не могут быть использованы в качестве идентификаторов, если не помещены в одиночные кавычки. Ключевые слова, кроме inout, var,  и let, могут быть использованы в качестве внешних имен параметров в объявлении функции или в вызове функции без необходимости помещать их в одиночные кавычки."),
            
            Question(question: ["Что мы получим, при сравнении переменных name и char?"],
                     image: "TheBasics39",
                     optionA: "true",
                     optionB: "false",
                     optionC: "Ошибку",
                     optionD: "",
                     questionId: 41,
                     helpText: "Хотя мы и присваиваем переменной char всего один отдельный символ, без явного указания типа данных Swift автоматически присвоит тип String, поэтому две этих переменных могут сравниваться, и результатом сравнения будет true (потому что в данном случае значения у переменных равны)"),
            
            Question(question: ["Что мы получим, при сравнении переменных name и name2?"],
                     image: "TheBasics40",
                     optionA: "Ошибку сравнения",
                     optionB: "false",
                     optionC: "true",
                     optionD: "",
                     questionId: 42,
                     helpText: "Перед нами две переменных с разными значениями, и если поторопиться, то можно ответить, что результатом сравнения будет false, так как их значения не равны. Но в данном случае, у переменных разные типы данных, и подобное сравнение вызовет ошибку Binary operator '==' cannot be applied to operands of type 'String' and 'Character'"),
            
            Question(question: ["Являются ли все базовые типы (Int, String, Double, Bool) в Swift хешируемыми?",
                                "Все базовые типы (Int, String, Double, Bool) в Swift являются хешируемыми, так ли это?",],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "Все, кроме Bool",
                     optionD: "Все, кроме String",
                     questionId: 43,
                     helpText: "Все базовые типы Swift (Int, String, Double, Bool) являются хешируемыми типами по умолчанию и могут быть использованы в качестве типов значений множества или в качестве типов ключей словаря. Значения членов перечисления без каких-либо связанных значений так жетакже являются хешируемыми по умолчанию."),
            
            Question(question: ["Что позволяет создавать и передавать группы значений, и возвращать несколько значений из функции?",
                                "С помощью этого можно вернуть несколько значений из функции как одно целое значение",
                                "С помощью чего мы можем создавать и передавать группы значений в Swift?"],
                     image: "",
                     optionA: "Кортеж",
                     optionB: "Опционал",
                     optionC: "Множество",
                     optionD: "Переменная",
                     questionId: 44,
                     helpText: "В дополнение к знакомым типам, Swift включает расширенные типы, которых нет в Objective-C. К ним относятся кортежи, которые позволяют создавать и передавать группы значений. Кортежи могут возвращать несколько значений из функции как одно целое значение."),
            
            Question(question: ["Тип, позволяющий работать с отсутствующими значениями",
                                "Какой тип позволяет работать с отсутствующими значениями?",
                                "С отсутствующими значениями можно работать с помощью этого типа"],
                     image: "",
                     optionA: "Опциональный тип",
                     optionB: "Тип кортежа",
                     optionC: "Тип коллекции",
                     optionD: "",
                     questionId: 45,
                     helpText: "Swift также включает опциональные типы, которые позволяют работать с отсутствующими значениями. Опциональные значения говорят либо «здесь есть значение, и оно равно х», либо «здесь нет значения вообще». Опциональные типы подобны использованию nil с указателями в Objective-C, но они работают со всеми типами, не только с классами. Опциональные значения безопаснее и выразительнее чем nil указатели в Objective-C, и находятся в сердце многих наиболее мощных особенностей Swift."),
            
            Question(question: ["Можем ли мы передать опциональный String куску кода, который ожидает неопциональный String?",
                                "Можете ли вы передать опциональный тип Double куску кода, который ждет неопциональный тип Double?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 46,
                     helpText: "Swift - язык типобезопасный, что означает, что Swift помогает вам понять, с какими типами значений ваш код может работать. Если кусок вашего кода ожидает String, безопасность типов не даст вам передать ему Int по ошибке. Кроме того, безопасность типов не позволит вам случайно передать опциональный String куску кода, который ожидает неопциональный String. Безопасность типов позволяет вам улавливать и исправлять ошибки как можно раньше в процессе разработки."),
            
            Question(question: ["Выберите соответствующий вариант: Объявляем константу с именем numbers, тип которой будет Double со значением 1.0.",
                                "Как мы запишем следующее: Объявляем константу с именем numbers, тип которой будет Double со значением 1.0."],
                     image: "",
                     optionA: "let numbers: Double = 1.0",
                     optionB: "var numbers: Double = 1.0",
                     optionC: "let numbers = Double(1.0)",
                     optionD: "let numbers = Double : 1.0",
                     questionId: 47,
                     helpText: "Правильный ответ будет: let numbers: Double = 1.0."),
            
            Question(question: ["Можем ли мы использовать значение с типом Int? как операнд в математической операции?",
                                "Можете ли вы использовать Double? как операнд в математической операции?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 71,
                     helpText: "Запомните, опциональный тип данных - это совершенно новый тип данных, поэтому, несмотря на то, что опционалы могут принимать значения основных типов данных, остальные свойства этих типов к опционалам не относятся. Например вы не можете использовать типы Int? или Double? при выполнении математических операций."),
            
            Question(question: ["Что не могут содержать имена констант и переменных?",
                                "Это нельзя использовать при написании имен констант и переменных",
                                "Выберите, что не могут содержать имена переменных и констант?"],
                     image: "",
                     optionA: "Пробелы и стрелки",
                     optionB: "Латинские буквы",
                     optionC: "Нижнее подчеркивание",
                     optionD: "Unicode-символы",
                     questionId: 48,
                     helpText: "Имена констант и переменных не могут содержать пробелы, математические символы, стрелки, приватные (или невалидные) кодовые точки Unicode, а так жетакже символы отрисовки линий или прямоугольников. Так жеТакже имена не могут начинаться с цифр, хотя цифры могут быть включены в имя в любом другом месте. "),
            
            Question(question: ["Можем ли мы после объявления константы, дальше по коду изменить ее на переменную?",
                                "После объявление переменной, дальше по коду, можем ли мы поменять ее на константу?",
                                "Можем ли мы менять константы на переменные, а переменные - на константы?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 49,
                     helpText: "Если вы объявили константу или переменную определенного типа, то вы не можете объявить ее заново с тем же именем или заставить хранить внутри себя значение другого типа. Также вы не можете изменить константу на переменную, а переменную - на константу."),
            
            Question(question: ["Какая глобальная функция может вывести одно или более значений в консоль?",
                                "Глобальная функция, которая используется для выведения значений в консоль",
                                "Функция, являющаяся глобальной, и позволяющая выводить одно или более значений в консоль?"],
                     image: "",
                     optionA: "print(_:separator:terminator:)",
                     optionB: "show()",
                     optionC: "alert()",
                     optionD: "Console.WriteLine",
                     questionId: 50,
                     helpText: "Функция print(_:separator:terminator:) является глобальной, которая выводит одно или более значений в подходящем виде. В Xcode, например, функция print(_:separator:terminator:) выводит значения в консоль. Параметры separator и terminator имеют дефолтные значения, так что при использовании функции их можно просто пропустить. По умолчанию функция заканчивает вывод символом переноса строки. Чтобы вывести в консоль значения без переноса на новую строку, вам нужно указать пустую строку в параметре terminator."),
            
            Question(question: ["Как называется игнорируемый компилятором, неисполняемый текст в коде?",
                                "Как называется неисполняемый текст в коде?",
                                "Что нужно добавить, чтобы у вас появился неисполняемый участок кода?"],
                     image: "",
                     optionA: "Комментарий",
                     optionB: "Исключение",
                     optionC: "Примечание",
                     optionD: "",
                     questionId: 51,
                     helpText: "Используйте комментарии, чтобы добавить неисполняемый текст в коде,  как примечание или напоминание самому себе. Комментарии игнорируются компилятором Swift во время компиляции кода. Комментарии в Swift очень похожи на комментарии в C. Однострочные комментарии начинаются с двух слешей (//), многострочные комментарии начинаются со слеша и звездочки (/*) и заканчиваются звездочкой, за которой следует слеш (*/). Внутри многострочного комментария вы можете поместить любой участок кода, который хотите сделать неисполняемым."),
            
            Question(question: ["Один случай, когда в Swift необходимо ставить точку с запятой (;) в коде?",
                                "В каком случае вам необходимо будет поставить точку с запятой (;) в коде?",
                                "В этом случае вам нужно ставить точку с запятой в коде"],
                     image: "",
                     optionA: "Несколько выражений на строке",
                     optionB: "Объявление двух переменных",
                     optionC: "После каждого выражения",
                     optionD: "",
                     questionId: 52,
                     helpText: "В отличие от многих других языков, Swift не требует писать точку с запятой (;) после каждого выражения в коде, хотя вы можете делать это, если хотите. Однако точки с запятой требуются, если вы хотите написать несколько отдельных выражений на одной строке. Пример: let name = SomeValue; print(name)."),
            
            Question(question: ["Какой тип будет у константы number?",
                                "Выберите правильный тип, который Swift присвоит константе number?",
                                "У константы number будет именно такой тип"],
                     image: "TheBasics51",
                     optionA: "Double",
                     optionB: "Float",
                     optionC: "Int",
                     optionD: "Character",
                     questionId: 53,
                     helpText: "Если объединить целые литералы и литералы с плавающей точкой в одном выражении, в этом случае тип будет выводиться как Double. Swift всегда выбирает Double (вместо Float), когда выводит тип чисел с плавающей точкой. Литеральное значение 1 не имеет явного типа само по себе, так что соответствующий тип Double выводится из наличия литерала с плавающей точкой как части сложения."),
            
            Question(question: ["Как изменить имя существующего типа на более подходящее по контексту?",
                                "Как вы можете изменить имя существующего типа на подходящее по контексту?",
                                "Как можно задать альтернативное имя для существующего типа?"],
                     image: "",
                     optionA: "Создать typealias",
                     optionB: "Создать копию типа",
                     optionC: "Создать контекстное имя",
                     optionD: "Это невозможно",
                     questionId: 54,
                     helpText: "Псевдонимы типов задают альтернативное имя для существующего типа. Можно задать псевдоним типа с помощью ключевого слова typealias. Псевдонимы типов полезны, когда вы хотите обратиться к существующему типу по имени, которое больше подходит по контексту. После того как вы один раз задали псевдоним типа, вы можете использовать псевдоним везде, где вы хотели бы его использовать. "),
            
            Question(question: ["Какие две логические константы предусматривает Swift для типа Bool?",
                                "В Swift есть две логические постоянные для типа Bool, какие?",
                                "Какие два логических значения мы можем присваивать переменным типа Bool?"],
                     image: "",
                     optionA: "true и false",
                     optionB: "true и not true",
                     optionC: "1 и 0",
                     optionD: "truth и false",
                     questionId: 55,
                     helpText: "В Swift есть простой логический тип Bool. Этот тип называют логическим, потому что он может быть только true или false. Swift предусматривает две логические константы, true и false соответственно. Так же как с Int и Double в предыдущих главах, вам не нужно указывать константы или переменные как Bool, если при создании вы присвоили им значения true или false. Вывод типов помогает сделать код Swift кратким и читабельным тогда, когда вы создаете константы или переменные со значениями которые точно известны."),
            
            Question(question: ["Как корректно обратиться в первому элементу кортежа?",
                                "Каким образом мы можем обратиться к первому элементу кортежа?",
                                "Мы можем обратиться к первому элементу кортежа через числовой индекс, как именно?"],
                     image: "",
                     optionA: "someTuples.0",
                     optionB: "someTuples.1",
                     optionC: "someTuples[0]",
                     optionD: "someTuples(1)",
                     questionId: 56,
                     helpText: "Вы можете разложить содержимое кортежа на отдельные константы и переменные, к которым можно получить доступ привычным способом. Если вам нужны только некоторые из значений кортежа, вы можете игнорировать части кортежа во время разложения с помощью символа подчеркивания (_). В качестве альтернативы можно получать доступ к отдельным частям кортежа, используя числовые индексы, начинающиеся с нуля."),
            
            Question(question: ["Когда мы можем дать имена отдельным элементам кортежа?",
                                "В какой момент мы можем дать имена отдельным элементам кортежа?"],
                     image: "",
                     optionA: "Во время объявления",
                     optionB: "После инициализации",
                     optionC: "После первого использования",
                     optionD: "В момент обращения к элементу",
                     questionId: 57,
                     helpText: "Вы можете давать имена отдельным элементам кортежа во время объявления. Например: let gameRecord = (questionNumber: 50, score: 49)."),
            
            Question(question: ["Особый объект, который группирует значения различных типов в пределах одного составного значения",
                                "Объект, предлагающий наиболее простой способ объединения значений различных типов в пределах одного значения",
                                "У каждого отдельного значения в составе этого объекта может быть собственный тип данных, который никак не зависит от других"],
                     image: "",
                     optionA: "Кортеж",
                     optionB: "Массив",
                     optionC: "Коллекция",
                     optionD: "",
                     questionId: 68,
                     helpText: "Кортеж - это особый объект, который группирует значения различных типов в пределах одного составного значения. Более того, кортеж предлагает наиболее простой способ объединения значений различных типов в пределах одного значения. У каждого отдельного значения в составе кортежа может быть собственный тип данных, который никак не зависит от других."),
            
            Question(question: ["Какой тип используется, когда значение может отсутствовать?",
                                "Если значение можно отсутствовать, какой тип мы будем использовать?",
                                "Этот тип используется, если значение может отсутствовать"],
                     image: "",
                     optionA: "Опциональный",
                     optionB: "Логический Bool",
                     optionC: "Кортеж",
                     optionD: "Неявный тип",
                     questionId: 58,
                     helpText: "Опциональные типы используются в тех случаях, когда значение может отсутствовать. Опциональный тип подразумевает, что возможны два варианта: или значение есть, и его можно извлечь из опционала, либо его вообще нет."),
            
            Question(question: ["Какой тип Swift присвоит константе convertedNum?",
                                "Константе convertedNum присвоится именно этот тип",
                                "Swift присвоит этот тип константе convertedNum"],
                     image: "TheBasics57",
                     optionA: "Int?",
                     optionB: "Int",
                     optionC: "String",
                     optionD: "Столкнемся с ошибкой",
                     questionId: 59,
                     helpText: "Поскольку метод Int() может иметь недопустимый аргумент, он возвращает опциональный Int, вместо Int. Опциональный Int записывается как Int?, а не Int. Знак вопроса означает, что содержащееся в ней значение является опциональным, что означает, что он может содержать некое Int значение, или он может вообще не содержать никакого значения. (Он не может содержать ничего другого, например, Bool значение или значение String. Он либо Int, либо вообще ничто)."),
            
            Question(question: ["Каким образом мы можем установить опциональную переменную в состояние отсутствия значения?",
                                "Каким путем вы можете присвоить опциональной переменной отсутствующее значение?",
                                "Отсутствующее значение для опциональной переменной можно установить именно так"],
                     image: "",
                     optionA: "Присвоить nil",
                     optionB: "Присвоить 0",
                     optionC: "Присвоить литерал пустого массива",
                     optionD: ".removeValue",
                     questionId: 60,
                     helpText: "Мы можем установить опциональную переменную в состояние отсутствия значения, путем присвоения ему специального значения nil. nil не может быть использован с не опциональными константами и переменными. Если значение константы или переменной при определенных условиях в коде должно когда-нибудь отсутствовать, всегда объявляйте их как опциональное значение соответствующего типа."),
            
            Question(question: ["Каким образом мы можем проверить, содержит ли опционал значение?",
                                "Как мы можем узнать, содержит опционал значение или нет?",
                                "Таким образом вы можете узнать, содержит опционал значение или нет"],
                     image: "",
                     optionA: "Сравнивая с nil через if",
                     optionB: "Через оператор ===",
                     optionC: "Внутри цикла for-in",
                     optionD: "Через forced unwrap",
                     questionId: 61,
                     helpText: "Вы можете использовать инструкцию if, сравнивая опционал с nil, чтобы проверить, содержит ли опционал значение. Это сравнение можно сделать с помощью оператора «равенства» (==) или оператора «неравенства» (!=). Если опционал имеет значение, он будет рассматриваться как «неравным» nil."),
            
            Question(question: ["Если мы точно уверены, что опционал имеет значение, каким наиболее быстрым образом мы можем его получить?",
                                "Каким самым быстрым образом мы можем получить значение опционала, если уверены, что оно присутствует?",
                                "Как быстро получить значение опционала, если значение точно есть?"],
                     image: "",
                     optionA: "Принудительное извлечение (!)",
                     optionB: "Внутри цикла while",
                     optionC: "Привязка опционалов",
                     optionD: "Оператор ??",
                     questionId: 62,
                     helpText: "Если вы уверены, что опционал содержит значение, вы можете получить доступ к его значению, добавив восклицательный знак (!) в конце имени опционала. Восклицательный знак фактически говорит: «Я знаю точно, что этот опционал содержит значение, пожалуйста, используй его». Это выражение известно как Принудительное извлечение значения опционала."),
            
            Question(question: ["Объекты, доступные в любой точке программы?"],
                     image: "",
                     optionA: "Глобальные объекты",
                     optionB: "Локальные объекты",
                     optionC: "",
                     optionD: "",
                     questionId: 65,
                     helpText: "Каждый созданный объект может использоваться только по определенным правилам, одно из которых называется областью видимости. Область видимости определяет, где именно в коде можно использовать тот или иной объект. По принадлежности к области видимости объекты делятся на локальные и глобальные."),
            
            Question(question: ["Как называется возможность сослаться на свойство динамически, а не напрямую?"],
                     image: "TheBasics67",
                     optionA: "KeyPath",
                     optionB: "NamePath",
                     optionC: "PropertyURL",
                     optionD: "",
                     questionId: 67,
                     helpText: "Одной из полезных особенностей Objective-C была возможность сослаться на свойство динамически, а не напрямую. Другими словами, вы могли указать объект и его свойство, которое необходимо использовать, но при этом не производить чтение или запись данного свойства сейчас, а сделать это позже. После создания структуры и константы, использующей эту структуру, вы можете использовать символ обратного слеша перед указанием параметра для создания динамический ссылки. В константу name записывается ссылка на значение свойства name из Starship."),
            
            Question(question: ["Какой тип будет у данного кортежа?",
                                "У этого кортежа будет такой тип данных",
                                "Какой тип данных будет присвоен этому кортежу?"],
                     image: "TheBasics69",
                     optionA: "(String, Double, Bool)",
                     optionB: "Tuple.type",
                     optionC: "(String, Float, Bool)",
                     optionD: "(Character, Double, True)",
                     questionId: 69,
                     helpText: "У вас мог возникнуть вопрос: если кортеж группирует значения различных типов данных в одно, то какой же тогда тип данных у самого кортежа? Правильный ответ: (String, Double, Bool). Тип данных кортежа - это фиксированный упорядоченный набор типов данных, входящих в него значений, который записывается в скобках и элементы которого отделяются запятыми друг от друга. Для кортежа из нашего примера это (String, Double, Bool) и у нас он задается неявно. Порядок указания типов данных должен соответствовать порядку следования элементов в кортеже."),
            
            Question(question: ["Можем ли мы задать имя для каждого элемента кортежа?",
                                "Мы не можем задать имена для части элементов кортежа, мы обязаны либо не использовать их вовсе, либо задать их для каждого элемента. Так ли это?",
                                "Присвоение элементам кортежа имен не лишает нас возможности использовать их индексы. Так ли это?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 70,
                     helpText: "Для каждого элемента кортежа можно задать не только значение, но и имя. Имя элемента указывается отдельно перед каждым элементом через двоеточие. При этом задать имена для отдельных элементов невозможно: вы должны либо указать имена для всех элементов, либо не использовать их вовсе. Указанные имена кортежа можно использовать при получении значений этих элементов. При этом применяется тот же синтаксис, что и при доступе через индексы. Присвоение имен значениям не лишает вас возможности использовать индексы. Индексы в кортеже можно задействовать всегда. Доступ к элементам с использованием имен удобнее и нагляднее, чем доступ через индексы."),
            
            Question(question: ["Как называется принудительное извлечение опционального значения?",
                                "Извлечение опционального значения с помощью оператора (!)"],
                     image: "",
                     optionA: "Force unwrap",
                     optionB: "Unwrapping",
                     optionC: "Optional Chaining",
                     optionD: "",
                     questionId: 72,
                     helpText: "Swift предлагает механизм извлечения опционального значения, который называется принудительным извлечением. При этом с помощью специального оператора значение опционального типа данных преобразуется в значение основного (для этого опционала) типа данных, например Int? преобразуется в Int. Для принудительного извлечения используется знак восклицания в качестве постфикса названия параметра, содержащего значение опционального типа. При принудительном извлечении значения вы должны гарантировать, что параметр с опциональным типом данных содержит какое-либо значение, а не равен nil. В противном случае будет иметь место попытка преобразовать в основной тип данных несуществующее значение, после компиляции такого кода мы столкнемся с ошибкой."),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 73,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 74,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 75,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 76,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 77,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 78,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 79,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 80,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 81,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 82,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 83,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 84,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 85,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 86,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 87,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 88,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 89,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 90,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 91,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 92,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 93,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 94,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 95,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 96,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 97,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 98,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 99,
            //                     helpText: ""),
            //
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //                     questionId: 100,
            //                     helpText: ""),
        ]
    }
}



