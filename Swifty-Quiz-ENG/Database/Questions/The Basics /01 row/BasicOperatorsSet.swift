
//  Created by Евгений Никитин on 15.04.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

// MARK:  02 - Вопросы (id) с 101 по 200

class BasicOperatorsSet {
	static func getQuestions() -> [Question] {
		return [
			Question(question: ["A special symbol or phrase that you use to check, change, or combine values"],
					 image: "",
					 optionA: "Operator",
					 optionB: "Operand",
					 optionC: "Variable",
					 optionD: "",
					 questionId: 101,
					 helpText: "An operator is a special symbol or phrase that you use to check, change, or combine values."),
			
			Question(question: ["The value that operators affect in their work",
								"Operators execute commands with these values",
								"In their work, operators affect on this"],
					 image: "",
					 optionA: "Operands",
					 optionB: "Expressions",
					 optionC: "Symbols",
					 optionD: "",
					 questionId: 102,
					 helpText: "The values that operators affect are operands. In the expression 1 + 2, the + symbol is a binary operator and its two operands are the values 1 and 2."),
			
			Question(question: ["Operators that operate on a single target",
								"These operators operate on a single target",
								"These are the operators that can operate only on a single target"],
					 image: "",
					 optionA: "Unary",
					 optionB: "Binary",
					 optionC: "Ternary",
					 optionD: "",
					 questionId: 103,
					 helpText: "Unary operators operate on a single target (such as -a). Unary prefix operators appear immediately before their target (such as !b), and unary postfix operators appear immediately after their target (such as c!)."),
			
			Question(question: ["Unary operators that are appear immediately before the value",
								"These unary operators appear before the value",
								"What kind of unary operators appear immediately before the value?"],
					 image: "",
					 optionA: "Prefix",
					 optionB: "Postfix",
					 optionC: "Infix",
					 optionD: "",
					 questionId: 104,
					 helpText: "Unary prefix operators appear immediately before their target (such as !b)."),
			
			Question(question: ["Unary operators that are appear immediately after the value",
								"These unary operators follow the value (appear after value)",
								"What kind of unary operators appear immediately after the value?"],
					 image: "",
					 optionA: "Postfix",
					 optionB: "Prefix",
					 optionC: "Infix",
					 optionD: "",
					 questionId: 105,
					 helpText: "Unary postfix operators appear immediately after their target (such as c!)."),
			
			Question(question: ["Which of these operators is called the assignment operator?",
								"How is the assignment operator spelled?",
								"Choose an assignment operator from these options"],
					 image: "",
					 optionA: "=",
					 optionB: "==",
					 optionC: "!=",
					 optionD: "===",
					 questionId: 108,
					 helpText: "The assignment operator (a = b) initializes or updates the value of a with the value of b."),
			
			Question(question: ["Operators that operate on two targets",
								"These operators operate on two targets ",
								"What kind of operators operate on two targets at the same time?"],
					 image: "",
					 optionA: "Binary",
					 optionB: "Ternary",
					 optionC: "Unary",
					 optionD: "",
					 questionId: 106,
					 helpText: "Binary operators operate on two targets (such as 2 + 3) and are infix because they appear in between their two targets."),
			
			Question(question: ["Operators that operate on three targets",
								"These operators operate on three targets",
								"Which operators can operate on three targets?"],
					 image: "",
					 optionA: "Ternary",
					 optionB: "Binary",
					 optionC: "Unary",
					 optionD: "All operators",
					 questionId: 107,
					 helpText: "Ternary operators operate on three targets. Like C, Swift has only one ternary operator, the ternary conditional operator (a ? b : c). The ternary conditional operator provides an efficient shorthand for deciding which of two expressions to consider. Use the ternary conditional operator with care, however. Its conciseness can lead to hard-to-read code if overused. Avoid combining multiple instances of the ternary conditional operator into one compound statement."),
			
			Question(question: ["Operators that appear in between their two targets"],
					 image: "",
					 optionA: "Infix",
					 optionB: "Prefix",
					 optionC: "Postfix",
					 optionD: "",
					 questionId: 10600,
					 helpText: "Binary operators operate on two targets (such as 2 + 3) and are infix because they appear in between their two targets."),
			
			Question(question: ["Which operator initializes or changes the value of a variable?",
								"This operator can initialize or change the value of the variable a to the value b",
								"Which operator can assigns the value of the variable a to the value of the variable b?"],
					 image: "",
					 optionA: "=",
					 optionB: "==",
					 optionC: "===",
					 optionD: "",
					 questionId: 109,
					 helpText: "The assignment operator (a = b) initializes or updates the value of a with the value of b. If the right side of the assignment is a tuple with multiple values, its elements can be decomposed into multiple constants or variables at once: let (x, y) = (1, 2)"),
			
			Question(question: ["Can Swift's assignment operator return a value?",
								"Can the assignment operator return a value?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "Only Bool",
					 optionD: "",
					 questionId: 111,
					 helpText: "Unlike the assignment operator in C and Objective-C, the assignment operator in Swift does not itself return a value. This feature prevents the assignment operator (=) from being used by accident when the equal to operator (==) is actually intended. By making if x = y invalid, Swift helps you to avoid these kinds of errors in your code."),
			
			Question(question: ["If the right side of the assignment is a tuple, can we decompose it into multiple constants or variables at once?",
								"The left side of the expression is a tuple, can we assign multiple constants or variables to all of its values",
								"Can we assign multiple constants or variables to tuple values at once?"],
					 image: "",
					 optionA: "Yes, like this: (x, y) = (1, 2)",
					 optionB: "Yes, like this: (x, y) = 1 / 2",
					 optionC: "No, we can't",
					 optionD: "",
					 questionId: 110,
					 helpText: "If the right side of the assignment is a tuple with multiple values, its elements can be decomposed into multiple constants or variables at once: let (x, y) = (1, 2)"),
			
			Question(question: ["How many standard arithmetic operators does Swift support?",
								"How many arithmetic operators are supported in Swift?",
								"Swift supports exactly that many arithmetic operators"],
					 image: "",
					 optionA: "Four",
					 optionB: "Three",
					 optionC: "Two",
					 optionD: "",
					 questionId: 112,
					 helpText: "Swift supports the four standard arithmetic operators for all number types: Addition (+). Subtraction (-). Multiplication (*). Division (/)"),
			
			Question(question: ["What arithmetic operator is supported for String concatenation?",
								"This arithmetic operator can be used to concatenate string values",
								"Concatenation of string values can be done through this arithmetic operator"],
					 image: "",
					 optionA: "Addition operator",
					 optionB: "Multiplication operator",
					 optionC: "Assignment operator",
					 optionD: "",
					 questionId: 113,
					 helpText: "The addition operator is supported for String concatenation."),
			
			Question(question: ["Does Swift arithmetic operators allow values to overflow by default?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 11300,
					 helpText: "Unlike the arithmetic operators in C and Objective-C, the Swift arithmetic operators don’t allow values to overflow by default. You can opt in to value overflow behavior by using Swift’s overflow operators (such as a &+ b). See Overflow Operators."),
			
			Question(question: ["Which operator show how many multiples of a will fit inside b?",
								"Which operator show how many multiples of c will fit inside d and returns the value that is left over?",
								"Which operator show how many multiples of b will fit inside a and returns the remainder?"],
					 image: "",
					 optionA: "Remainder operator",
					 optionB: "Assignment operator",
					 optionC: "Identical to operator",
					 optionD: "",
					 questionId: 114,
					 helpText: "The remainder operator (a % b) works out how many multiples of b will fit inside a and returns the value that is left over (known as the remainder). The remainder operator (%) is also known as a modulo operator in other languages. However, its behavior in Swift for negative numbers means that, strictly speaking, it’s a remainder rather than a modulo operation."),
			
			Question(question: ["What remainder will be in 9 % 4 expression?"],
					 image: "",
					 optionA: "1",
					 optionB: "2",
					 optionC: "3",
					 optionD: "4",
					 questionId: 115,
					 helpText: "Here’s how the remainder operator works. To calculate 9 % 4, you first work out how many 4s will fit inside 9 (You can fit two 4s inside 9, and the remainder is 1). In Swift, this would be written as: 9 % 4. To determine the answer for a % b, the % operator calculates the following equation and returns remainder as its output: a = (b x some multiplier) + remainder, where some multiplier is the largest number of multiples of b that will fit inside a. Inserting 9 and 4 into this equation yields: 9 = (4 x 2) + 1"),
			
			Question(question: ["What remainder will be in -9 % 4 expression?"],
					 image: "",
					 optionA: "-1",
					 optionB: "1",
					 optionC: "2",
					 optionD: "-2",
					 questionId: 116,
					 helpText: "We will get: -9 = (4 × -2) + -1, so the remainder will be -1."),
			
			Question(question: ["What remainder will be in 9 % -4 expression?"],
					 image: "",
					 optionA: "1",
					 optionB: "2",
					 optionC: "4",
					 optionD: "8",
					 questionId: 117,
					 helpText: "The sign of b is ignored for negative values of b. This means that a % b and a % -b always give the same answer."),
			
			Question(question: ["How to add unary minus operator correctly?"],
					 image: "",
					 optionA: "-1",
					 optionB: "- 2",
					 optionC: "8 -",
					 optionD: "",
					 questionId: 118,
					 helpText: "The sign of a numeric value can be toggled using a prefixed -, known as the unary minus operator. The unary minus operator (-) is prepended directly before the value it operates on, without any white space."),
			
			Question(question: ["What is the name of the operator in this expression: a += 2?",
								"What is the name of this operator: c += 11?",
								"apples += 55, what is this operator called?"],
					 image: "",
					 optionA: "Compound assignment operator",
					 optionB: "Assignment operator",
					 optionC: "Compound addition operator",
					 optionD: "Plus - equal operator",
					 questionId: 119,
					 helpText: "Like C, Swift provides compound assignment operators that combine assignment (=) with another operation. One example is the addition assignment operator (+=): var a = 1, a += 2 // a is now equal to 3. The expression a += 2 is shorthand for a = a + 2. Effectively, the addition and the assignment are combined into one operator that performs both tasks at the same time. The compound assignment operators don’t return a value. For example, you can’t write let b = a += 2."),
			
			Question(question: ["Does the unary plus operator (+) change the original value?",
								"Does the unary plus operator change the original value?",
								"Does the original value changed when we are using the unary plus operator?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "- become +",
					 optionD: "",
					 questionId: 120,
					 helpText: "The unary plus operator (+) simply returns the value it operates on, without any change. Although the unary plus operator doesn’t actually do anything, you can use it to provide symmetry in your code for positive numbers when also using the unary minus operator for negative numbers."),
			
			Question(question: ["How many comparison operators does Swift support?",
								"How many comparison operators are there in Swift?",
								"How many comparison operators are supported in Swift?"],
					 image: "",
					 optionA: "Six",
					 optionB: "Eight",
					 optionC: "Four",
					 optionD: "",
					 questionId: 121,
					 helpText: "Swift supports the following comparison operators: Equal to (a == b). Not equal to (a != b). Greater than (a > b). Less than (a < b). Greater than or equal to (a >= b). Less than or equal to (a <= b)"),
			
			Question(question: ["What value will be assigned to the constant anotherMinusOne?",
								"The constant anotherMinusOne will be assigned with this value"],
					 image: "BasicOperators22",
					 optionA: "-1",
					 optionB: "1",
					 optionC: "-2",
					 optionD: "2",
					 questionId: 122,
					 helpText: "Correct answer: -1. The unary plus operator (+) simply returns the value it operates on, without any change. Although the unary plus operator doesn’t actually do anything, you can use it to provide symmetry in your code for positive numbers when also using the unary minus operator for negative numbers."),
			
			Question(question: ["How do you spell the comparison operator equal to?"],
					 image: "",
					 optionA: "==",
					 optionB: "=",
					 optionC: "===",
					 optionD: "!=",
					 questionId: 123,
					 helpText: "The comparison operator equal to is: a == b."),
			
			Question(question: ["How is the greater than or equal comparison operator spelled?"],
					 image: "",
					 optionA: ">=",
					 optionB: "<=",
					 optionC: "=>",
					 optionD: "=<",
					 questionId: 124,
					 helpText: "Greater than or equal to: a >= b"),
			
			Question(question: ["How is the identity operator spelled?"],
					 image: "",
					 optionA: "===",
					 optionB: "==",
					 optionC: "=",
					 optionD: "!==",
					 questionId: 125,
					 helpText: "Swift also provides two identity operators (=== and !==), which you use to test whether two object references both refer to the same object instance."),
			
			Question(question: ["What do comparison operators return?",
								"What is the result of expressions using any comparison operator?"],
					 image: "",
					 optionA: "Bool",
					 optionB: "Int",
					 optionC: "Double",
					 optionD: "nil",
					 questionId: 126,
					 helpText: "Each of the comparison operators returns a Bool value to indicate whether or not the statement is true. For example: 1 == 1 // true, since 1 is 1, 2! = 1 // true, because 2 is not equal to 1, 2 > 1 // true, because 2 is greater than 1, etc. Comparison operators are often used in conditional expressions, including the if statement."),
			
			Question(question: ["The syntax for this operator is: expression? Action1 : Action2?",
								"Which operator is this: question? Answer1 : Answer2?",
								"Which operator syntax looks like this: (a? b: c)?"],
					 image: "",
					 optionA: "Ternary conditional operator",
					 optionB: "Binary conditional operator",
					 optionC: "Assignment operator",
					 optionD: "Unary prefix operator",
					 questionId: 127,
					 helpText: "The ternary conditional operator is a special operator with three parts, which takes the form question ? answer1 : answer2. It’s a shortcut for evaluating one of two expressions based on whether question is true or false. If question is true, it evaluates answer1 and returns its value; otherwise, it evaluates answer2 and returns its value."),
			
			Question(question: ["Can two tuples of type (String, Int) be compared with each other?",
								"You have two tuples of type (String, Int). Can you compare them?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "Only  != or ==",
					 optionC: "Only < or >",
					 optionD: "No",
					 questionId: 128,
					 helpText: "You can compare two tuples if they have the same type and the same number of values. Tuples are compared from left to right, one value at a time, until the comparison finds two values that aren’t equal. Those two values are compared, and the result of that comparison determines the overall result of the tuple comparison. If all the elements are equal, then the tuples themselves are equal. Tuples can be compared with a given operator only if the operator can be applied to each value in the respective tuples."),
			
			Question(question: ["Can two tuples of type (String, Bool) be compared with each other?",
								"You have two tuples of type (String, Bool). Can you compare them?"],
					 image: "",
					 optionA: "No",
					 optionB: "Only != or ==",
					 optionC: "Yes",
					 optionD: "",
					 questionId: 129,
					 helpText: "Tuples can be compared with a given operator only if the operator can be applied to each value in the respective tuples. You can compare two tuples of type (String, Int) because both String and Int values can be compared using the < operator. In contrast, two tuples of type (String, Bool) can’t be compared with the < operator because the < operator can’t be applied to Bool values."),
			
			Question(question: ["The Swift standard library includes tuple comparison operators for tuples with fewer than seven elements. Is that true?",
								"To compare tuples with seven or more elements, you must implement the comparison operators yourself. Is that true?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 12900,
					 helpText: "The Swift standard library includes tuple comparison operators for tuples with fewer than seven elements. To compare tuples with seven or more elements, you must implement the comparison operators yourself."),
			
			Question(question: ["This operator unwraps the optional a or returns the default b if a = nil",
								"The operator that unwraps the optional a if it contains a value?",
								"Which operator returns the default value when the variable is nil?"],
					 image: "",
					 optionA: "The nil-coalescing operator",
					 optionB: "Identical to operator",
					 optionC: "Optional chaining operator",
					 optionD: "",
					 questionId: 130,
					 helpText: "The nil-coalescing operator (a ?? b) unwraps an optional a if it contains a value, or returns a default value b if a is nil. The expression a is always of an optional type. The expression b must match the type that is stored inside a."),
			
			/// Если что я поменял в 131 картинку на исходную. Я тогда выпендрился и все названия переписал для себя, а тут не хочется заморачиваться и переписывать хелп
			
			Question(question: ["What value will be assigned to the colorToUse constant?",
								"What value will colorToUse get?"],
					 image: "BasicOperators31",
					 optionA: "red",
					 optionB: "Value of userDefinedColorName",
					 optionC: "We will get an error",
					 optionD: "nil",
					 questionId: 131,
					 helpText: "The userDefinedColorName variable is defined as an optional String, with a default value of nil. Because userDefinedColorName is of an optional type, you can use the nil-coalescing operator to consider its value. In the example above, the operator is used to determine an initial value for a String variable called colorNameToUse. Because userDefinedColorName is nil, the expression userDefinedColorName ?? defaultColorName returns the value of defaultColorName, or \"red\". If you assign a non-nil value to userDefinedColorName and perform the nil-coalescing operator check again, the value wrapped inside userDefinedColorName is used instead of the default."),
			
			Question(question: ["What value will be assigned to the constant test if we pass compilation?",
								"If the constant test is assigned a value, what will it be?",
								"What value will the test constant get?"],
					 image: "BasicOperators32",
					 optionA: "К",
					 optionB: "nil",
					 optionC: "We will get an error",
					 optionD: "",
					 questionId: 132,
					 helpText: "The nil-coalescing operator (a ?? b) unwraps an optional a if it contains a value, or returns a default value b if a is nil. The expression a is always of an optional type. The expression b must match the type that is stored inside a. In this example, the variable character, with an implicit type declaration, is assigned the type String by default, which means the types are equal and the constant test will be assigned the value K."),
			
			Question(question: ["What range operators are there in Swift?",
								"Operators for these ranges are supported in Swift",
								"Swift supports these range operators"],
					 image: "",
					 optionA: "Closed and Half-Open Range Operator",
					 optionB: "Multithreading and Singlethreading",
					 optionC: "One-Sided Range Operator",
					 optionD: "",
					 questionId: 133,
					 helpText: "Swift includes several range operators, which are shortcuts for expressing a range of values: Closed Range Operator, Half-Open Range Operator."),
			
			Question(question: ["The operator of this range specifies a range from a to b, including a and b themselves",
								"What range operator specifies a value from a to b, including a and b themselves?"],
					 image: "",
					 optionA: "Closed range operator",
					 optionB: "Half-Open range operator",
					 optionC: "Open range operator",
					 optionD: "",
					 questionId: 134,
					 helpText: "The closed range operator (a...b) defines a range that runs from a to b, and includes the values a and b. The value of a must not be greater than b. The closed range operator is useful when iterating over a range in which you want all of the values to be used, such as with a for-in loop."),
			
			Question(question: ["This range operator specifies a range from a to b, but doesn’t include b",
								"Which range operator specifies a value from a to b, but doesn’t include b?"],
					 image: "",
					 optionA: "Half-Open range operator",
					 optionB: "Closed range operator",
					 optionC: "One-Sided range operator",
					 optionD: "",
					 questionId: 135,
					 helpText: "The half-open range operator (a..<b) defines a range that runs from a to b, but doesn’t include b. It’s said to be half-open because it contains its first value, but not its final value. As with the closed range operator, the value of a must not be greater than b. If the value of a is equal to b, then the resulting range will be empty. Half-open ranges are particularly useful when you work with zero-based lists such as arrays, where it’s useful to count up to (but not including) the length of the list."),
			
			Question(question: ["A range that extends as far as possible, but only in one direction?",
								"A range that continues as far as possible, but only one way?",
								"A range that includes all elements of the array from 2 to the last index?"],
					 image: "",
					 optionA: "One-Sided Range",
					 optionB: "Open",
					 optionC: "Endless",
					 optionD: "",
					 questionId: 136,
					 helpText: "The closed range operator has an alternative form for ranges that continue as far as possible in one direction—for example, a range that includes all the elements of an array from index 2 to the end of the array. In these cases, you can omit the value from one side of the range operator. This kind of range is called a one-sided range because the operator has a value on only one side."),
			
			Question(question: ["Does the closed range operator has a one-sided form?",
								"Does the half-open range operator has a one-sided form?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 13600,
					 helpText: "The closed range operator has an alternative form for ranges that continue as far as possible in one direction—for example, a range that includes all the elements of an array from index 2 to the end of the array. In these cases, you can omit the value from one side of the range operator. This kind of range is called a one-sided range because the operator has a value on only one side. The half-open range operator also has a one-sided form that’s written with only its final value. Just like when you include a value on both sides, the final value isn’t part of the range."),
			
			Question(question: ["How many standard Logical operators does Swift support?",
								"Swift supports exactly as many standard Logical operators",
								"Number of Logical Operators Supported by Swift"],
					 image: "",
					 optionA: "3",
					 optionB: "4",
					 optionC: "2",
					 optionD: "",
					 questionId: 137,
					 helpText: "Logical operators modify or combine the Boolean logic values true and false. Swift supports the three standard logical operators found in C-based languages: Logical NOT (!a), Logical AND (a && b), Logical OR (a || b)"),
			
			Question(question: ["Which logical operator inverts the boolean value - true becomes false and false becomes true?",
								"A logical operator that inverts a boolean value (true becomes false)?",
								"It is this prefix logical operator that inverts the boolean value"],
					 image: "",
					 optionA: "!",
					 optionB: "&&",
					 optionC: "||",
					 optionD: "",
					 questionId: 138,
					 helpText: "The logical NOT operator (!a) inverts a Boolean value so that true becomes false, and false becomes true. The logical NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space. The phrase if !allowedEntry can be read as “if not allowed entry.” The subsequent line is only executed if “not allowed entry” is true; that is, if allowedEntry is false. As in this example, careful choice of Boolean constant and variable names can help to keep code readable and concise, while avoiding double negatives or confusing logic statements."),
			
			/// Чуть приподнял вопрос, там два похожих снизу шли подряд
			/// Он самописный, чекни его пожалуйста под микроскопом
			
			Question (question: ["Which operator will return true when comparing if the objects refer to the same place in memory?"],
					  image: "",
					  optionA: "===",
					  optionB: "==",
					  optionC: "=",
					  optionD: "&&",
					  questionId: 145,
					  helpText: "Swift's identity check operator (===) returns true if variables refer to the same memory location."),
			
			Question(question: ["What logical operator outputs true if and only if both of its operands are true?",
								"If at least one operand of this logical operator is false, the whole expression will be false",
								"Only when both operands are true this logical operator return true"],
					 image: "",
					 optionA: "&&",
					 optionB: "||",
					 optionC: "!",
					 optionD: "",
					 questionId: 139,
					 helpText: "The logical AND operator (a && b) creates logical expressions where both values must be true for the overall expression to also be true.If either value is false, the overall expression will also be false. In fact, if the first value is false, the second value won’t even be evaluated, because it can’t possibly make the overall expression equate to true. This is known as short-circuit evaluation."),
			
			Question(question: ["If the first operand is false when using logical AND (&&), will the second value be evaluated?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 140,
					 helpText: "When using logical AND, if the first value is false, the second value won’t even be evaluated, because it can’t possibly make the overall expression equate to true. This is known as short-circuit evaluation."),
			
			Question(question: ["How many logical operators are infix?"],
					 image: "",
					 optionA: "2",
					 optionB: "1",
					 optionC: "3",
					 optionD: "All of them",
					 questionId: 141,
					 helpText: "Two logical operators are infix: && (AND) and || (OR)."),
			
			Question(question: ["Using this operator, you can create logical expressions that will return true if at least one of the operands is true",
								"If at least one of the operands = true, the whole expression will be true",
								"This boolean operator will return true when at least one operand is true"],
					 image: "",
					 optionA: "|| (OR)",
					 optionB: "! (NOT)",
					 optionC: "&& (AND)",
					 optionD: "",
					 questionId: 142,
					 helpText: "The logical OR operator (a || b) is an infix operator made from two adjacent pipe characters. You use it to create logical expressions in which only one of the two values has to be true for the overall expression to be true."),
			
			Question(question: ["If the left side of the logical OR expression is true, will the right side be evaluated?",
								"The left side of the expression with the boolean operator || is true, will we evaluate the second side?",
								"Will the second part of the expression be evaluated if the logical OR is true in the first part?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 143,
					 helpText: "Like the Logical AND operator above, the Logical OR operator uses short-circuit evaluation to consider its expressions. If the left side of a Logical OR expression is true, the right side is not evaluated, because it can’t change the outcome of the overall expression."),
			
			/// Ниже совсем самописное
			
			Question(question: ["What will print (red1 === red2) return when let red1 = UIColor.red, let red2 = UIColor.red?",
								"let green1 = UIColor.green, let green2 = UIColor.green, what will print (green1 === green2) return?",
								"If two variables refer to the same color UIColor.blue, what will the comparison return for being identical (===)?"],
					 image: "",
					 optionA: "true",
					 optionB: "false",
					 optionC: "Color name",
					 optionD: "",
					 questionId: 144,
					 helpText: "When we initialize several variables through a reference to the same UIColor.color, all the variables become references to the same color instance, that is, they are identical."),
			
			Question(question: ["What number do we get after running this code?"],
					 image: "BasicOperators47",
					 optionA: "6",
					 optionB: "8",
					 optionC: "9",
					 optionD: "",
					 questionId: 147,
					 helpText: "Correct answer: 6. Despite the confusing spaces, Swift has well-defined operator precedence. In the task, the execution order is as follows: 1 + (2 * number) - 1"),
			
			Question(question: ["What number do we get after running this code?"],
					 image: "BasicOperators46",
					 optionA: "true",
					 optionB: "false",
					 optionC: ".red",
					 optionD: "",
					 questionId: 146,
					 helpText: "True will be printed to the console. UIColor.red does not create a new object every time, but always returns the same one, so the comparison operator for identity returns true (variables refer to the same place in memory)."),
			
			Question(question: ["What kind of range the constant low has?"],
					 image: "BasicOperators48",
					 optionA: "One-Sided",
					 optionB: "Two-Sided",
					 optionC: "Halp-Open",
					 optionD: "Close",
					 questionId: 148,
					 helpText: "Swift incorporates a lot of other programming languages. This also happened with one-sided ranges, which have long been used in development, for example, in Python. In this form of ranges, only one of the boundaries is indicated, while the other is determined automatically.")
		]
	}
	
	
	///
	
	
	static func getDemoQuestions() -> [Question] {
		return [
			Question(question: ["Минимальная автономная единица, выполняющая команду",
								"Автономная единица, выполняющая команду",
								"Эта минимальная автономная единица способна выполнить команду"],
					 image: "",
					 optionA: "Оператор",
					 optionB: "Операнд",
					 optionC: "Переменная",
					 optionD: "Функция",
					 questionId: 101,
					 helpText: "Оператор — минимальная автономная единица, выполняющая команду. Операторы могут быть простыми (унарными, бинарными) и структурными (тернарными)."),
			
			Question(question: ["Значение, которое операторы затрагивают в своей работе",
								"Операторы выполняют команды с этим значением",
								"В своей работе операторы затрагивают именно это"],
					 image: "",
					 optionA: "Операнд",
					 optionB: "Оператор",
					 optionC: "Значение",
					 optionD: "",
					 questionId: 102,
					 helpText: "Величины, к которым применяются операторы, называются операндами. В выражении “1 + 2” символ “+” является бинарным оператором, а его операндами служат 1 и 2."),
			
			Question(question: ["Операторы, которые применяются к одной величине",
								"Эти операторы применяются к одной величине",
								"Именно эти операторы можно применять только к одной величине"],
					 image: "",
					 optionA: "Унарные",
					 optionB: "Бинарные",
					 optionC: "Тернарные",
					 optionD: "",
					 questionId: 103,
					 helpText: "Унарные операторы применяются к одной величине (например, -a). Унарные префиксные операторы ставятся непосредственно перед величиной (например, !b), а унарные постфиксные операторы — сразу за ней (например, c!)."),
			
			Question(question: ["Унарные операторы, которые ставятся непосредственно перед величиной",
								"Эти унарные операторы ставятся перед величиной",
								"Непосредственно перед величиной ставятся именно эти унарные операторы"],
					 image: "",
					 optionA: "Префиксные",
					 optionB: "Постфиксные",
					 optionC: "Инфиксные",
					 optionD: "",
					 questionId: 104,
					 helpText: "Унарные префиксные операторы ставятся непосредственно перед величиной (например, !b)."),
			
			Question(question: ["Унарные операторы, которые ставятся сразу за величиной",
								"Эти унарные операторы ставятся за величиной",
								"Сразу за величиной ставятся именно эти унарные операторы"],
					 image: "",
					 optionA: "Постфиксные",
					 optionB: "Инфиксные",
					 optionC: "Префиксные",
					 optionD: "",
					 questionId: 105,
					 helpText: "Унарные постфиксные операторы ставятся сразу за величиной (например, c!)."),
			
			Question(question: ["Операторы, которые применяются к двум величинам",
								"Эти операторы применяются к двум величинам",
								"Как называются операторы, которые применяются к двум величинам?"],
					 image: "",
					 optionA: "Бинарные",
					 optionB: "Тернарные",
					 optionC: "Унарные",
					 optionD: "",
					 questionId: 106,
					 helpText: "Бинарные операторы применяются к двум величинам (например, 2 + 3) и являются инфиксными, так как ставятся между этими величинами."),
			
			Question(question: ["Операторы, применяемые к трем величинам",
								"К трем величинам применяются эти операторы",
								"Как называются операторы, применяемые к трем величинам?"],
					 image: "",
					 optionA: "Тернарные",
					 optionB: "Бинарные",
					 optionC: "Унарные",
					 optionD: "",
					 questionId: 107,
					 helpText: "Тернарные операторы применяются к трем величинам. Как и в языке C, в Swift есть только один такой оператор, а именно — тернарный условный оператор (a ? b : c)."),
			
			Question(question: ["Какой из этих операторов называется оператором присваивания?",
								"Как пишется оператор присваивания?",
								"Выберите среди вариантов оператор присваивания"],
					 image: "",
					 optionA: "=",
					 optionB: "==",
					 optionC: "!=",
					 optionD: "===",
					 questionId: 108,
					 helpText: "Оператор присваивания (a = b) инициализирует или изменяет значение переменной a на значение b."),
			
			Question(question: ["Какой оператор инициализирует или изменяет значение переменной?",
								"Этот оператор инициализирует или изменяет значение переменной a на значение b",
								"Какой оператор присваивает значение переменной a значению переменной b?"],
					 image: "",
					 optionA: "=",
					 optionB: "==",
					 optionC: "!=",
					 optionD: "===",
					 questionId: 109,
					 helpText: "Оператор присваивания (a = b) инициализирует или изменяет значение переменной a на значение b. Если левая часть выражения является кортежем с несколькими значениями, его элементам можно присвоить сразу несколько констант или переменных."),
			
			Question(question: ["Если левая часть выражения является кортежем с несколькими значениями, можем ли мы присвоить сразу несколько констант или переменных его значениям?",
								"Левая часть выражения, это кортеж, можем ли мы присвоить несколько констант или переменных всем его значениям",
								"Можем ли мы сразу присвоить несколько констант или переменных значениям кортежа?"],
					 image: "",
					 optionA: "Можем, через запятую: (x, y) = (1, 2)",
					 optionB: "Можем, через точку с запятой",
					 optionC: "Нет, не можем",
					 optionD: "Можем, через слеш: (x, y) = 1 / 2",
					 questionId: 110,
					 helpText: "Если левая часть выражения является кортежем с несколькими значениями, его элементам можно присвоить сразу несколько констант или переменных. let (x, y) = (1, 2), где x равно 1, а y равно 2."),
			
			Question(question: ["Может ли оператор присваивания в Swift возвращать значение?",
								"Оператор присваивания может возвращать значение?"],
					 image: "",
					 optionA: "Нет",
					 optionB: "Да",
					 optionC: "Только Bool",
					 optionD: "Только Int",
					 questionId: 111,
					 helpText: "В отличие от C и Objective-C оператор присваивания в Swift не может возвращать значение. Эта особенность не позволяет разработчику спутать оператор присваивания (=) с оператором проверки на равенство (==). Благодаря тому, что выражения типа if x = y некорректны, подобные ошибки при программировании на Swift не произойдут."),
			
			Question(question: ["Сколько стандартных арифметических операторов поддерживает Swift?",
								"Количество арифметических операторов, поддерживаемых в Swift?",
								"Swift поддерживает именно столько арифметических операторов"],
					 image: "",
					 optionA: "4",
					 optionB: "3",
					 optionC: "5",
					 optionD: "2",
					 questionId: 112,
					 helpText: "Язык Swift поддерживает четыре стандартных арифметических оператора для всех числовых типов: сложение (+), вычитание (-), умножение (*), деление (/)."),
			
			Question(question: ["Какой арифметический оператор служит для конкатенации строковых значений?",
								"Для конкатенации строковых значений служит этот арифметический оператор",
								"Конкатенация строковых значений выполняется через этот арифметический оператор"],
					 image: "",
					 optionA: "Оператор сложения",
					 optionB: "Оператор деления",
					 optionC: "Оператор умножения",
					 optionD: "",
					 questionId: 113,
					 helpText: "Оператор сложения (+) служит для конкатенации или же склейки, строковых значений (тип String)."),
			
			Question(question: ["Какой оператор показывает какое количество b помещается внутри a?",
								"Оператор, который показывает какое количество b помещается внутри c",
								"Оператор, который возвращает остаток деления a на b"],
					 image: "",
					 optionA: "Целочисленного деления",
					 optionB: "Присваивания",
					 optionC: "Отображения",
					 optionD: "Сложения",
					 questionId: 114,
					 helpText: "Оператор целочисленного деления (a % b) показывает какое количество b помещается внутри a, и возвращает остаток деления a на b. Оператор целочисленного деления (%) в некоторых языках называется оператором деления по модулю. Однако учитывая его действие над отрицательными числами в Swift, этот оператор, строго говоря, выполняет деление с остатком, а не по модулю."),
			
			Question(question: ["Какой результат будет в данном выражении 9 % 4?",
								"Какой остаток будет в выражении 9 % 4?"],
					 image: "",
					 optionA: "1",
					 optionB: "2",
					 optionC: "3",
					 optionD: "4",
					 questionId: 115,
					 helpText: "В одной девятке содержатся две четверки, а остатком будет 1. Чтобы получить результат деления a % b, оператор % вычисляет следующее выражение и возвращает остаток: a = (b × множитель) + остаток, где множитель показывает, сколько раз целых b содержится в a. Подставляя в это выражение 9 и 4, получим: 9 = (4 × 2) + 1"),
			
			Question(question: ["Какой результат будет в выражении -9 % 4?",
								"Какой остаток будет в данном выражении -9 % 4?"],
					 image: "",
					 optionA: "-1",
					 optionB: "1",
					 optionC: "2",
					 optionD: "-2",
					 questionId: 116,
					 helpText: "Получаем: -9 = (4 × -2) + -1. Остаток будет равен -1."),
			
			Question(question: ["Какой результат будет в выражении 9 % -4?",
								"9 % -4 какой будет остаток?"],
					 image: "",
					 optionA: "1",
					 optionB: "2",
					 optionC: "4",
					 optionD: "8",
					 questionId: 117,
					 helpText: "Если b отрицательно, его знак отбрасывается. Это означает, что выражения a % b и a % -b всегда будут давать одинаковый результат."),
			
			Question(question: ["Как правильно поставить оператор унарного префиксного минуса?",
								"Где правильно используется оператор префиксного минуса?",
								"Выберите вариант, где корректно используется оператор префиксного минуса"],
					 image: "",
					 optionA: "-1",
					 optionB: "- 2",
					 optionC: "8 -",
					 optionD: "",
					 questionId: 118,
					 helpText: "Для изменения знака числового значения служит префиксный минус -, который называется оператором унарного минуса. Оператор унарного минуса (-) ставится непосредственно перед значением без пробела."),
			
			Question(question: ["Как называется оператор в этом выражении: a += 2?",
								"Как называется этот оператор: c += 11?",
								"apples += 55, как называется подобный оператор?"],
					 image: "",
					 optionA: "Присваивания со сложением",
					 optionB: "Присваивания",
					 optionC: "Составного сложения",
					 optionD: "Сложения",
					 questionId: 119,
					 helpText: "Как и в языке C, в Swift имеются составные операторы присваивания, совмещающие простое присваивание (=) с другой операцией. Одним из примеров может служить оператор присваивания со сложением (+=): var a = 1, a += 2 // теперь a равно 3. Выражение a += 2 является краткой формой записи a = a + 2. Таким образом, один и тот же оператор выполняет одновременно операцию сложения и присваивания. Составные операторы присваивания не возвращают значение. К примеру, нельзя написать так: let b = a += 2."),
			
			Question(question: ["Оператор унарного плюса (+) изменяет исходное значение?",
								"Изменяет ли оператор унарного плюса исходное значение?",
								"Изменяется ли исходное значение при использовании оператора унарного плюса?"],
					 image: "",
					 optionA: "Нет",
					 optionB: "Да",
					 optionC: "- становится +",
					 optionD: "",
					 questionId: 120,
					 helpText: "Оператор унарного плюса (+) просто возвращает исходное значение без каких-либо изменений. Хотя оператор унарного плюса не выполняет никаких действий, он придает коду единообразие, позволяя зрительно отличать положительные значения от отрицательных."),
			
			Question(question: ["Сколько операторов сравнения поддерживает Swift?",
								"Сколько в Swift операторов сравнения?",
								"Сколько операторов сравнения поддерживается в Swift?"],
					 image: "",
					 optionA: "Шесть",
					 optionB: "Восемь",
					 optionC: "Четыре",
					 optionD: "Два",
					 questionId: 121,
					 helpText: "Язык Swift поддерживает все стандартные операторы сравнения из C: равно (a == b), не равно (a != b), больше (a > b), меньше (a < b), больше или равно (a >= b), меньше или равно (a <= b). Всего их шесть."),
			
			Question(question: ["Какое значение будет присвоено константе anotherMinusOne?",
								"Константе anotherMinusOne присвоится именно это значение"],
					 image: "BasicOperators22",
					 optionA: "-1",
					 optionB: "1",
					 optionC: "-2",
					 optionD: "2",
					 questionId: 122,
					 helpText: "Оператор унарного плюса (+) просто возвращает исходное значение без каких-либо изменений. Хотя оператор унарного плюса не выполняет никаких действий, он придает коду единообразие, позволяя зрительно отличать положительные значения от отрицательных."),
			
			Question(question: ["Как пишется оператор сравнения равно?",
								"Выберите оператор сравнения равно",
								"Какой из этих операторов является оператором сравнения равно?"],
					 image: "",
					 optionA: "==",
					 optionB: "=",
					 optionC: "===",
					 optionD: "!=",
					 questionId: 123,
					 helpText: "Оператор сравнения равно (a == b)."),
			
			Question(question: ["Как пишется оператор сравнения “больше или равно”?",
								"Выберите оператор сравнения “больше или равно”",
								"Какой из этих операторов называется “больше или равно”?"],
					 image: "",
					 optionA: ">=",
					 optionB: "<=",
					 optionC: "=>",
					 optionD: "=<",
					 questionId: 124,
					 helpText: "Оператор сравнения больше или равно (a >= b)."),
			
			Question(question: ["Как пишется оператор проверки на идентичность/тождественность?",
								"Выберите оператор проверки на идентичность или тождественность",
								"Оператор проверки на идентичность/тождественность"],
					 image: "",
					 optionA: "===",
					 optionB: "==",
					 optionC: "=",
					 optionD: "!==",
					 questionId: 125,
					 helpText: "В языке Swift есть также два оператора проверки на идентичность/тождественность (=== и !==), определяющие, ссылаются ли два указателя на один и тот же экземпляр объекта."),
			
			Question(question: ["Что возвращают выражения с использованием операторов сравнения?",
								"Какой результат у выражений с использованием любого оператора сравнения?",
								"При использовании операторов сравнения какой мы получим результат?"],
					 image: "",
					 optionA: "Bool",
					 optionB: "Int",
					 optionC: "Double",
					 optionD: "nil",
					 questionId: 126,
					 helpText: "Каждый оператор сравнения возвращает значение типа Bool, указывающее, является ли выражение истинным: 1 == 1 // истина, так как 1 равно 1, 2 != 1 // истина, так как 2 не равно 1, 2 > 1 // истина, так как 2 больше чем 1 и т.д. Операторы сравнения часто используются в условных выражениях, включая инструкцию if."),
			
			Question(question: ["Синтаксис этого оператора выглядит следующим образом: выражение ? действие1 : действие2?",
								"Какой это оператор: question ? answer1 : answer2?",
								"Синтаксис какого оператора выглядит следующим образом: (a ? b : c)?"],
					 image: "",
					 optionA: "Тернарный условный оператор",
					 optionB: "Бинарный условный оператор",
					 optionC: "Оператор присваивания",
					 optionD: "Унарный оператор",
					 questionId: 127,
					 helpText: "Тернарный условный оператор — это специальный оператор из трех частей, имеющий следующий синтаксис: выражение ? действие1 : действие2. Он выполняет одно из двух действий в зависимости от того, является ли выражение true или false. Если выражение равно true, оператор выполняет действие №1 и возвращает его результат; в противном случае оператор выполняет действие №2 и возвращает его результат."),
			
			Question(question: ["Можно ли сравнивать между собой два кортежа с типом (String, Int)?",
								"У вас есть два кортежа с типом (String, Int), можно ли их сравнить?"],
					 image: "",
					 optionA: "Да",
					 optionB: "Только != или ==",
					 optionC: "Только < или >",
					 optionD: "Нет",
					 questionId: 128,
					 helpText: "Вы можете сравнивать кортежи, которые имеют одно и то же количество значений, которые, в свою очередь, должны быть сравниваемыми, что означает, что кортеж типа (Int, String) может быть сравнен с кортежем такого же типа. Кортежи сравниваются слева направо по одному значению за раз до тех пор, пока операция сравнения не найдет отличия между значениями. Если все значения кортежей попарно равны, то и кортежи так же считаются равными. Кортежи могут сравниваться, только в том случае, если оператор сравнения можно применить ко всем членам кортежей соответственно."),
			
			Question(question: ["Можно ли сравнивать между собой два кортежа с типом (String, Bool)?",
								"У вас есть два кортежа с типом (String, Bool), можно ли их сравнить?"],
					 image: "",
					 optionA: "Нет",
					 optionB: "Только != или ==",
					 optionC: "Да",
					 optionD: "Только < или >",
					 questionId: 129,
					 helpText: "Кортежи могут сравниваться только в том случае, если оператор сравнения можно применить ко всем членам кортежей соответственно. Например, вы можете сравнить два кортежа типа (String, Int) потому что и String, и Int могут сравниваться операторами сравнения. Кортеж типа (String, Bool) сравниваться не может, так как к значениям типа Bool операторы сравнения не применяются."),
			
			Question(question: ["Этот оператор извлекает опционал a или возвращает значение по умолчанию b, если a = nil",
								"Оператор, который извлекает опционал а, если он содержит значение?",
								"Какой оператор возвращает значение по умолчанию, если переменная равна nil?"],
					 image: "",
					 optionA: "Объединения по nil",
					 optionB: "Проверки на идентичность",
					 optionC: "Опционального сравнения",
					 optionD: "Проверки на nil",
					 questionId: 130,
					 helpText: "Оператор объединения по nil (a ?? b) извлекает опционал a, если он содержит значение или возвращает значение по умолчанию b, если a равно nil. Выражение a может быть только опционалом. Выражение b должно быть такого же типа, что и значение внутри a."),
		]
	}
}
