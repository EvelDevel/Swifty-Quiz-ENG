
//  Created by Евгений Никитин on 12.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

// MARK: 26 - Вопросы (id) с 2451 по 2500

class AdvancedOperatorsSet {
	static func getQuestions() -> [Question] {
		return [
			Question(question: ["How is arithmetic operator overflow reported in Swift?",
								"How the overflow behavior of arithmetic operators is trapped and reported in Swift?"],
					 image: "",
					 optionA: "As an error",
					 optionB: "It is not reported",
					 optionC: "As a warning",
					 optionD: "",
					 questionId: 2451,
					 helpText: "Unlike arithmetic operators in C, arithmetic operators in Swift do not overflow by default. Overflow behavior is trapped and reported as an error."),
			
			Question(question: ["Which sign should the overflow operator start with in Swift?",
								"Overflow operators in Swift begins with that sign"],
					 image: "",
					 optionA: "&",
					 optionB: "^",
					 optionC: "$",
					 optionD: "#",
					 questionId: 2452,
					 helpText: "Unlike arithmetic operators in C, arithmetic operators in Swift do not overflow by default. Overflow behavior is trapped and reported as an error. To opt in to overflow behavior, use Swift’s second set of arithmetic operators that overflow by default, such as the overflow addition operator (&+). All of these overflow operators begin with an ampersand (&)."),
			
			Question(question: ["Can we create our own tailored implementations of the standard Swift operators?",
								"Can you provide your own tailored implementations of the standard Swift operators for your custom types?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 2453,
					 helpText: "When you define your own structures, classes, and enumerations, it can be useful to provide your own implementations of the standard Swift operators for these custom types. Swift makes it easy to provide tailored implementations of these operators and to determine exactly what their behavior should be for each type you create."),
			
			Question(question: ["In Swift you’re not limited to the predefined operators. Is that true?",
								"Can you define your own custom infix, prefix, postfix, and assignment operators?",
								"Can you extend existing types to support the custom operators you define?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 2454,
					 helpText: "You’re not limited to the predefined operators. Swift gives you the freedom to define your own custom infix, prefix, postfix, and assignment operators, with custom precedence and associativity values. These operators can be used and adopted in your code like any of the predefined operators, and you can even extend existing types to support the custom operators you define."),
			
			Question(question: ["Which operators enable you to manipulate the individual raw data bits within a data structure?",
								"Which operators are often used in low - level programming, such as graphics programming?",
								"Which operators are often used in low - level programming, such as device driver creation?"],
					 image: "",
					 optionA: "Bitwise operators",
					 optionB: "Overflow operators",
					 optionC: "Equivalence operators",
					 optionD: "Operator Methods",
					 questionId: 2455,
					 helpText: "Bitwise operators enable you to manipulate the individual raw data bits within a data structure. They are often used in low - level programming, such as graphics programming and device driver creation. Bitwise operators can also be useful when you work with raw data from external sources, such as encoding and decoding data for communication over a custom protocol. Swift supports all of the bitwise operators found in C."),
			
			Question(question: ["Which bitwise operator is this?"],
					 image: "AdvancedOperators6",
					 optionA: "NOT (~)",
					 optionB: "AND (&)",
					 optionC: "OR (|)",
					 optionD: "XOR (^)",
					 questionId: 2456,
					 helpText: "This is the bitwise NOT operator (~). It inverts all bits in a number."),
			
			Question(question: ["The bitwise NOT operator is a ___ operator"],
					 image: "",
					 optionA: "prefix",
					 optionB: "postfix",
					 optionC: "infix",
					 optionD: "",
					 questionId: 2457,
					 helpText: "The bitwise NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space."),
			
			Question(question: ["Which bitwise operator is this?"],
					 image: "AdvancedOperators8",
					 optionA: "AND (&)",
					 optionB: "NOT (~)",
					 optionC: "OR (|)",
					 optionD: "XOR (^)",
					 questionId: 2458,
					 helpText: "The bitwise AND operator (&) combines the bits of two numbers. It returns a new number whose bits are set to 1 only if the bits were equal to 1 in both input numbers. In our example, the first value and the second value both have four middle bits equal to 1. The bitwise AND operator combines them to make the number 00111100, which is equal to an unsigned decimal value of 60."),
			
			Question(question: ["Which bitwise operator is this?"],
					 image: "AdvancedOperators9",
					 optionA: "OR (|)",
					 optionB: "NOT (~)",
					 optionC: "AND (&)",
					 optionD: "XOR (^)",
					 questionId: 2459,
					 helpText: "The bitwise OR operator (|) compares the bits of two numbers. The operator returns a new number whose bits are set to 1 if the bits are equal to 1 in either input number. In the example below, the values of both values have different bits set to 1. The bitwise OR operator combines them to make the number 11111110, which equals an unsigned decimal of 254."),
			
			Question(question: ["Which bitwise operator is this?"],
					 image: "AdvancedOperators10",
					 optionA: "XOR (^)",
					 optionB: "NOT (~)",
					 optionC: "AND (&)",
					 optionD: "OR (|)",
					 questionId: 2460,
					 helpText: "The bitwise XOR operator, or “exclusive OR operator” (^), compares the bits of two numbers. The operator returns a new number whose bits are set to 1 where the input bits are different and are set to 0 where the input bits are the same. In our example, the first value and the second value each have a bit set to 1 in a location that the other does not. The bitwise XOR operator sets both of these bits to 1 in its output value. All of the other bits in firstBits and otherBits match and are set to 0 in the output value."),
			
			Question(question: ["The bitwise left shift operator (<<) and bitwise right shift operator (>>) move all bits in a number to the left or the right by a certain number of places. Is that true?",
								"Bitwise left and right shifts have the effect of multiplying or dividing an integer by a factor of two. Is that true?",
								"Shifting an integer’s bits to the left by one position doubles its value, whereas shifting it to the right by one position halves its value. Is that true?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 2461,
					 helpText: "The bitwise left shift operator (<<) and bitwise right shift operator (>>) move all bits in a number to the left or the right by a certain number of places, according to the rules defined below. Bitwise left and right shifts have the effect of multiplying or dividing an integer by a factor of two. Shifting an integer’s bits to the left by one position doubles its value, whereas shifting it to the right by one position halves its value."),
			
			Question(question: ["How many rules for bit-shifting behavior exist?"],
					 image: "",
					 optionA: "Three",
					 optionB: "Two",
					 optionC: "Four",
					 optionD: "",
					 questionId: 2462,
					 helpText: "The bit-shifting behavior for unsigned integers is as follows: 1. Existing bits are moved to the left or right by the requested number of places. 2. Any bits that are moved beyond the bounds of the integer’s storage are discarded. 3. Zeros are inserted in the spaces left behind after the original bits are moved to the left or right. This approach is known as a logical shift."),
			
			Question(question: ["What happens to the bits that are moved beyond the bounds while bit-shifting?"],
					 image: "",
					 optionA: "Discarded",
					 optionB: "Saved",
					 optionC: "Expand the value",
					 optionD: "",
					 questionId: 2463,
					 helpText: "Any bits that are moved beyond the bounds of the integer’s storage are discarded."),
			
			Question(question: ["What value is inserted at the empty positions of the shifted bits?",
								"These values are inserted into the empty positions of the shifted bits"],
					 image: "",
					 optionA: "0",
					 optionB: "1",
					 optionC: "nil",
					 optionD: "",
					 questionId: 2464,
					 helpText: "Zeros are inserted in the spaces left behind after the original bits are moved to the left or right."),
			
			Question(question: ["What is the name of this shift?"],
					 image: "AdvancedOperators15",
					 optionA: "Logical Shift",
					 optionB: "Left Shift",
					 optionC: "Right Shift",
					 optionD: "Tectonic Shift",
					 questionId: 2465,
					 helpText: "The bit-shifting behavior for unsigned integers is as follows: 1. Existing bits are moved to the left or right by the requested number of places. 2. Any bits that are moved beyond the bounds of the integer’s storage are discarded. 3. Zeros are inserted in the spaces left behind after the original bits are moved to the left or right. This approach is known as a logical shift."),
			
			Question(question: ["If you try to insert a number into an integer constant or variable that cannot hold that value, by default Swift will do that...",
								"What will Swift do if you try to insert a number into an integer constant or variable that cannot hold that value?"],
					 image: "",
					 optionA: "Reports an error",
					 optionB: "Create a value",
					 optionC: "",
					 optionD: "",
					 questionId: 2466,
					 helpText: "If you try to insert a number into an integer constant or variable that cannot hold that value, by default Swift reports an error rather than allowing an invalid value to be created. This behavior gives extra safety when you work with numbers that are too large or too small."),
			
			Question(question: ["How many arithmetic overflow operators are available in Swift?"],
					 image: "",
					 optionA: "Three",
					 optionB: "Four",
					 optionC: "Two",
					 optionD: "Eleven",
					 questionId: 2467,
					 helpText: "When you specifically want an overflow condition to truncate the number of available bits, you can opt in to this behavior rather than triggering an error. Swift provides three arithmetic overflow operators that opt in to the overflow behavior for integer calculations. These operators all begin with an ampersand (&): Overflow addition (&+), Overflow subtraction (&-), Overflow multiplication (&*)."),
			
			Question(question: ["In which direction can numbers overflow, positive or negative?",
								"In which direction, positive or negative, can numbers overflow?"],
					 image: "",
					 optionA: "In both directions",
					 optionB: "Positive direction",
					 optionC: "Negative direction",
					 optionD: "",
					 questionId: 2468,
					 helpText: "Numbers can overflow in both the positive and negative direction."),
			
			Question(question: ["Overflow in the which direction wraps around from the maximum valid integer value back to the minimum?"],
					 image: "",
					 optionA: "Positive direction",
					 optionB: "Negative direction",
					 optionC: "In both directions",
					 optionD: "",
					 questionId: 2469,
					 helpText: "For both signed and unsigned integers, overflow in the positive direction wraps around from the maximum valid integer value back to the minimum, and overflow in the negative direction wraps around from the minimum value to the maximum."),
			
			Question(question: ["Overflow in the which direction wraps around from the minimum value to the maximum?"],
					 image: "",
					 optionA: "Negative direction",
					 optionB: "Positive direction",
					 optionC: "In both directions",
					 optionD: "",
					 questionId: 2470,
					 helpText: "For both signed and unsigned integers, overflow in the positive direction wraps around from the maximum valid integer value back to the minimum, and overflow in the negative direction wraps around from the minimum value to the maximum."),
			
			Question(question: ["The process that allows you to change the way existing operators work with your custom structures or classes"],
					 image: "",
					 optionA: "Overloading",
					 optionB: "Overflowing",
					 optionC: "Customization",
					 optionD: "",
					 questionId: 2471,
					 helpText: "Classes and structures can provide their own implementations of existing operators. This is known as overloading the existing operators."),
			
			Question(question: ["When we are overloading a prefix operator, which modifier must we implement?"],
					 image: "",
					 optionA: "prefix",
					 optionB: "postfix",
					 optionC: "pref",
					 optionD: "post",
					 questionId: 2472,
					 helpText: "Classes and structures can also provide implementations of the standard unary operators. Unary operators operate on a single target. They are prefix if they precede their target (such as -a) and postfix operators if they follow their target (such as b!). You implement a prefix or postfix unary operator by writing the prefix or postfix modifier before the func keyword when declaring the operator method.")
		]
	}
}
