
//  Created by Евгений Никитин on 12.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

// MARK:  Вопросы (id) с 1301 по 1400

class InitializationSet {
    static func getQuestions() -> [Question] {
        return [
            Question(question: ["Как \"Инициализация\" будет на английском?"],
                     image: "",
                     optionA: "Initialization",
                     optionB: "Deinitialization",
                     optionC: "Subscripts",
                     optionD: "Enumerations",
                     questionId: 1301,
                     helpText: "Правильный ответ: Initialization."),
            
            Question(question: ["Что включает в себя процесс инициализации экземпляра?",
                                "Во время инициализации экземпляра класса или структуры происходит это",
                                "Что происходит в момент инициализации экземпляров класса, структуры или перечисления?"],
                     image: "",
                     optionA: "Установка начальных значений",
                     optionB: "Освобождение памяти",
                     optionC: "Создание свойств хранения",
                     optionD: "Создание самого экземпляра",
                     questionId: 1302,
                     helpText: "Инициализация - подготовительный процесс экземпляра класса, структуры или перечисления для дальнейшего использования. Этот процесс включает в себя установку начальных значений для каждого свойства хранения этого экземпляра и проведение любых настроек или инициализации, которые нужны до того, как экземпляр будет использоваться."),
            
            Question(question: ["Инициализаторы в Swift возвращают значение?",
                                "Возвращают ли инициализаторы в Swift значение?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 1303,
                     helpText: "Вы реализуете инициализацию, определяя инициализаторы, которые схожи со специальными методами, которые вызываются для создания экземпляра определенного типа. В отличии от инициализаторов в Objective-C, инициализаторы в Swift не возвращают значения."),
            
            Question(question: ["Какая основная роль инициализаторов?",
                                "Основная роль инициализаторов",
                                "У инициализаторов есть основная задача, какая?"],
                     image: "",
                     optionA: "Корректная инициализация",
                     optionB: "Освобождение памяти",
                     optionC: "Создание свойств хранения",
                     optionD: "Освобождение экземпляра класса",
                     questionId: 1304,
                     helpText: "Основная роль инициализаторов - убедиться в том, что новый экземпляр типа правильно инициализирован до того, как будет использован в первый раз."),
            
            Question(question: ["Могут ли экземпляры структуры иметь деинициализатор?",
                                "Может ли экземпляр перечисления иметь деинициализатор?",
                                "Экземпляр класса не может иметь деинициализатор, так ли это?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 1305,
                     helpText: "Экземпляры классовых типов так же могут реализовывать деинициализаторы, которые проводят любую чистку прямо перед тем, как экземпляр класса будет освобожден."),
            
            Question(question: ["Обязаны ли классы и структуры устанавливать начальные значения у всех свойств хранения, во время создания экземпляра?",
                                "Классы и структуры должны устанавливать начальные значения у всех свойств хранения во время создания класса или структуры, так ли это?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "Только экземплярам класса",
                     optionD: "Только экземплярам структуры",
                     questionId: 1306,
                     helpText: "Классы и структуры должны устанавливать начальные значения у всех свойств хранения во время создания класса или структуры. Свойства хранения не могут быть оставлены в неопределённом состоянии."),
            
            Question(question: ["Можем ли мы присвоить значение по умолчанию для свойства хранения, как часть определения свойства?",
                                "Вы можете установить значение по умолчанию, как часть определения свойства хранения, так ли это?",
                                "Можем ли мы установить значение по умолчанию для свойства хранения, вместо использования инициализатора?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 1307,
                     helpText: "Вы можете установить начальное значение свойства внутри инициализатора или присвоить ему значение по умолчанию, как часть определения свойства."),
            
            Question(question: ["Если мы устанавливаем значение по умолчанию для свойства хранения, наблюдатель вызывается?",
                                "Когда мы устанавливаем исходное значение для свойства хранения в инициализаторе, будет вызываться наблюдатель?",
                                "Когда мы присваиваем значение по умолчанию или устанавливаем исходное значение в инициализаторе, значение устанавливается не напрямую, и мы вызываем наблюдателя свойства. Так ли это?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 1308,
                     helpText: "Когда вы присваиваете значение по умолчанию свойству хранения или устанавливаете исходное значение в инициализаторе, то значение устанавливается напрямую, без вызова наблюдателей."),
            
            Question(question: ["Каким ключевым словом вызывается инициализатор экземпляра?",
                                "Этим ключевым словом можно вызвать инициализатор экземпляра класса",
                                "Мы можем вызвать инициализатор класса с помощью этого ключевого слова"],
                     image: "",
                     optionA: "init",
                     optionB: "deinit",
                     optionC: "func",
                     optionD: "var",
                     questionId: 1309,
                     helpText: "Инициализаторы вызываются для создания нового экземпляра конкретного типа. В самой простой своей форме инициализатор работает как метод экземпляра без параметров, написанный с помощью ключевого слова init."),
            
            Question(question: ["Предпочтительнее использовать исходные значения для свойств, если эти значения повторяются, или использовать инициализатор?",
                                "Что предпочтительнее, при повторяющихся значениях свойств, использовать инициализатор или исходные значения для свойств хранения?"],
                     image: "",
                     optionA: "Исходные значения",
                     optionB: "Инициализатор",
                     optionC: "Без разницы",
                     optionD: "",
                     questionId: 1310,
                     helpText: "Если свойство каждый раз берет одно и то же исходное значение, то лучше указать это значение, в качестве значения по умолчанию, чем каждый раз устанавливать его в инициализаторе. Конечный результат такой же, но значение по умолчанию связывает инициализацию свойства ближе к своему объявлению. Так делают, чтобы оставить инициализаторы в более чистой и краткой форме, и это позволяет вам вывести тип свойства из его значения по умолчанию."),
            
            Question(question: ["Являются ли данные структуры равнозначными?",
                                "Эти структуры эквивалентны?"],
                     image: "Initialization11",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 1311,
                     helpText: "Вы можете написать структуру FahrenheitSecond в более простой форме, указав значение по умолчанию для свойства temperature, в месте его объявления в инициализаторе."),
            
            Question(question: ["Могут ли инициализаторы иметь входящие параметры?",
                                "Вы можете показать параметры инициализации как часть определения инициализатора, так ли это?",
                                "Параметры инициализатора имеют те же возможности и синтаксис, как и параметры функции или метода?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 1312,
                     helpText: "Вы можете указать параметры инициализации как часть определения инициализатора, для определения типов и имен значений, которые настраивают процесс инициализации. Параметры инициализации имеют те же возможности и синтаксис как и параметры функции или метода."),
            
            Question(question: ["Может ли класс иметь два пользовательских инициализатора?",
                                "Может ли структура иметь три пользовательских инициализатора?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 1313,
                     helpText: "Правильный ответ: Да. Классы и структуры могут иметь необходимое количество пользовательских инициализаторов. Главное, чтобы ваши инициализаторы имели разные внешние имена."),
            
            Question(question: ["Параметры инициализации могут иметь как внешнее, так и локальное имя одновременно. Так ли это?",
                                "Параметры инициализации могут иметь локальные имена и внешние имена, это так?",
                                "У параметров инициализации, как и у параметров функций или методов, есть локальные и внешние имена, это так?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "Только внешнее имя",
                     optionD: "Только локальное имя",
                     questionId: 1314,
                     helpText: "Как и в случае с параметрами функций или методов, параметры инициализации могут иметь локальные имена для использования внутри тела инициализатора и внешние для использования при вызове инициализатора."),
            
            Question(question: ["Может ли инициализатор иметь свое имя?",
                                "Имеет ли инициализатор имя как методы или функции?",
                                "Есть ли у инициализаторов имена до круглых скобок?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 1315,
                     helpText: "Инициализаторы не имеют своего имени до круглых скобок, как это имеют методы или функции. Поэтому имена и типы параметров инициализатора играют важную роль в определении того, какой инициализатор и где может быть использован."),
            
            Question(question: ["Если вы не укажите своё внешнее имя для параметра инициализатора, что произойдет?",
                                "Если вы не указали внешнее имя для параметра инициализатора, произойдет это"],
                     image: "",
                     optionA: "Имя предоставляется автоматически",
                     optionB: "Не будет внешнего имени",
                     optionC: "Столкнемся с ошибкой",
                     optionD: "",
                     questionId: 1316,
                     helpText: "Swift предоставляет автоматические внешние имена для каждого параметра, если вы, конечно, не укажите своё внешнее имя."),
            
            Question(question: ["Если у параметра инициализатора определено внешнее имя, можем ли мы вызвать его, не указывая это имя?",
                                "Можем ли мы вызвать инициализатор без внешних имен параметров, если они определены?"],
                     image: "",
                     optionA: "Получим ошибку компиляции",
                     optionB: "Да, можем",
                     optionC: "На наше усмотрение",
                     optionD: "",
                     questionId: 1317,
                     helpText: "Обратите внимание, что невозможно вызвать инициализатор без использования внешних имен. Внешние имена обязательно должны быть использованы в инициализаторе, если они определены, если пропустить их, то выскочит ошибка компиляции."),
            
            Question(question: ["Если при вызове инициализатора вы не хотите использовать внешние имена для параметров инициализации, какой символ мы должны поставить до локального имени?",
                                "Какой символ мы можем поставить до локального имена параметра инициализатора, чтобы при его вызове нам не пришлось указывать внешнее имя?"],
                     image: "",
                     optionA: "Нижнее подчеркивание (_)",
                     optionB: "Двоеточие (:)",
                     optionC: "Тире (-)",
                     optionD: "Амперсанд (&)",
                     questionId: 1318,
                     helpText: "Если вы не хотите использовать внешние имена для параметров инициализации, напишите подчеркивание (_) вместо явного указания внешнего имени для этого параметра, чтобы переопределить поведение по умолчанию."),
            
            Question(question: ["Если ваш пользовательский тип имеет свойство, которое логически имеет “отсутствие значения, какой тип для этого свойства необходимо использовать?"],
                     image: "",
                     optionA: "Опциональный",
                     optionB: "nil",
                     optionC: "Int",
                     optionD: "String",
                     questionId: 1319,
                     helpText: "Если ваш пользовательский тип имеет свойство, которое логически имеет “отсутствие значения”, возможно потому, что его значение не может быть установлено во время инициализации или потому, что ему разрешается иметь “отсутствие значения” в какой-либо точке кода, то такое свойство нужно объявить с опциональным типом. Свойства опционального типа автоматически инициализируются со значением nil, указывая на то, что значение стремится иметь значение “пока что отсутствие значение” на этапе инициализации."),
            
            Question(question: ["Можем ли мы изменять постоянное свойство хранения, после того, как мы присвоили значение в процессе инициализации?",
                                "Когда во время инициализации мы присвоили значение постоянному свойству хранения, можем ли мы его дальше изменять?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 1320,
                     helpText: "Вы можете присвоить значения постоянных (когда свойство константа) свойств в любой точке вашего процесса инициализации. Как только для свойства константы присваивается значение, оно не может быть далее изменено."),
            
            Question(question: ["В какой момент мы можем изменять постоянное свойство хранения у экземпляра класса?",
                                "Когда вы можете изменить постоянное свойство хранения у экземпляра?"],
                     image: "",
                     optionA: "Во время инициализации",
                     optionB: "Никогда",
                     optionC: "В любой момент",
                     optionD: "В подклассе",
                     questionId: 1321,
                     helpText: "В экземплярах класса постоянное свойство может быть изменено только во время инициализации класса, в котором оно представлено. Оно не может быть изменено подклассом."),
            
            Question(question: ["Может ли подкласс изменять проинициализированное постоянное свойство хренения суперкласса?",
                                "Мы можем изменить постоянно свойство хранения суперкласса в экземпляре подкласса, так ли это?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 1322,
                     helpText: "В экземплярах класса постоянное свойство может быть изменено только во время инициализации класса, в котором оно представлено. Оно не может быть изменено подклассом."),
            
            Question(question: ["Если у всех свойств структуры есть исходное значение, и нет инициализатора, чем мы можем воспользоваться, чтобы создать новый экземпляр?",
                                "У базового класса, который имеет значение по умолчанию для всех его свойств и не имеет ни одного инициализатора, есть это, и с помощью этого можно создавать новые экземпляры"],
                     image: "",
                     optionA: "Дефолтный инициализатор",
                     optionB: "Стартовый инициализатор",
                     optionC: "Деинициализатор",
                     optionD: "Стартер",
                     questionId: 1323,
                     helpText: "Swift предоставляет дефолтный инициализатор для любой структуры или базового класса, который имеет значение по умолчанию для всех его свойств и не имеет ни одного инициализатора. Дефолтный инициализатор просто создает новый экземпляр со всеми его свойствами с уже присвоенными значениями по умолчанию."),
            
            Question(question: ["Что мы получим после компиляции?",
                                "Какой результат мы получим после запуска данного кода?"],
                     image: "Initialization24",
                     optionA: "Экземпляр ShoppingListItem",
                     optionB: "Ошибку компиляции",
                     optionC: "Ошибку инициализации",
                     optionD: "",
                     questionId: 1324,
                     helpText: "Так как все свойства класса ShoppingListItem имеют значения по умолчанию и так как этот класс не имеет суперкласса, то ShoppingListItem автоматически получает реализацию дефолтного инициализатора, который создает новый экземпляр со всеми свойствами с уже присвоенными значениями по умолчанию. (Свойство name - свойство опционального типа String, значит значение по умолчанию равно nil). В примере выше используется дефолтный инициализатор для класса ShoppingListItem для создания нового экземпляра. Синтаксис дефолтного инициализатора в нашем случае выглядит как ShoppingListItem(), что присваивается переменной item."),
            
            Question(question: ["Сокращенный способ инициализировать свойства члена нового экземпляра структуры",
                                "При инициализации нового экземпляра структуры, мы можем воспользоваться этим инициализатором"],
                     image: "",
                     optionA: "Почленный инициализатор",
                     optionB: "Дефолтный инициализатор",
                     optionC: "Запрашиваемый инициализатор",
                     optionD: "Деинициализатор",
                     questionId: 1325,
                     helpText: "Почленный инициализатор - сокращенный способ инициализировать свойства члена нового экземпляра структуры. Начальные значения для свойств нового экземпляра могут быть переданы в почленный инициализатор по имени."),
            
            Question(question: ["Могут ли инициализаторы вызывать другие инициализаторы?",
                                "Могут ли инициализаторы вызывать другие инициализаторы для инициализации части экземпляра?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 1326,
                     helpText: "Инициализаторы могут вызывать другие инициализаторы для инициализации части экземпляра. Этот процесс называется как делегирование инициализатора. Он позволяет избегать дублирования кода в разных инициализаторах."),
            
            Question(question: ["Для типов значения и ссылочных типов существуют разные правила для делегирования инициализатора, так ли это?",
                                "Наследование у классов провоцирует другое поведение при делегировании инициализатора, так ли это?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 1327,
                     helpText: "Правила того, как работает делегирование инициализатора и для каких форм делегирования это возможно, для типов значений и ссылочных типов разные. Типы значений (структуры и перечисления) не поддерживают наследование, так что их процесс делегирования инициализатора сравнительно прост, потому что они только могут делегировать другому инициализатору то, что предоставляют сами. Классы, однако, могут наследовать от других классов. Это значит, что у классов есть дополнительная ответственность за проверку наличия корректных значений у каждого унаследованного свойства хранения класса."),
            
            Question(question: ["Если мы определили пользовательский инициализатор для типа значений, будем ли мы иметь доступ к дефолтному или почленному инициализатору?",
                                "Будем ли мы иметь доступ к дефолтному инициализатору, если мы определили пользовательский инициализатор для типа значений (структуры или перечисления)?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 1328,
                     helpText: "Обратите внимание, что если вы определите пользовательский инициализатор для типов значений, то вы больше не будете иметь доступа к дефолтному инициализатору (или почленному инициализатору, если это структура) для этого типа. Такое ограничение предотвращает ситуацию, в которой настройка важного дополнения в более сложном инициализаторе может быть пропущена при случайном использовании автоматического инициализатора."),
            
            Question(question: ["Где мы должны написать пользовательский инициализатор, чтобы иметь возможность продолжать пользоваться дефолтным инициализатором или почленным инициализатором типа значения?",
                                "Чтобы иметь возможность пользоваться дефолтным инициализатором типа значения, но так же сделать свой пользовательский инициализатор, мы должны написать его там"],
                     image: "",
                     optionA: "В расширении типа",
                     optionB: "Внутри структуры",
                     optionC: "В дефолтном инициализаторе",
                     optionD: "Не имеет значения",
                     questionId: 1329,
                     helpText: "Если вы хотите, чтобы ваш пользовательский тип значения имел возможность быть инициализированным дефолтным инициализатором или почленным инициализатором, или вашим пользовательским инициализатором, то вам нужно написать свой пользовательский инициализатор в расширении вашего типа, чем как часть реализации типа значения."),
            
            Question(question: ["Как записываются назначенные инициализаторы классов?",
                                "Назначенные инициализаторы для классов записываются именно так"],
                     image: "",
                     optionA: "init() { }",
                     optionB: "required init() { }",
                     optionC: "convenience init() { }",
                     optionD: "override init() { }",
                     questionId: 1330,
                     helpText: "Правильный ответ: init() { }. Назначенные инициализаторы для классов записываются точно так же как и простые инициализаторы для типов значений. Назначенные инициализаторы в основном инициализаторы класса. Они предназначены для того, чтобы полностью инициализировать все свойства представленные классом и чтобы вызвать соответствующий инициализатор суперкласса для продолжения процесса инициализации цепочки наследований суперклассов."),
            
            Question(question: ["Как записываются вспомогательные инициализаторы классов?",
                                "Вспомогательные инициализаторы для классов записываются именно так"],
                     image: "",
                     optionA: "convenience init() { }",
                     optionB: "required init() { }",
                     optionC: "init() { }",
                     optionD: "override init() { }",
                     questionId: 1331,
                     helpText: "Вспомогательные инициализаторы пишутся как назначенные, но только дополнительно используется вспомогательное слово convenience, которое располагается до слова init и разделяется пробелом. Вспомогательные инициализаторы являются вторичными, поддерживающими инициализаторами для класса. Вы можете определить вспомогательный инициализатор для вызова назначенного инициализатора из того же класса, что и вспомогательный инициализатор с некоторыми параметрами назначенного инициализатора с установленными начальными значениями."),
            
            Question(question: ["Обязаны ли мы обеспечивать вспомогательные инициализаторы, если класс не нуждается в них?",
                                "Если наш класс не нуждается во вспомогательных инициализаторах, обязаны ли мы их обеспечить?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 1332,
                     helpText: "Вы не обязаны обеспечивать вспомогательные инициализаторы, если ваш класс не нуждается в них. Создавайте вспомогательный инициализатор всякий раз, когда это является наиболее рациональным путем общей инициализации и может сэкономить время и сделать саму инициализацию класса более чистой и краткой."),
            
            Question(question: ["Как делегируют назначенные инициализаторы?",
                                "Назначенные инициализаторы делегируют таким образом"],
                     image: "",
                     optionA: "Наверх (в суперкласс)",
                     optionB: "По своему уровню",
                     optionC: "Внутри своего класса",
                     optionD: "",
                     questionId: 1333,
                     helpText: "Правило 1: Назначенный инициализатор должен вызывать назначенный инициализатор из суперкласса. Правило 2: Вспомогательный инициализатор должен вызывать другой инициализатор из того же класса. Правило 3: Вспомогательный инициализатор в конечном счете должен вызывать назначенный инициализатор. Вот как можно просто это запомнить: Назначенные инициализаторы должны делегировать наверх, вспомогательные инициализаторы должны делегировать по своему уровню (классу)."),
            
            Question(question: ["Сколько вспомогательных инициализаторов имеет суперкласс?",
                                "Сколько назначенных инициализаторов имеет подкласс?"],
                     image: "Initialization34",
                     optionA: "2",
                     optionB: "1",
                     optionC: "3",
                     optionD: "Нисколько",
                     questionId: 1334,
                     helpText: "Здесь, в суперклассе есть один назначенный инициализатор и два вспомогательных инициализатора. Один вспомогательный инициализатор вызывает другой вспомогательный инициализатор, который в свою очередь вызывает единственный назначенный инициализатор. Подкласс на этом рисунке содержит два назначенных инициализатора и один вспомогательный инициализатор. Вспомогательный инициализатор должен вызвать одного из двух назначенных инициализаторов, потому что он может вызвать другой инициализатор того же класса."),
            
            Question(question: ["Каким является процесс инициализации в Swift?",
                                "Процесс инициализации в Swift является таким"],
                     image: "",
                     optionA: "Двухфазным",
                     optionB: "Трехфазным",
                     optionC: "Моментальным",
                     optionD: "Ограниченным",
                     questionId: 1335,
                     helpText: "Инициализация класса в Swift является двухфазным процессом. На первой фазе каждое свойство получает начальное значение от класса, в котором оно представлено. Как только первоначальные значения для свойств хранения были определены, начинается вторая фаза, и каждому классу предоставляется возможность изменить свои свойства еще до того как будет считаться, что созданный экземпляр можно использовать. Использование двухфазного процесса инициализации делает инициализацию безопасной, в то же время обеспечивая полную гибкость классов в классовой иерархии. Двухфазная инициализация предотвращает доступ к значениям свойств до того, как они будут инициализированы и не допускает случайную установку значения свойства другим инициализатором."),
            
            Question(question: ["Сколько проверок Swift проводит, чтобы проверить, что наша двухфазная инициализация прошла без ошибок?",
                                "Swift проводит именно столько проверок, чтобы удостовериться, что двухфазная инициализация прошла без ошибок",
                                "Чтобы убедиться, что двухфазная инициализация прошла без ошибок, Swift проводит такое количество проверок (каждый раз)"],
                     image: "",
                     optionA: "Четыре",
                     optionB: "Три",
                     optionC: "Две",
                     optionD: "Одну",
                     questionId: 1336,
                     helpText: "Компилятор Swift проводит четыре полезные проверки безопасности для подтверждения того, что ваша двухфазная инициализация прошла без ошибок. Проверка 1: Назначенный инициализатор должен убедиться в том, что все свойства представленные его классом инициализированы до того, как он делегирует наверх, в инициализатор суперкласса. Проверка 2: Назначенный инициализатор должен делегировать суперклассу инициализатор до присваивания значений унаследованным свойствам. Проверка 3: Вспомогательный инициализатор должен делегировать другому инициализатору до того, как будут присвоены значения любым свойствам (включая свойства определенные тем же классом). Проверка 4: Инициализатор не может вызывать методы экземпляра, читать значения любого свойства экземпляра или ссылаться на self как на значение до тех пор, пока не будет закончена первая фаза инициализации."),
            
            Question(question: ["Согласно первой проверке безопасности двухфазной инициализации в Swift, память считается полностью инициализированной только для этих объектов"],
                     image: "",
                     optionA: "Полностью инициализированных",
                     optionB: "Любых",
                     optionC: "Частично инициализированных",
                     optionD: "С назначенными инициализаторами",
                     questionId: 1337,
                     helpText: "Память для объекта считается полностью инициализированной только для полностью инициализированного объекта, где все значения хранимых свойств известны. Для того чтобы удовлетворить этому правилу, назначенный инициализатор должен убедиться, что все его собственные свойства инициализированы до того, как будут переданы вверх по цепочке."),
            
            Question(question: ["Если назначенный инициализатор не делегирует суперклассу инициализатор до присваивания значений унаследованным свойствам, что произойдет со значениями, которые он присвоил?"],
                     image: "",
                     optionA: "Перепишутся суперклассом",
                     optionB: "Сбросятся на nil",
                     optionC: "Ничего не произойдет",
                     optionD: "",
                     questionId: 1338,
                     helpText: "Назначенный инициализатор должен делегировать суперклассу инициализатор до присваивания значений унаследованным свойствам. Если этого сделано не будет, то новое значение, которое присвоит назначенный инициализатор будет переписано суперклассом, как часть инициализации суперкласса."),
            
            Question(question: ["Если вспомогательный инициализатор не делегировал другому инициализатору до того, как были присвоены значения любым свойствам, что произойдет со значениями свойств?"],
                     image: "",
                     optionA: "Перезапишутся назначенным",
                     optionB: "Перепишутся суперклассом",
                     optionC: "Сбросятся на nil",
                     optionD: "Столкнемся с ошибкой",
                     questionId: 1339,
                     helpText: "Вспомогательный инициализатор должен делегировать другому инициализатору до того, как будут присвоены значения любым свойствам (включая свойства определенные тем же классом). Если этого сделано не будет, то новое значение, которое присваивает вспомогательный инициализатор, будет перезаписано его собственным назначенным инициализатором класса."),
            
            Question(question: ["К какой фазе инициализации относятся эти пункты: \"назначенный или вспомогательный инициализатор вызывается в классе, выделяется память под новый экземпляр этого класса, но она еще не инициализирована\"?",
                                "К какой фазе инициализации относятся эти пункты: \"Назначенный инициализатор для этого класса подтверждает, что все свойства, представленные этим классом, имеют значения\"?"],
                     image: "",
                     optionA: "К первой фазе",
                     optionB: "Ко второй фазе",
                     optionC: "К третьей фазе",
                     optionD: "Ни к какой",
                     questionId: 1340,
                     helpText: "Фаза первая: Назначенный или вспомогательный инициализатор вызывается в классе. Память под новый экземпляр этого класса выделяется, но она еще не инициализирована. Назначенный инициализатор для этого класса подтверждает, что все свойства, представленные этим классом, имеют значения. Память под эти свойства теперь инициализирована. Назначенный инициализатор передает инициализатору суперкласса, что пора проводить те же действия, только для его собственных свойств. Так продолжается по цепочке до самого верхнего суперкласса. После того как верхушка этой цепочки достигнута и последний класс в цепочке убедился в том, что все его свойства имеют значение, только тогда считается, что память для этого экземпляра полностью инициализирована. На этом первая фаза кончается."),
            
            Question(question: ["К какой фазе инициализации относится этот пункт: \"Двигаясь вниз по цепочке, каждый назначенный инициализатор в этой цепочке имеет такую возможность, как настраивать экземпляр\"?",
                                "К какой фазе инициализации относится этот пункт: \"Теперь инициализаторы получают доступ к self и могут изменять свои свойства, создавать экземпляры и вызывать методы и т.д.\"?"],
                     image: "",
                     optionA: "Ко второй фазе",
                     optionB: "К первой фазе",
                     optionC: "К третьей фазе",
                     optionD: "Ни к какой",
                     questionId: 1341,
                     helpText: "Фаза вторая: Двигаясь вниз по цепочке, каждый назначенный инициализатор в этой цепочке имеет такую возможность, как настраивать экземпляр. Теперь инициализаторы получают доступ к self и могут изменять свои свойства, создавать экземпляры и вызывать методы и т.д. И наконец, каждый вспомогательный инициализатор в цепочки имеет возможность настраивать экземпляр и работать с self."),
            
            Question(question: ["Какая фаза инициализации на изображении?",
                                "На изображении эта фаза инициализации"],
                     image: "Initialization42",
                     optionA: "Первая",
                     optionB: "Вторая",
                     optionC: "Третья",
                     optionD: "Четвертая",
                     questionId: 1342,
                     helpText: "Так выглядит первая фаза для гипотетического подкласса и суперкласса: Инициализация начинается с вызова вспомогательного инициализатора подкласса. Вспомогательный инициализатор пока не может изменять каких-либо свойств. Он делегирует назначенному инициализатору по тому же классу, где и он сам. Назначенный инициализатор убеждается, что все свойства, подкласса имеют значения. После этого он вызывает назначенный инициализатор своего суперкласса для продолжения. Назначенный инициализатор суперкласса проверяет наличие значений у всех свойств суперкласса. Сразу после того как все свойства суперкласса получают начальные значения, память считается полностью инициализированной, Фаза 1 завершается."),
            
            Question(question: ["Какая фаза инициализации на изображении?",
                                "На изображении эта фаза инициализации"],
                     image: "Initialization43",
                     optionA: "Вторая",
                     optionB: "Первая",
                     optionC: "Третья",
                     optionD: "Четвертая",
                     questionId: 1343,
                     helpText: "Фаза №2. Назначенный инициализатор суперкласса только теперь получает возможность менять дальнейшие экземпляры(хотя и не обязан). Как только назначенный инициализатор суперкласса заканчивает работу, получает возможность вносить изменения назначенный инициализатор подкласса(хотя он так же и не обязан это делать). Наконец, как только заканчивает работу назначенный инициализатор подкласса, то возможность вносить изменения получает вспомогательный инициализатор, который изначально был вызван. То есть если рассмотреть весь процесс отдаленно, то он получается, как бы, идет вверх, а потом спускается вниз."),
            
            Question(question: ["Подклассы в Swift не наследуют инициализаторов их суперклассов по умолчанию, так ли это?",
                                "Наследуют ли подклассы в Swift инициализаторы их суперклассов по умолчанию?",
                                "Могут ли подклассы наследовать инициализаторы суперклассов по умолчанию?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 1344,
                     helpText: "В отличии от подклассов в Objective-C, подклассы в Swift не наследуют инициализаторов их суперклассов по умолчанию. Такой подход в Swift предотвращает ситуации, когда простой инициализатор суперкласса наследуется более специфичным подклассом, а потом используется для создания экземпляра подкласса, который не полностью или не правильно инициализирован. Инициализаторы суперкласса наследуются в определенных обстоятельствах, но только когда это безопасно и когда это имеет смысл делать. "),
            
            Question(question: ["Какой модификатор мы должны писать перед тем, как переопределить инициализатор суперкласса внутри подкласса?",
                                "Этим модификатором мы должны помечать инициализатор суперкласса внутри подкласса (переопределение)"],
                     image: "",
                     optionA: "override",
                     optionB: "static",
                     optionC: "private",
                     optionD: "super",
                     questionId: 1345,
                     helpText: "Если вы хотите, чтобы у вашего подкласса были один или более инициализаторов его суперклассов, вы можете сделать свою реализацию этих инициализаторов внутри подкласса. Когда вы пишете инициализатор подкласса, который совпадает с назначенным инициализатором суперкласса, вы фактически переопределяете назначенный инициализатор. Таким образом вы должны писать модификатор override перед определением инициализатора подкласса. Это верно даже если вы переопределяете автоматически предоставляемый инициализатор."),
            
            Question(question: ["Должны ли мы использовать модификатор override, если написали инициализатор подкласса, который совпадает с вспомогательным инициализатором суперкласса?",
                                "Если наш инициализатор подкласса совпадает со вспомогательным инициализатором суперкласса, должны ли мы использовать модификатор override?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "При любом совпадении",
                     optionD: "",
                     questionId: 1346,
                     helpText: "И наоборот, если вы пишете инициализатор подкласса, который совпадает с вспомогательным инициализатором суперкласса, то этот вспомогательный инициализатор суперкласса никогда не сможет быть вызван напрямую вашим подклассом, в соответствии с правилами указанными выше. Таким образом ваш подкласс не проводит переопределение инициализатора суперкласса. И в результате, вы не пишете модификатор override, когда проводите совпадающую реализацию вспомогательного инициализатора суперкласса."),
            
            Question(question: ["Могут ли подклассы менять унаследованные переменные свойства в процессе инициализации?",
                                "В процессе инициализации подклассы могут менять унаследованные переменные свойства, так ли это?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "Только неизменяемые",
                     optionD: "",
                     questionId: 1347,
                     helpText: "Подклассы могут менять унаследованные переменные свойства в процессе инициализации, но нельзя менять неизменяемые унаследованные свойства."),
            
            Question(question: ["Будет ли подкласс наследовать все назначенные инициализаторы суперкласса, если сам не определяет ни одного?",
                                "Ваш подкласс будет наследовать все назначенные инициализаторы суперкласса, если сам не определяет ни одного назначенного инициализатора. Так ли это?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 1348,
                     helpText: "Если ваш подкласс не определяет ни одного назначенного инициализатора, он автоматически наследует все назначенные инициализаторы суперкласса."),
            
            Question(question: ["Если у класса есть реализация всех назначенных инициализаторов его суперкласса, будет ли он автоматически наследовать все вспомогательные инициализаторы этого суперкласса?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 1349,
                     helpText: "Если у вашего класса есть реализация всех назначенных инициализаторов его суперкласса, либо они были унаследованы (если ваш подкласс не определяет ни одного назначенного инициализатора, он автоматически наследует все назначенные инициализаторы суперкласса) или же представлены как часть пользовательской реализации определения подкласса, то тогда этот подкласс автоматически наследует все вспомогательные инициализаторы суперкласса."),
            
            Question(question: ["Что мы можем использовать, если нужно определить класс, структуру или перечисление, инициализация которого может не сработать?",
                                "Иногда бывает нужно определить класс, структуру или перечисление, инициализация которого может не сработать (такое неисполнение, например, может быть вызвано некорректными значениями параметров). Что мы можем использовать?"],
                     image: "",
                     optionA: "Проваливающийся инициализатор",
                     optionB: "Требуемый инициализатор",
                     optionC: "Назначенный инициализатор",
                     optionD: "Вспомогательный инициализатор",
                     questionId: 1350,
                     helpText: "Иногда бывает нужно определить класс, структуру или перечисление, инициализация которого может не сработать, провалиться. Такое неисполнение может быть вызвано некорректными значениями параметров или отсутствием требуемого внешнего источника данных или еще какое-нибудь обстоятельство, которое может не позволить завершить инициализацию успешно. Для того чтобы справиться с условиями инициализации, которые могут провалиться, определите один или несколько проваливающихся инициализаторов как часть определения класса, структуры или перечисления. Вы можете написать проваливающийся инициализатор поместив вопросительный знак после ключевого слова init (init?)."),
            
            Question(question: ["Можем ли мы определить проваливающийся инициализатор и обычные инициализаторы с одними и теми же именами и типами параметров?",
                                "Мы можем определить проваливающийся инициализатор и обычные инициализаторы с одними и теми же именами и типами параметров, так ли это?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "Иногда",
                     optionD: "",
                     questionId: 1351,
                     helpText: "Вы не можете определить проваливающийся инициализатор и обычные инициализаторы с одними и теми же именами и типами параметров. Проваливающийся инициализатор создает опциональное значение типа, который он инициализирует. Вы пишете return nil внутри проваливающегося инициализатора для индикации точки, где инициализация может провалиться."),
            
            Question(question: ["Как пишется проваливающийся инициализатор?"],
                     image: "",
                     optionA: "init?() { }",
                     optionB: "init()? { }",
                     optionC: "init(?) { }",
                     optionD: "",
                     questionId: 1352,
                     helpText: "Для того чтобы справиться с условиями инициализации, которые могут провалиться, определите один или несколько проваливающихся инициализаторов как часть определения класса, структуры или перечисления. Вы можете написать проваливающийся инициализатор поместив вопросительный знак после ключевого слова init (init?)."),
            
            Question(question: ["Можем ли мы использовать проваливающийся инициализатор для перечислений?",
                                "Вы можете использовать проваливающийся инициализатор для выбора подходящего члена перечисления, основываясь на одном или более параметров. Так ли это?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 1353,
                     helpText: "Вы можете использовать проваливающийся инициализатор для выбора подходящего члена перечисления основываясь на одном или более параметров. Инициализатор может провалиться, если предоставленные параметры не будут соответствовать подходящему члену перечисления."),
            
            Question(question: ["Какой инициализатор по умолчанию получают перечисления с начальными значениями (rawValue)?",
                                "Этот инициализатор по умолчанию получит перечисление с установленными начальными значениям (rawValue)"],
                     image: "",
                     optionA: "Проваливающийся",
                     optionB: "Назначенный",
                     optionC: "Вспомогательный",
                     optionD: "Требуемый",
                     questionId: 1354,
                     helpText: "Перечисления с начальными значениями по умолчанию получают проваливающийся инициализатор init?(rawValue:), который принимает параметр rawValue подходящего типа и выбирает соответствующий член перечисления, если он находит подходящий, или срабатывает сбой инициализации, если существующее значение не находит совпадения среди членов перечисления."),
            
            Question(question: ["Может ли проваливающийся инициализатор класса, структуры, или перечисления быть делегирован другому проваливающемуся инициализатору из того же класса?",
                                "Может ли проваливающийся инициализатор подкласса быть делегирован наверх в проваливающийся инициализатор суперкласса?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 1355,
                     helpText: "Проваливающийся инициализатор класса, структуры, перечисления может быть делегирован к другому проваливающемуся инициализатору из того же класса, структуры, перечисления. Аналогично проваливающийся инициализатор подкласса может быть делегирован наверх в проваливающийся инициализатор суперкласса."),
            
            Question(question: ["Какой инициализатор мы будем использовать, когда нам нужно, чтобы каждый подкласс этого класса был обязан реализовать его?"],
                     image: "",
                     optionA: "Требуемый",
                     optionB: "Назначенный",
                     optionC: "Вспомогательный",
                     optionD: "Почленный",
                     questionId: 1356,
                     helpText: "Напишите required перед определением инициализатора класса, если вы хотите, чтобы каждый подкласс этого класса был обязан реализовывать этот инициализатор."),
            
            Question(question: ["Каким ключевым словом обозначается требуемый инициализатор?",
                                "Требуемый инициализатор обозначается этим ключевым словом"],
                     image: "",
                     optionA: "required",
                     optionB: "convenience",
                     optionC: "override",
                     optionD: "",
                     questionId: 1357,
                     helpText: "Напишите required перед определением инициализатора класса, если вы хотите, чтобы каждый подкласс этого класса был обязан реализовывать этот инициализатор."),
            
            Question(question: ["Мы обязаны писать override каждый раз, когда переопределяем требуемый инициализатор. Это так?",
                                "Обязаны ли мы писать override всегда, когда переопределяем требуемый инициализатор суперкласса?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 1358,
                     helpText: "Вы также должны писать модификатор required перед каждой реализацией требуемого инициализатора класса для индикации того, что последующий подкласс так же должен унаследовать этот инициализатор по цепочке. Вы не пишете override, когда переопределяете требуемый инициализатор."),
            
            Question(question: ["Обязаны ли мы обеспечивать явную реализацию требуемого инициализатора в подклассах, если нам достаточно унаследованного?",
                                "Если мы можем удовлетворить требования инициализации унаследованным инициализатором суперкласса, должны ли мы явно реализовывать требуемый инициализатор в нашем подклассе?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 1359,
                     helpText: "Вы не должны обеспечивать явную реализацию требуемого инициализатора, если вы можете удовлетворить требование унаследованным инициализатором."),
            
            Question(question: ["Если начальное значение свойства требует какой-то настройки или структуризации, можете ли вы использовать замыкание?",
                                "Если начальное значение свойства требует какой-то структуризации или настройки, можете ли вы использовать глобальную функцию?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 1360,
                     helpText: "Если начальное значение свойства требует какой-то настройки или структуризации, то вы можете использовать замыкание или глобальную функцию, которая будет предоставлять значение для этого свойства. Как только создается новый экземпляр, вызывается функция или замыкание, которая возвращает значение, которое присваивается в качестве начального значения свойства. Эти виды замыканий или функций обычно создают временное значение того же типа, что и свойство, используя эту величину для отображения желаемого начального состояния, затем возвращают ее в качестве начального значения свойства."),
            
            Question(question: ["Обязаны ли мы использовать круглые скобки после замыкания?",
                                "Должны ли мы писать круглые скобки после замыкания?"],
                     image: "Initialization61",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "На ваше усмотрение",
                     optionD: "",
                     questionId: 1361,
                     helpText: "Обратите внимание, что после закрывающей фигурной скобки замыкания идут пустая пара круглых скобок. Это говорит Swift, что нужно исполнить это замыкание немедленно. Если вы пропустите эти скобки, то вы присваиваете само значение замыкания свойству, а не возвращаете значения замыкания."),
            
            Question(question: ["Если мы используем замыкание для инициализации свойства, можем ли мы обращаться к остальной части нашего экземпляра в момент, когда это замыкание исполняется?",
                                "Если для инициализации свойства мы используем замыкание, можем ли мы обращаться из него к остальным свойствам нашего экземпляра?",
                                "Когда для инициализации свойства мы используем замыкание, можем ли мы внутри него обращаться к self?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 1362,
                     helpText: "Если вы используете замыкание для инициализации свойства, помните, что остальная часть экземпляра еще не инициализирована, на тот момент когда исполняется замыкание. Это значит, что вы не можете получить доступ к значениям других свойств из вашего замыкания, даже если эти свойства имеют начальное значение. Вы так же не можете использовать неявное свойство self и не можете вызвать какой-либо метод вашего экземпляра."),
            
            //            Question(question: ["",
            //                                "",
            //                                ""],
            //                     image: "",
            //                     optionA: "",
            //                     optionB: "",
            //                     optionC: "",
            //                     optionD: "",
            //
            //                     questionId: 1363,
            //                     helpText: ""),
        ]
    }
}
