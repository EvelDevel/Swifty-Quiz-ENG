
//  Created by Евгений Никитин on 12.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

// MARK: 14 - Вопросы (id) с 1301 по 1400

class InitializationSet {
	static func getQuestions() -> [Question] {
		return [
			Question(question: ["What does the initialization process involve?"],
					 image: "",
					 optionA: "Setting initial values",
					 optionB: "Deallocation",
					 optionC: "Defining initializers",
					 optionD: "",
					 questionId: 1302,
					 helpText: "Initialization is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that is required before the new instance is ready for use."),
			
			Question(question: ["Do Swift initializers return a value?",
								"Swift initializers return a value. Is that correct?",
								"Can we expect a value to be returned from an initializer?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 1303,
					 helpText: "You implement the initialization process by defining initializers, which are like special methods that can be called to create a new instance of a particular type. Unlike Objective-C initializers, Swift initializers do not return a value."),
			
			Question(question: ["What best describes the initializers’ primary role?",
								"What is the primary role of initializers in Swift?",
								"Define the primary role of initializers"],
					 image: "",
					 optionA: "Correct instance initialization",
					 optionB: "Memory deallocation",
					 optionC: "Correct property storage",
					 optionD: "Multithreading checks",
					 questionId: 1304,
					 helpText: "The initializers primary role is to ensure that new instances of a type are correctly initialized before they are used for the first time."),
			
			Question(question: ["Can instances of both classes and structures implement a deinitializer?",
								"Is that correct that instances of class and structure types can implement both initializers and deinitializers?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 1305,
					 helpText: "Instances of class types can also implement a deinitializer, which performs any custom cleanup just before an instance of that class is deallocated. Deinitializers are only available on class types."),
			
			Question(question: ["Must classes set all of their stored properties to an appropriate initial value by the time an instance of that class is created?",
								"Must structures set all of their stored properties to an appropriate initial value by the time an instance of that structure is created?",
								"All stored properties must be determined by the time an instance of class or structure is created. Is that true?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1306,
					 helpText: "Classes and structures must set all of their stored properties to an appropriate initial value by the time an instance of that class or structure is created. Stored properties cannot be left in an indeterminate state."),
			
			Question(question: ["Can you set an initial value by assigning a default property value as part of the property’s definition?",
								"You can set an initial value for a stored property by assigning a default property value as part of its definition. Is that true?",
								"Is that correct that you can set an initial value for a stored property within an initializer?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1307,
					 helpText: "You can set an initial value for a stored property within an initializer, or by assigning a default property value as part of the property’s definition."),
			
			Question(question: ["When you assign a default value to a stored property, does it call property observers?",
								"When you set a property’s initial value within its initializer, does it call any property observers?",
								"While assigning a default value to a stored property a property observer is called. Is that correct?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 1308,
					 helpText: "When you assign a default value to a stored property, or set its initial value within an initializer, the value of that property is set directly, without calling any property observers."),
			
			Question(question: ["Which keyword is used to write initializers?",
								"We can use one of the following keywords to call an initializer. Which one?",
								"The keyword for writing initializers"],
					 image: "",
					 optionA: "init",
					 optionB: "create",
					 optionC: "func",
					 optionD: "var",
					 questionId: 1309,
					 helpText: "Initializers are called to create a new instance of a particular type. In its simplest form, an initializer is like an instance method with no parameters, written using the init keyword."),
			
			Question(question: ["Which of the following approaches is preferable if a property always requires the same initial value?",
								"How should we deal with properties that always take the same initial value?"],
					 image: "",
					 optionA: "Provide a default value to the property itself",
					 optionB: "Set a value within an initializer",
					 optionC: "It doesn't matter",
					 optionD: "",
					 questionId: 1310,
					 helpText: "If a property always takes the same initial value, provide a default value rather than setting a value within an initializer. The end result is the same, but the default value ties the property’s initialization more closely to its declaration. It makes for shorter, clearer initializers and enables you to infer the type of the property from its default value."),
			
			Question(question: ["Are these structures initialized in the same way?",
								"Is the first structure equivalent to the second one?"],
					 image: "Initialization11",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1311,
					 helpText: "Yes, they are. You can write the Fahrenheit structure from above in a simpler form by providing a default value for its temperature property at the point that the property is declared."),
			
			Question(question: ["Is it possible to provide initialization parameters as part of an initializer’s definition?",
								"You can provide initialization parameters as part of an initializer’s definition. Is that true?",
								"Do the initialization parameters have the same capabilities and syntax as function and method parameters?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1312,
					 helpText: "You can provide initialization parameters as part of an initializer’s definition, to define the types and names of values that customize the initialization process. Initialization parameters have the same capabilities and syntax as function and method parameters."),
			
			Question(question: ["Can a class have two custom initializers?",
								"Can a structure have several custom initializers?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1313,
					 helpText: "Yes. Classes and structures can have as many custom initializers as needed."),
			
			Question(question: ["Is that correct that initialization parameters can have both a parameter name and an argument label?",
								"Are you allowed to provide both a parameter name and an argument label in initialization parameters?",
								"As with function and method parameters, initialization parameters can have both a parameter name and an argument label, right?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "Only parameter name",
					 optionD: "Only argument label",
					 questionId: 1314,
					 helpText: "As with function and method parameters, initialization parameters can have both a parameter name for use within the initializer’s body and an argument label for use when calling the initializer."),
			
			Question(question: ["Do initializers have an identifying function name?",
								"Do you have to provide initializers with an identifying function name before their parentheses?",
								"Initializers have an identifying function name before their parentheses. Is that true?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 1315,
					 helpText: "Initializers do not have an identifying function name before their parentheses in the way that functions and methods do. Therefore, the names and types of an initializer’s parameters play a particularly important role in identifying which initializer should be called."),
			
			Question(question: ["If you didn't provide any argument labels for some parameters in an initializer, what is going to happen?",
								"What will happen if no argument labels were provided for parameters while declaring an initializer?"],
					 image: "",
					 optionA: "Swift will provide them automatically",
					 optionB: "There will be no argument labels",
					 optionC: "You will get an error",
					 optionD: "",
					 questionId: 1316,
					 helpText: "Swift provides an automatic argument label for every parameter in an initializer if you don’t provide one."),
			
			Question(question: ["Is it possible to call initializers without using argument labels, considering that they are defined?",
								"Can we call initializers without using argument labels, if they were defined?"],
					 image: "",
					 optionA: "No, we'll get compile-time error",
					 optionB: "Yes, it's possible",
					 optionC: "Only in required initializers",
					 optionD: "",
					 questionId: 1317,
					 helpText: "It is not possible to call initializers without using argument labels, if they are defined, and omitting them is a compile-time error."),
			
			Question(question: ["If you do not want to use an argument label for an initializer parameter, write a(n) ... instead",
								"Which of the following can you use to to skip an argument label for an initializer parameter?"],
					 image: "",
					 optionA: "Underscore (_)",
					 optionB: "Colon (:)",
					 optionC: "Ampersand (&)",
					 optionD: "",
					 questionId: 1318,
					 helpText: "If you do not want to use an argument label for an initializer parameter, write an underscore (_) instead of an explicit argument label for that parameter to override the default behavior."),
			
			Question(question: ["If your custom type has a stored property that is logically allowed to have no value - which type should you use to declare that property?"],
					 image: "",
					 optionA: "Optional type",
					 optionB: "String",
					 optionC: "Int",
					 optionD: "Class type",
					 questionId: 1319,
					 helpText: "If your custom type has a stored property that is logically allowed to have “no value” — perhaps because its value cannot be set during initialization, or because it is allowed to have “no value” at some later point — declare the property with an optional type. Properties of optional type are automatically initialized with a value of nil, indicating that the property is deliberately intended to have “no value yet” during initialization."),
			
			Question(question: ["Can we modify a constant property during initialization once we assigned a value to it?",
								"If we assigned a value to a constant property during initialization, can it be further modified?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 1320,
					 helpText: "You can assign a value to a constant property at any point during initialization, as long as it is set to a definite value by the time initialization finishes. Once a constant property is assigned a value, it can’t be further modified."),
			
			Question(question: ["At what point can constant property be modified?"],
					 image: "",
					 optionA: "During initialization",
					 optionB: "Never",
					 optionC: "At any moment",
					 optionD: "In a subclass",
					 questionId: 1321,
					 helpText: "For class instances, a constant property can be modified during initialization only by the class that introduces it. It cannot be modified by a subclass."),
			
			Question(question: ["Can a constant property be modified by a subclass?",
								"Is that true that for class instances, a constant property can be modified by a subclass?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 1322,
					 helpText: "For class instances, a constant property can be modified during initialization only by the class that introduces it. It cannot be modified by a subclass."),
			
			Question(question: ["What kind of initializer can we use if a class provides default values for all of its properties without providing at least one initializer itself?",
								"Swift provides a ... for any structure or class that provides default values for all of its properties and does not provide at least one initializer itself",
								"Which of the following creates a new instance with all class properties set to their default values?"],
					 image: "",
					 optionA: "Default initializer",
					 optionB: "Start initializer",
					 optionC: "Deinitializer",
					 optionD: "Custom initializer",
					 questionId: 1323,
					 helpText: "Swift provides a default initializer for any structure or class that provides default values for all of its properties and does not provide at least one initializer itself. The default initializer simply creates a new instance with all of its properties set to their default values."),
			
			Question(question: ["What will we get after running this code?"],
					 image: "Initialization24",
					 optionA: "New instance of ShoppingListItem",
					 optionB: "Compilation error",
					 optionC: "Initialization error",
					 optionD: "",
					 questionId: 1324,
					 helpText: "Because all properties of the ShoppingListItem class have default values, and because it is a base class with no superclass, ShoppingListItem automatically gains a default initializer implementation that creates a new instance with all of its properties set to their default values. (The name property is an optional String property, and so it automatically receives a default value of nil, even though this value is not written in the code.) The example above uses the default initializer for the ShoppingListItem class to create a new instance of the class with initializer syntax, written as ShoppingListItem(), and assigns this new instance to a variable called item."),
			
			Question(question: ["A shorthand way to initialize the member properties of new structure instances",
								"Which initializer can you use to initialize the member properties of new structure instances?"],
					 image: "",
					 optionA: "Memberwise initializer",
					 optionB: "Default initializer",
					 optionC: "Required initializer",
					 optionD: "Deinitializer",
					 questionId: 1325,
					 helpText: "The memberwise initializer is a shorthand way to initialize the member properties of new structure instances. Initial values for the properties of the new instance can be passed to the memberwise initializer by name."),
			
			Question(question: ["Can initializers call other initializers?",
								"Can initializers call other initializers to perform part of an instance’s initialization?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1326,
					 helpText: "Initializers can call other initializers to perform part of an instance’s initialization. This process, known as initializer delegation, avoids duplicating code across multiple initializers."),
			
			Question(question: ["Are the rules for how initializer delegation works different for value types and class types?",
								"Are the rules for what forms of delegation are allowed, different for value types and class types?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1327,
					 helpText: "The rules for how initializer delegation works, and for what forms of delegation are allowed, are different for value types and class types. Value types (structures and enumerations) do not support inheritance, and so their initializer delegation process is relatively simple, because they can only delegate to another initializer that they provide themselves. Classes, however, can inherit from other classes, as described in Inheritance. This means that classes have additional responsibilities for ensuring that all stored properties they inherit are assigned a suitable value during initialization."),
			
			Question(question: ["If you define a custom initializer for a value type, will you have access to the default initializer?",
								"If you define a custom initializer for a value type, will you have access to the memberwise initializer (if it is a structure)?",
								"Will you have access to the memberwise initializer, if you already defined a custom initializer?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 1328,
					 helpText: "Note that if you define a custom initializer for a value type, you will no longer have access to the default initializer (or the memberwise initializer, if it is a structure) for that type. This constraint prevents a situation in which additional essential setup provided in a more complex initializer is accidentally circumvented by someone using one of the automatic initializers."),
			
			Question(question: ["If you want your custom value type to be initializable with the default initializer, and also with your own custom initializers, consider writing the custom ones ...",
								"How can you implement a custom initializer if you want your custom value type to be initializable both with the memberwise initializer and with your own custom initializer?"],
					 image: "",
					 optionA: "In an extension",
					 optionB: "Inside a structure",
					 optionC: "As part of original implementation",
					 optionD: "",
					 questionId: 1329,
					 helpText: "If you want your custom value type to be initializable with the default initializer and memberwise initializer, and also with your own custom initializers, write your custom initializers in an extension rather than as part of the value type’s original implementation."),
			
			Question(question: ["How will you write designated initializers for classes?",
								"Designated initializers for classes should be written like this"],
					 image: "",
					 optionA: "init() { }",
					 optionB: "required init() { }",
					 optionC: "convenience init() { }",
					 optionD: "override init() { }",
					 questionId: 1330,
					 helpText: "Correct answer: init() { }. Designated initializers for classes are written in the same way as simple initializers for value types. Designated initializers are the primary initializers for a class. A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain."),
			
			Question(question: ["How will you declare convenience initializers for classes?",
								"Convenience initializers for classes should be written like this"],
					 image: "",
					 optionA: "convenience init() { }",
					 optionB: "required init() { }",
					 optionC: "init() { }",
					 optionD: "override init() { }",
					 questionId: 1331,
					 helpText: "Correct answer: convenience init() { }. Convenience initializers are secondary, supporting initializers for a class. You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializer’s parameters set to default values. You can also define a convenience initializer to create an instance of that class for a specific use case or input value type."),
			
			Question(question: ["Do you have to provide convenience initializers if your class does not require them?",
								"If our class does not require convenience initializers, do we need to provide them?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 1332,
					 helpText: "You do not have to provide convenience initializers if your class does not require them. Create convenience initializers whenever a shortcut to a common initialization pattern will save time or make initialization of the class clearer in intent."),
			
			Question(question: ["Designated initializers delegate this way",
								"How do designated initializers delegate?"],
					 image: "",
					 optionA: "From a subclass up to its superclass",
					 optionB: "Across subclasses of the same level",
					 optionC: "Inside a class",
					 optionD: "",
					 questionId: 1333,
					 helpText: "There are three rules for delegation calls between initializers: Rule 1: A designated initializer must call a designated initializer from its immediate superclass. Rule 2: A convenience initializer must call another initializer from the same class. Rule 3: A convenience initializer must ultimately call a designated initializer. In other words, designated initializers must always delegate up and convenience initializers must always delegate across."),
			
			Question(question: ["How many convenience initializers does the superclass from this picture have?",
								"Pick the correct number of convenience initializers the following superclass has"],
					 image: "Initialization34",
					 optionA: "Two",
					 optionB: "One",
					 optionC: "Three",
					 optionD: "",
					 questionId: 1334,
					 helpText: "Here, the superclass has a single designated initializer and two convenience initializers. One convenience initializer calls another convenience initializer, which in turn calls the single designated initializer. The subclass in this figure has two designated initializers and one convenience initializer. The convenience initializer must call one of the two designated initializers, because it can only call another initializer from the same class."),
			
			Question(question: ["Class initialization in Swift is a(n) ... process"],
					 image: "",
					 optionA: "Two-phase",
					 optionB: "Three-phase",
					 optionC: "Instantaneous",
					 optionD: "",
					 questionId: 1335,
					 helpText: "Class initialization in Swift is a two-phase process. In the first phase, each stored property is assigned an initial value by the class that introduced it. Once the initial state for every stored property has been determined, the second phase begins, and each class is given the opportunity to customize its stored properties further before the new instance is considered ready for use. The use of a two-phase initialization process makes initialization safe, while still giving complete flexibility to each class in a class hierarchy. Two-phase initialization prevents property values from being accessed before they are initialized, and prevents property values from being set to a different value by another initializer unexpectedly."),
			
			Question(question: ["How many safety-checks Swift’s compiler performs to make sure that two-phase initialization is completed without error?",
								"Swift’s compiler performs several safety-checks to make sure that two-phase initialization is completed without error. How many safety-checks are there?"],
					 image: "",
					 optionA: "Four",
					 optionB: "Three",
					 optionC: "Two",
					 optionD: "Thirteen",
					 questionId: 1336,
					 helpText: "Swift’s compiler performs four helpful safety-checks to make sure that two-phase initialization is completed without error. 1. A designated initializer must ensure that all of the properties introduced by its class are initialized before it delegates up to a superclass initializer; 2. A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property; 3. A convenience initializer must delegate to another initializer before assigning a value to any property (including properties defined by the same class); 4. An initializer cannot call any instance methods, read the values of any instance properties, or refer to self as a value until after the first phase of initialization is complete."),
			
			Question(question: ["According to the first safety check of two-phase initialization in Swift, memory is considered fully initialized for ..."],
					 image: "",
					 optionA: "Objects with known stored properties",
					 optionB: "Any objects",
					 optionC: "Partly initialized objects",
					 optionD: "Objects with designated initializers",
					 questionId: 1337,
					 helpText: "The memory for an object is only considered fully initialized once the initial state of all of its stored properties is known. In order for this rule to be satisfied, a designated initializer must make sure that all of its own properties are initialized before it hands off up the chain."),
			
			Question(question: ["Which initialization phase is shown on the image?"],
					 image: "Initialization43",
					 optionA: "Phase 2",
					 optionB: "Phase 3",
					 optionC: "Phase 1",
					 optionD: "",
					 questionId: 1338,
					 helpText: "Here’s how phase 2 looks for an initialization call: The superclass’s designated initializer here has an opportunity to customize the instance further after finishing the first phase (although it does not have to). Once the superclass’s designated initializer is finished, the subclass’s designated initializer can perform additional customization (although again, it does not have to). Finally, once the subclass’s designated initializer is finished, the convenience initializer that was originally called can perform additional customization."),
			
			Question(question: ["If a designated initializer doesn’t delegate up to a superclass initializer before assigning a value to an inherited property, what is going to happen to this value?"],
					 image: "",
					 optionA: "Will be overwritten by the superclass",
					 optionB: "Will be cast to nil",
					 optionC: "Nothing is going to happen",
					 optionD: "",
					 questionId: 1339,
					 helpText: "A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property. If it doesn’t, the new value the designated initializer assigns will be overwritten by the superclass as part of its own initialization."),
			
			Question(question: ["If a convenience initializer doesn't delegate to another initializer before assigning a value to a property, what is going to happen to this value?"],
					 image: "",
					 optionA: "It'll be overwritten by its own class",
					 optionB: "It'll be overwritten by the superclass",
					 optionC: "Will be cast to nil",
					 optionD: "We will get an error",
					 questionId: 1340,
					 helpText: "A convenience initializer must delegate to another initializer before assigning a value to any property (including properties defined by the same class). If it doesn’t, the new value the convenience initializer assigns will be overwritten by its own class’s designated initializer."),
			
			Question(question: ["Which initialization phase is it: \"A designated or convenience initializer is called on a class, memory for a new instance of that class is allocated, but the memory is not yet initialized\"?"],
					 image: "",
					 optionA: "Phase one",
					 optionB: "Phase two",
					 optionC: "Phase three",
					 optionD: "This is not part of any phase",
					 questionId: 1341,
					 helpText: "Phase 1: A designated or convenience initializer is called on a class. Memory for a new instance of that class is allocated. The memory is not yet initialized. A designated initializer for that class confirms that all stored properties introduced by that class have a value. The memory for these stored properties is now initialized. The designated initializer hands off to a superclass initializer to perform the same task for its own stored properties. This continues up the class inheritance chain until the top of the chain is reached. Once the top of the chain is reached, and the final class in the chain has ensured that all of its stored properties have a value, the instance’s memory is considered to be fully initialized, and phase 1 is complete."),
			
			Question(question: ["Which initialization phase is it: \"Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further, initializers are now able to access self and can modify its properties\"?",
								"Which initialization phase is it: \"Any convenience initializers in the chain have the option to customize the instance and to work with self\"?"],
					 image: "",
					 optionA: "Phase two",
					 optionB: "Phase one",
					 optionC: "This is not part of any phase",
					 optionD: "",
					 questionId: 1342,
					 helpText: "Phase 2: Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further. Initializers are now able to access self and can modify its properties, call its instance methods, and so on. Any convenience initializers in the chain have the option to customize the instance and to work with self."),
			
			Question(question: ["Which initialization phase is shown on the image?"],
					 image: "Initialization42",
					 optionA: "Phase 1",
					 optionB: "Phase 2",
					 optionC: "Phase 3",
					 optionD: "",
					 questionId: 1343,
					 helpText: "This is what phase-one looks like for a hypothetical subclass and superclass: Initialization begins with a call to a convenience initializer on the subclass. This convenience initializer cannot yet modify any properties. It delegates across to a designated initializer from the same class. The designated initializer makes sure that all of the subclass’s properties have a value, as per the first safety check. It then calls a designated initializer on its superclass to continue the initialization up the chain. The superclass’s designated initializer makes sure that all of the superclass properties have a value. There are no further superclasses to initialize, and so no further delegation is needed. As soon as all properties of the superclass have an initial value, its memory is considered fully initialized, and phase 1 is complete."),
			
			Question(question: ["Swift subclasses do not inherit their superclass initializers by default. Is that true?",
								"Does Swift subclasses inherit their superclass initializers by default?",
								"Can Swift subclasses inherit their superclass initializers by default?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1344,
					 helpText: "Unlike subclasses in Objective-C, Swift subclasses do not inherit their superclass initializers by default. Swift’s approach prevents a situation in which a simple initializer from a superclass is inherited by a more specialized subclass and is used to create a new instance of the subclass that is not fully or correctly initialized. Superclass initializers are inherited in certain circumstances, but only when it is safe and appropriate to do so."),
			
			Question(question: ["What modifier must you write when the subclass initializer matches a superclass designated initializer?",
								"You write the ... modifier before the subclass’s initializer definition, when you write a subclass initializer that matches a superclass designated initializer"],
					 image: "",
					 optionA: "override",
					 optionB: "static",
					 optionC: "private",
					 optionD: "super",
					 questionId: 1345,
					 helpText: "If you want a custom subclass to present one or more of the same initializers as its superclass, you can provide a custom implementation of those initializers within the subclass. When you write a subclass initializer that matches a superclass designated initializer, you are effectively providing an override of that designated initializer. Therefore, you must write the override modifier before the subclass’s initializer definition. This is true even if you are overriding an automatically provided default initializer"),
			
			Question(question: ["You need to use the override modifier when providing a matching implementation of a superclass convenience initializer. Is that true?",
								"Do we need to write the override modifier when providing a matching implementation of a superclass convenience initializer?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 1346,
					 helpText: "If you write a subclass initializer that matches a superclass convenience initializer, that superclass convenience initializer can never be called directly by your subclass. Therefore, your subclass is not (strictly speaking) providing an override of the superclass initializer. As a result, you do not write the override modifier when providing a matching implementation of a superclass convenience initializer."),
			
			Question(question: ["Can subclasses modify inherited variable properties during initialization?",
								"Subclasses can modify inherited variable properties during initialization. Is that correct?",
								"Can you modify inherited variable properties during initialization of a subclass?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1347,
					 helpText: "Subclasses can modify inherited variable properties during initialization, but can not modify inherited constant properties."),
			
			Question(question: ["Will your subclass inherit all of its superclass designated initializers, if it doesn’t define any designated initializers itself?",
								"Is that true that in case your subclass doesn’t define any designated initializers, it automatically inherits all of its superclass designated initializers?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1348,
					 helpText: "If your subclass doesn’t define any designated initializers, it automatically inherits all of its superclass designated initializers."),
			
			Question(question: ["If your subclass provides an implementation of all of its superclass designated initializers will it inherit all of the superclass convenience initializers?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1349,
					 helpText: "If your subclass provides an implementation of all of its superclass designated initializers — either by inheriting them, or by providing a custom implementation as part of its definition — then it automatically inherits all of the superclass convenience initializers."),
			
			Question(question: ["Which initializer should we use, if our initialization for a class, structure, or enumeration can fail?",
								"To define a class, structure, or enumeration for which initialization can fail, add one or more initializers of this type"],
					 image: "",
					 optionA: "Failable Initializer",
					 optionB: "Required initializer",
					 optionC: "Designated initializer",
					 optionD: "Convenience initializer",
					 questionId: 1350,
					 helpText: "It is sometimes useful to define a class, structure, or enumeration for which initialization can fail. This failure might be triggered by invalid initialization parameter values, the absence of a required external resource, or some other condition that prevents initialization from succeeding. To cope with initialization conditions that can fail, define one or more failable initializers as part of a class, structure, or enumeration definition. You write a failable initializer by placing a question mark after the init keyword (init?)."),
			
			Question(question: ["Can you define a failable and a nonfailable initializer with the same parameter types and names?",
								"Is it possible to have a failable and a nonfailable initializer with the same parameter types and names?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "Sometimes",
					 optionD: "",
					 questionId: 1351,
					 helpText: "You cannot define a failable and a nonfailable initializer with the same parameter types and names. A failable initializer creates an optional value of the type it initializes. You write return nil within a failable initializer to indicate a point at which initialization failure can be triggered."),
			
			Question(question: ["Choose the correct way of defining a failable initializer"],
					 image: "",
					 optionA: "init?() { }",
					 optionB: "init()? { }",
					 optionC: "init(?) { }",
					 optionD: "",
					 questionId: 1352,
					 helpText: "To cope with initialization conditions that can fail, define one or more failable initializers as part of a class, structure, or enumeration definition. You write a failable initializer by placing a question mark after the init keyword \"init?\"."),
			
			Question(question: ["Can we use a failable initializer for enumerations?",
								"Do enumerations support failable initializers?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1353,
					 helpText: "You can use a failable initializer to select an appropriate enumeration case based on one or more parameters. The initializer can then fail if the provided parameters do not match an appropriate enumeration case."),
			
			Question(question: ["Enumerations with raw values automatically receive a ... initializer"],
					 image: "",
					 optionA: "Failable",
					 optionB: "Designated",
					 optionC: "Convenience",
					 optionD: "Required",
					 questionId: 1354,
					 helpText: "Enumerations with raw values automatically receive a failable initializer, init?(rawValue:), that takes a parameter called rawValue of the appropriate raw-value type and selects a matching enumeration case if one is found, or triggers an initialization failure if no matching value exists."),
			
			Question(question: ["Can a failable initializer of a class, structure, or enumeration delegate across to another failable initializer from the same class?",
								"Can a subclass failable initializer delegate up to a superclass failable initializer?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1355,
					 helpText: "A failable initializer of a class, structure, or enumeration can delegate across to another failable initializer from the same class, structure, or enumeration. Similarly, a subclass failable initializer can delegate up to a superclass failable initializer."),
			
			Question(question: ["From the options below, which keyword indicates that every subclass of the class must implement that initializer?"],
					 image: "",
					 optionA: "required",
					 optionB: "convenience",
					 optionC: "override",
					 optionD: "",
					 questionId: 1356,
					 helpText: "Write the required modifier before the definition of a class initializer to indicate that every subclass of the class must implement that initializer."),
			
			Question(question: ["You must write the override modifier when overriding a required designated initializer. Is that true?",
								"Do we need to write the override modifier while overriding a required designated initializer?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 1357,
					 helpText: "The modifier you must write in this case is the required modifier. Use it before every subclass implementation of a required initializer, to indicate that the initializer requirement applies to further subclasses in the chain. You do not write the override modifier when overriding a required designated initializer."),
			
			Question(question: ["Do you have to provide an explicit implementation of a required initializer if you can satisfy the requirement with an inherited initializer?",
								"If you can satisfy the requirement with an inherited initializer, do you have to provide an implementation of a required initializer explicitly?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 1358,
					 helpText: "You do not have to provide an explicit implementation of a required initializer if you can satisfy the requirement with an inherited initializer."),
			
			Question(question: ["If a stored property’s default value requires some customization or setup, can you use a closure to provide a customized default value for that property?",
								"If a stored property’s default value requires some customization or setup, can you use a global function to provide a customized default value for that property?"],
					 image: "",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1359,
					 helpText: "If a stored property’s default value requires some customization or setup, you can use a closure or global function to provide a customized default value for that property. Whenever a new instance of the type that the property belongs to is initialized, the closure or function is called, and its return value is assigned as the property’s default value. These kinds of closures or functions typically create a temporary value of the same type as the property, tailor that value to represent the desired initial state, and then return that temporary value to be used as the property’s default value."),
			
			Question(question: ["Do we need to use a empty pair of parentheses after curly braces?"],
					 image: "Initialization61",
					 optionA: "Yes",
					 optionB: "No",
					 optionC: "",
					 optionD: "",
					 questionId: 1360,
					 helpText: "Note that the closure’s end curly brace is followed by an empty pair of parentheses. This tells Swift to execute the closure immediately. If you omit these parentheses, you are trying to assign the closure itself to the property, and not the return value of the closure."),
			
			Question(question: ["If you use a closure to initialize a property, can you access any other property values from within your closure?",
								"If you use a closure to initialize a property, can you use the implicit self property, or call any of the instance’s methods?"],
					 image: "",
					 optionA: "No",
					 optionB: "Yes",
					 optionC: "",
					 optionD: "",
					 questionId: 1361,
					 helpText: "If you use a closure to initialize a property, remember that the rest of the instance has not yet been initialized at the point that the closure is executed. This means that you cannot access any other property values from within your closure, even if those properties have default values. You also cannot use the implicit self property, or call any of the instance’s methods.")
		]
	}
}
