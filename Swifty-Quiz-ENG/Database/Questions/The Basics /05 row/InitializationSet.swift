
//  Created by Евгений Никитин on 12.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

// MARK: 14 - Вопросы (id) с 1301 по 1400

class InitializationSet {
    static func getQuestions() -> [Question] {
        return [
            Question(question: ["What does the initialization process involve?"],
                     image: "",
                     optionA: "Setting initial values",
                     optionB: "Deallocation",
                     optionC: "Defining initializers",
                     optionD: "",
                     questionId: 1302,
                     helpText: "Initialization is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that is required before the new instance is ready for use."),
            
            Question(question: ["Does Swift initializers return a value?",
								"Swift initializers does return a value. Is that true?",
								"Can we expect a returned value from initializer?"],
                     image: "",
                     optionA: "No",
                     optionB: "Yes",
                     optionC: "",
                     optionD: "",
                     questionId: 1303,
                     helpText: "You implement this initialization process by defining initializers, which are like special methods that can be called to create a new instance of a particular type. Unlike Objective-C initializers, Swift initializers do not return a value."),
            
            Question(question: ["The initializers primary role is ...",
                                "What the primary role of initializers in Swift?",
                                "The initializers have a primary role. Which is it?"],
                     image: "",
                     optionA: "Correct instance initialization",
                     optionB: "Memory deallocation",
                     optionC: "Define stored properties",
                     optionD: "Check for multithreading",
                     questionId: 1304,
                     helpText: "The initializers primary role is to ensure that new instances of a type are correctly initialized before they are used for the first time."),
            
            Question(question: ["Can instances of structure types implement a deinitializer?",
                                "Can instances of enumiration types implement a deinitializer?",
                                "Instances of class types can't implement a deinitializer. Is that true?"],
                     image: "",
                     optionA: "No",
                     optionB: "Yes",
                     optionC: "",
                     optionD: "",
                     questionId: 1305,
                     helpText: "Instances of class types can implement a deinitializer, which performs any custom cleanup just before an instance of that class is deallocated."),
            
            Question(question: ["Does classes set all of their stored properties to an appropriate initial value by the time an instance of that class is created?",
								"Does structures set all of their stored properties to an appropriate initial value by the time an instance of structure is created?",
                                "Stored properties cannot be left in an indeterminate state by the time an instance of class or structure is created. Is that true?"],
                     image: "",
                     optionA: "Yes",
                     optionB: "No",
                     optionC: "",
                     optionD: "",
                     questionId: 1306,
                     helpText: "Classes and structures must set all of their stored properties to an appropriate initial value by the time an instance of that class or structure is created. Stored properties cannot be left in an indeterminate state."),
            
            Question(question: ["Can you set an initial value by assigning a default property value as part of the property’s definition?",
                                "You can set an initial value for a stored property by assigning a default property value as part of its definition. Is that true?",
                                "You can set an initial value for a stored property within an initializer. Is that true?"],
                     image: "",
                     optionA: "Yes",
                     optionB: "No",
                     optionC: "",
                     optionD: "",
                     questionId: 1307,
                     helpText: "You can set an initial value for a stored property within an initializer, or by assigning a default property value as part of the property’s definition."),
            
            Question(question: ["When you assign a default value to a stored property, does it call property observers?",
                                "When you set property initial value within an initializer, did it call to any property observers?",
                                "When you assign a deault value to a stored property, or set its initial value within an initializer, the value of that property won't set directly, and will call property observers. Is that true?"],
                     image: "",
                     optionA: "No",
                     optionB: "Yes",
                     optionC: "",
                     optionD: "",
                     questionId: 1308,
                     helpText: "When you assign a deault value to a stored property, or set its initial value within an initializer, the value of that property is set directly, without calling any property observers."),
            
            Question(question: ["Initializers are called by this keyword",
								"We can use this keyword to call an initializer",
								"Keyword for initialization"],
                     image: "",
                     optionA: "init",
                     optionB: "deinit",
                     optionC: "func",
                     optionD: "var",
                     questionId: 1309,
                     helpText: "Initializers are called to create a new instance of a particular type. In its simplest form, an initializer is like an instance method with no parameters, written using the init keyword."),
            
			/// Пожалуйста подумай над формулировками ниже (1310)
			/// Поскольку можно и так и так, но предпочтительнее все таки предоставлять дефолтное значение
			
            Question(question: ["If a property always takes the same initial value, what we need to do?",
                                "What you need to do, if a property always takes the same initial value?"],
                     image: "",
                     optionA: "Provide a default value",
                     optionB: "Setting a value within an initializer",
                     optionC: "It doesn't matter",
                     optionD: "",
                     questionId: 1310,
                     helpText: "If a property always takes the same initial value, provide a default value rather than setting a value within an initializer. The end result is the same, but the default value ties the property’s initialization more closely to its declaration. It makes for shorter, clearer initializers and enables you to infer the type of the property from its default value."),
            
            Question(question: ["Are these structures the same?",
                                "Are these structures equivalent?"],
                     image: "Initialization11",
                     optionA: "Yes",
                     optionB: "No",
                     optionC: "",
                     optionD: "",
                     questionId: 1311,
                     helpText: "Yes, they are. You can write the Fahrenheit structure from above in a simpler form by providing a default value for its temperature property at the point that the property is declared."),
            
            Question(question: ["Can you provide initialization parameters as part of an initializer’s definition?",
                                "You can provide initialization parameters as part of an initializer’s definition. Is that true?",
                                "Does the initialization parameters have the same capabilities and syntax as function and method parameters?"],
                     image: "",
                     optionA: "Yes",
                     optionB: "No",
                     optionC: "",
                     optionD: "",
                     questionId: 1312,
                     helpText: "You can provide initialization parameters as part of an initializer’s definition, to define the types and names of values that customize the initialization process. Initialization parameters have the same capabilities and syntax as function and method parameters."),
            
			/// 1313 - Самописный вопрос
			
            Question(question: ["Can class have two custom initializers?",
                                "Can the structure have three custom initializers?"],
                     image: "",
                     optionA: "Yes",
                     optionB: "No",
                     optionC: "",
                     optionD: "",
                     questionId: 1313,
                     helpText: "Yes. Classes and structures can have as many custom initializers as needed."),
            
            Question(question: ["Initialization parameters can have both a parameter name and argument label. Is that true?",
                                "Does the initialization parameters can have both a parameter name and argument label?",
                                "As with function and method parameters, initialization parameters can have both a parameter name and argument label. Is that true?"],
                     image: "",
                     optionA: "Yes",
                     optionB: "No",
                     optionC: "Only parameter name",
                     optionD: "Only argument label",
                     questionId: 1314,
                     helpText: "As with function and method parameters, initialization parameters can have both a parameter name for use within the initializer’s body and an argument label for use when calling the initializer."),
            
            Question(question: ["Does the initializers have an identifying function name?",
                                "Does the initializers have an identifying function name before their parentheses?",
                                "Initializers have an identifying function name before their parentheses. Is that true?"],
                     image: "",
                     optionA: "No",
                     optionB: "Yes",
                     optionC: "",
                     optionD: "",
                     questionId: 1315,
                     helpText: "initializers do not have an identifying function name before their parentheses in the way that functions and methods do. Therefore, the names and types of an initializer’s parameters play a particularly important role in identifying which initializer should be called."),
            
			/// Здесь немного сомневаюсь по поводу первой формулировки
			
            Question(question: ["If you didn't provide an argument label for some parameters in an initializer, what is going to happen?",
                                "If you don’t provide argument label, this is going to happen"],
                     image: "",
                     optionA: "It will provides automatically",
                     optionB: "There will be no argument label",
                     optionC: "You will get an error",
                     optionD: "",
                     questionId: 1316,
                     helpText: "Swift provides an automatic argument label for every parameter in an initializer if you don’t provide one."),
			
            Question(question: ["Is it possible to call initializers without using argument labels, which are defined?",
                                "Can we call initializers without using argument labels, if they are defined?"],
                     image: "",
                     optionA: "No, we'll get compile-time error",
                     optionB: "Yes, it's possible",
                     optionC: "Only in required initializers",
                     optionD: "",
                     questionId: 1317,
                     helpText: "It is not possible to call initializers without using argument labels. Argument labels must always be used in an initializer if they are defined, and omitting them is a compile-time error."),
            
            Question(question: ["If you do not want to use an argument label for an initializer parameter, write this sign instead",
                                "What sign can you use, if you don't want to use an argument label for an initializer parameter?"],
                     image: "",
                     optionA: "Underscore (_)",
                     optionB: "Colon (:)",
                     optionC: "Ampersand (&)",
                     optionD: "",
                     questionId: 1318,
                     helpText: "If you do not want to use an argument label for an initializer parameter, write an underscore (_) instead of an explicit argument label for that parameter to override the default behavior."),
            
            Question(question: ["If your custom type has a stored property that is logically allowed to have no value - declare the property with this type"],
                     image: "",
                     optionA: "Optional type",
                     optionB: "String",
                     optionC: "Int",
                     optionD: "Class type",
                     questionId: 1319,
                     helpText: "If your custom type has a stored property that is logically allowed to have “no value” — perhaps because its value cannot be set during initialization, or because it is allowed to have “no value” at some later point — declare the property with an optional type. Properties of optional type are automatically initialized with a value of nil, indicating that the property is deliberately intended to have “no value yet” during initialization."),
            
            Question(question: ["Can we modify constant property after we assign a value at any point during initialization?",
                                "If we did assign a value to a constant property at any point during initialization, can it be further modified?"],
                     image: "",
                     optionA: "No",
                     optionB: "Yes",
                     optionC: "",
                     optionD: "",
                     questionId: 1320,
                     helpText: "You can assign a value to a constant property at any point during initialization, as long as it is set to a definite value by the time initialization finishes. Once a constant property is assigned a value, it can’t be further modified."),
            
            Question(question: ["At what point can constant property be modified?"],
                     image: "",
                     optionA: "During initialization",
                     optionB: "Never",
                     optionC: "At any moment",
                     optionD: "In a subclass",
                     questionId: 1321,
                     helpText: "For class instances, a constant property can be modified during initialization only by the class that introduces it. It cannot be modified by a subclass."),
            
            Question(question: ["Can the constant property be modified by a subclass?",
                                "For class instances, a constant property can be modified by a subclass. Is that true?"],
                     image: "",
                     optionA: "No",
                     optionB: "Yes",
                     optionC: "",
                     optionD: "",
                     questionId: 1322,
                     helpText: "For class instances, a constant property can be modified during initialization only by the class that introduces it. It cannot be modified by a subclass."),
            
            Question(question: ["If class provides default values for all of its properties and does not provide at least one initializer itself, what can we use?",
                                "Swift provides a ___ for any structure or class that provides default values for all of its properties and does not provide at least one initializer itself",
								"It creates a new instance with all of its properties set to their default values"],
                     image: "",
                     optionA: "Default initializer",
                     optionB: "Start initializer",
                     optionC: "Deinitializer",
                     optionD: "Starter",
                     questionId: 1323,
                     helpText: "Swift provides a default initializer for any structure or class that provides default values for all of its properties and does not provide at least one initializer itself. The default initializer simply creates a new instance with all of its properties set to their default values."),
            
            Question(question: ["What will we get after running this code?"],
                     image: "Initialization24",
                     optionA: "New instance of ShoppingListItem",
                     optionB: "Compilation error",
                     optionC: "Initialization error",
                     optionD: "",
                     questionId: 1324,
                     helpText: "Because all properties of the ShoppingListItem class have default values, and because it is a base class with no superclass, ShoppingListItem automatically gains a default initializer implementation that creates a new instance with all of its properties set to their default values. (The name property is an optional String property, and so it automatically receives a default value of nil, even though this value is not written in the code.) The example above uses the default initializer for the ShoppingListItem class to create a new instance of the class with initializer syntax, written as ShoppingListItem(), and assigns this new instance to a variable called item."),
            
            Question(question: ["A shorthand way to initialize the member properties of new structure instances",
                                "To initialize the member properties of new structure instances you can use this initializer"],
                     image: "",
                     optionA: "Memberwise initializer",
                     optionB: "Default initializer",
                     optionC: "Required initializer",
                     optionD: "Deinitializer",
                     questionId: 1325,
                     helpText: "The memberwise initializer is a shorthand way to initialize the member properties of new structure instances. Initial values for the properties of the new instance can be passed to the memberwise initializer by name."),
            
            Question(question: ["Can initializers call other initializers?",
                                "Can initializers call other initializers to perform part of an instance’s initialization?"],
                     image: "",
                     optionA: "Yes",
                     optionB: "No",
                     optionC: "",
                     optionD: "",
                     questionId: 1326,
                     helpText: "Initializers can call other initializers to perform part of an instance’s initialization. This process, known as initializer delegation, avoids duplicating code across multiple initializers."),
            
            Question(question: ["Are the rules for how initializer delegation works different for value types and class types?",
								"Are the rules for what forms of delegation are allowed, different for value types and class types?"],
                     image: "",
                     optionA: "Yes",
                     optionB: "No",
                     optionC: "",
                     optionD: "",
                     questionId: 1327,
                     helpText: "The rules for how initializer delegation works, and for what forms of delegation are allowed, are different for value types and class types. Value types (structures and enumerations) do not support inheritance, and so their initializer delegation process is relatively simple, because they can only delegate to another initializer that they provide themselves. Classes, however, can inherit from other classes, as described in Inheritance. This means that classes have additional responsibilities for ensuring that all stored properties they inherit are assigned a suitable value during initialization."),
            
            Question(question: ["If you define a custom initializer for a value type, will you have access to the default initializer?",
								"If you define a custom initializer for a value type, will you have access to the memberwise initializer (if it is a structure)?",
                                "Will you have access to the memberwise initializer, if you already define your custom initializer?"],
                     image: "",
                     optionA: "No",
                     optionB: "Yes",
                     optionC: "",
                     optionD: "",
                     questionId: 1328,
                     helpText: "Note that if you define a custom initializer for a value type, you will no longer have access to the default initializer (or the memberwise initializer, if it is a structure) for that type. This constraint prevents a situation in which additional essential setup provided in a more complex initializer is accidentally circumvented by someone using one of the automatic initializers."),
            
            Question(question: ["If you want your custom value type to be initializable with the default initializer, and also with your own custom initializers, write your custom initializers there ___",
								"If you want your custom value type to be initializable with the memberwise initializer, and also with your own custom initializers, write your custom initializers there ___"],
                     image: "",
                     optionA: "In an extension",
                     optionB: "Inside a structure",
                     optionC: "As part of original implementation",
                     optionD: "",
                     questionId: 1329,
                     helpText: "If you want your custom value type to be initializable with the default initializer and memberwise initializer, and also with your own custom initializers, write your custom initializers in an extension rather than as part of the value type’s original implementation."),
            
            Question(question: ["How will you write designated initializers for classes?",
                                "Designated initializers for classes should be written like this"],
                     image: "",
                     optionA: "init() { }",
                     optionB: "required init() { }",
                     optionC: "convenience init() { }",
                     optionD: "override init() { }",
                     questionId: 1330,
                     helpText: "Correct answer: init() { }. Designated initializers for classes are written in the same way as simple initializers for value types. Designated initializers are the primary initializers for a class. A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain."),
            
			Question(question: ["How will you write designated convenience for classes?",
								"Convenience initializers for classes should be written like this"],
                     image: "",
                     optionA: "convenience init() { }",
                     optionB: "required init() { }",
                     optionC: "init() { }",
                     optionD: "override init() { }",
                     questionId: 1331,
                     helpText: "Correct answer: convenience init() { }. Convenience initializers are secondary, supporting initializers for a class. You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializer’s parameters set to default values. You can also define a convenience initializer to create an instance of that class for a specific use case or input value type."),
            
            Question(question: ["Do you have to provide convenience initializers if your class does not require them?",
                                "If our class does not require convenience initializers, do we need to provide them?"],
                     image: "",
                     optionA: "No",
                     optionB: "Yes",
                     optionC: "",
                     optionD: "",
                     questionId: 1332,
                     helpText: "You do not have to provide convenience initializers if your class does not require them. Create convenience initializers whenever a shortcut to a common initialization pattern will save time or make initialization of the class clearer in intent."),
            
            Question(question: ["Designated initializers delegate like this",
                                "How the Designated initializers delegate?"],
                     image: "",
                     optionA: "Up",
                     optionB: "Across",
                     optionC: "Inside a class",
                     optionD: "",
                     questionId: 1333,
                     helpText: "Rule 1: A designated initializer must call a designated initializer from its immediate superclass. Rule 2: A convenience initializer must call another initializer from the same class. Rule 3: A convenience initializer must ultimately call a designated initializer. A simple way to remember this is: Designated initializers must always delegate up and Convenience initializers must always delegate across."),
            
            Question(question: ["How many convenience initializers does the superclass have?",
                                "The superclass have this many convenience initializers"],
                     image: "Initialization34",
                     optionA: "Two",
                     optionB: "One",
                     optionC: "Three",
                     optionD: "",
                     questionId: 1334,
                     helpText: "Here, the superclass has a single designated initializer and two convenience initializers. One convenience initializer calls another convenience initializer, which in turn calls the single designated initializer. The subclass in this figure has two designated initializers and one convenience initializer. The convenience initializer must call one of the two designated initializers, because it can only call another initializer from the same class."),
            
            Question(question: ["Class initialization in Swift is a ___ process"],
                     image: "",
                     optionA: "Two-phase",
                     optionB: "Three-phase",
                     optionC: "Instantenious",
                     optionD: "",
                     questionId: 1335,
                     helpText: "Class initialization in Swift is a two-phase process. In the first phase, each stored property is assigned an initial value by the class that introduced it. Once the initial state for every stored property has been determined, the second phase begins, and each class is given the opportunity to customize its stored properties further before the new instance is considered ready for use. The use of a two-phase initialization process makes initialization safe, while still giving complete flexibility to each class in a class hierarchy. Two-phase initialization prevents property values from being accessed before they are initialized, and prevents property values from being set to a different value by another initializer unexpectedly."),
            
            Question(question: ["How much helpful safety-checks Swift’s compiler performs to make sure that two-phase initialization is completed without error?",
                                "Swift’s compiler performs this much safety-checks to make sure that two-phase initialization is completed without error"],
                     image: "",
                     optionA: "Four",
                     optionB: "Three",
                     optionC: "Two",
                     optionD: "Thirteen",
                     questionId: 1336,
                     helpText: "Swift’s compiler performs four helpful safety-checks to make sure that two-phase initialization is completed without error. 1. A designated initializer must ensure that all of the properties introduced by its class are initialized before it delegates up to a superclass initializer; 2. A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property; 3. A convenience initializer must delegate to another initializer before assigning a value to any property (including properties defined by the same class); 4. An initializer cannot call any instance methods, read the values of any instance properties, or refer to self as a value until after the first phase of initialization is complete."),
            
			/// В 1337 у меня что-то вышел очень длинный ответ, если делать нормальный (initial state of all of its stored properties is known)
			/// Если сможешь как-то пересмотреть это, было бы круто. Если нет - то в целом в русской версии тоже тавтология используется
			
            Question(question: ["According to the first safety check of two-phase initialization in Swift, memory is considered fully initialized only for these objects"],
                     image: "",
                     optionA: "Fully initialized objects",
                     optionB: "Any objects",
                     optionC: "Partly initialized objects",
                     optionD: "With designated initializers",
                     questionId: 1337,
                     helpText: "The memory for an object is only considered fully initialized once the initial state of all of its stored properties is known. In order for this rule to be satisfied, a designated initializer must make sure that all of its own properties are initialized before it hands off up the chain."),
            
			Question(question: ["Which initialization phase on the image?"],
					 image: "Initialization43",
					 optionA: "Phase 2",
					 optionB: "Phase 3",
					 optionC: "Phase 1",
					 optionD: "",
					 questionId: 1343,
					 helpText: "Here’s how phase 2 looks for the same initialization call: The superclass’s designated initializer now has an opportunity to customize the instance further (although it does not have to). Once the superclass’s designated initializer is finished, the subclass’s designated initializer can perform additional customization (although again, it does not have to). Finally, once the subclass’s designated initializer is finished, the convenience initializer that was originally called can perform additional customization."),
			
            Question(question: ["If a designated initializer delegate up to a superclass initializer before assigning a value to an inherited property, what is going to happen to this value?"],
                     image: "",
                     optionA: "Will be overwritten by the superclass",
                     optionB: "Will be cast to nil",
                     optionC: "Nothing is going to happen",
                     optionD: "",
                     questionId: 1338,
                     helpText: "A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property. If it doesn’t, the new value the designated initializer assigns will be overwritten by the superclass as part of its own initialization."),
            
            Question(question: ["If a convenience initializer doesn't delegate to another initializer before assigning a value to any property, what is going to happen to this value?"],
                     image: "",
                     optionA: "It'll be overwritten by it's own class",
                     optionB: "It'll be overwritten by the superclass",
                     optionC: "Will be cast to nil",
                     optionD: "We will get an error",
                     questionId: 1339,
                     helpText: "A convenience initializer must delegate to another initializer before assigning a value to any property (including properties defined by the same class). If it doesn’t, the new value the convenience initializer assigns will be overwritten by its own class’s designated initializer."),
			
            Question(question: ["Which initialization phase is it: \"A designated or convenience initializer is called on a class, memory for a new instance of that class is allocated, but the memory is not yet initialized\"?",
                                "Which initialization phase is it: \"The designated initializer hands off to a superclass initializer to perform the same task for its own stored properties\"?"],
                     image: "",
                     optionA: "Phase one",
                     optionB: "Phase two",
                     optionC: "Phase three",
                     optionD: "This is not part of any phase",
                     questionId: 1340,
                     helpText: "Phase 1: A designated or convenience initializer is called on a class. Memory for a new instance of that class is allocated. The memory is not yet initialized. A designated initializer for that class confirms that all stored properties introduced by that class have a value. The memory for these stored properties is now initialized. The designated initializer hands off to a superclass initializer to perform the same task for its own stored properties. This continues up the class inheritance chain until the top of the chain is reached. Once the top of the chain is reached, and the final class in the chain has ensured that all of its stored properties have a value, the instance’s memory is considered to be fully initialized, and phase 1 is complete."),
            
			Question(question: ["Which initialization phase is it: \"Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further, initializers are now able to access self and can modify its properties\"?",
								"Which initialization phase is it: \"Any convenience initializers in the chain have the option to customize the instance and to work with self\"?"],
                     image: "",
                     optionA: "Phase two",
                     optionB: "Phase one",
                     optionC: "This is not part of any phase",
                     optionD: "",
                     questionId: 1341,
                     helpText: "Phase 2: Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further. Initializers are now able to access self and can modify its properties, call its instance methods, and so on. Any convenience initializers in the chain have the option to customize the instance and to work with self."),
            
            Question(question: ["Which initialization phase on the image?"],
                     image: "Initialization42",
                     optionA: "Phase 1",
                     optionB: "Phase 2",
                     optionC: "Phase 3",
                     optionD: "",
                     questionId: 1342,
                     helpText: "This is what phase-one looks like for a hypothetical subclass and superclass: Initialization begins with a call to a convenience initializer on the subclass. This convenience initializer cannot yet modify any properties. It delegates across to a designated initializer from the same class. The designated initializer makes sure that all of the subclass’s properties have a value, as per safety check 1. It then calls a designated initializer on its superclass to continue the initialization up the chain. The superclass’s designated initializer makes sure that all of the superclass properties have a value. There are no further superclasses to initialize, and so no further delegation is needed. As soon as all properties of the superclass have an initial value, its memory is considered fully initialized, and phase 1 is complete."),
	
            Question(question: ["Swift subclasses do not inherit their superclass initializers by default. Is that true?",
                                "Does Swift subclasses inherit their superclass initializers by default?",
                                "Can Swift subclasses inherit their superclass initializers by default?"],
                     image: "",
                     optionA: "Yes",
                     optionB: "No",
                     optionC: "",
                     optionD: "",
                     questionId: 1344,
                     helpText: "Unlike subclasses in Objective-C, Swift subclasses do not inherit their superclass initializers by default. Swift’s approach prevents a situation in which a simple initializer from a superclass is inherited by a more specialized subclass and is used to create a new instance of the subclass that is not fully or correctly initialized. Superclass initializers are inherited in certain circumstances, but only when it is safe and appropriate to do so."),
            
            Question(question: ["What modifier you must write when subclass initializer matches a superclass designated initializer?",
                                "You must write ___ modifier before the subclass’s initializer definition, when you write a subclass initializer that matches a superclass designated initializer"],
                     image: "",
                     optionA: "override",
                     optionB: "static",
                     optionC: "private",
                     optionD: "super",
                     questionId: 1345,
                     helpText: "If you want a custom subclass to present one or more of the same initializers as its superclass, you can provide a custom implementation of those initializers within the subclass. When you write a subclass initializer that matches a superclass designated initializer, you are effectively providing an override of that designated initializer. Therefore, you must write the override modifier before the subclass’s initializer definition. This is true even if you are overriding an automatically provided default initializer"),
            
            Question(question: ["You need to write the override modifier when providing a matching implementation of a superclass convenience initializer. Is that true?",
                                "Do we need to write the override modifier when providing a matching implementation of a superclass convenience initializer?"],
                     image: "",
                     optionA: "No",
                     optionB: "Yes",
                     optionC: "",
                     optionD: "",
                     questionId: 1346,
                     helpText: "If you write a subclass initializer that matches a superclass convenience initializer, that superclass convenience initializer can never be called directly by your subclass, as per the rules described above in Initializer Delegation for Class Types. Therefore, your subclass is not (strictly speaking) providing an override of the superclass initializer. As a result, you do not write the override modifier when providing a matching implementation of a superclass convenience initializer."),
            
            Question(question: ["Can subclasses modify inherited variable properties during initialization?",
                                "Subclasses can modify inherited variable properties during initialization. Is that true?",
								"Subclasses can not modify inherited constant properties. Is that true?"],
                     image: "",
                     optionA: "Yes",
                     optionB: "No",
                     optionC: "",
                     optionD: "",
                     questionId: 1347,
                     helpText: "Subclasses can modify inherited variable properties during initialization, but can not modify inherited constant properties."),
            
            Question(question: ["Will your subclass inherits all of its superclass designated initializers, if it doesn’t define any designated initializers itself?",
                                "If your subclass doesn’t define any designated initializers, it automatically inherits all of its superclass designated initializers. Is that true?"],
                     image: "",
                     optionA: "Yes",
                     optionB: "No",
                     optionC: "",
                     optionD: "",
                     questionId: 1348,
                     helpText: "If your subclass doesn’t define any designated initializers, it automatically inherits all of its superclass designated initializers."),
            
            Question(question: ["If your subclass provides an implementation of all of its superclass designated initializers will it inherits all of the superclass convenience initializers?"],
                     image: "",
                     optionA: "Yes",
                     optionB: "No",
                     optionC: "",
                     optionD: "",
                     questionId: 1349,
                     helpText: "If your subclass provides an implementation of all of its superclass designated initializers — either by inheriting them as per rule 1, or by providing a custom implementation as part of its definition — then it automatically inherits all of the superclass convenience initializers."),
            
            Question(question: ["Which initializer can we use, if our initialization for a class, structure, or enumeration can fail?",
                                "To define a class, structure, or enumeration for which initialization can fail, define one or more of this initializers"],
                     image: "",
                     optionA: "Failable Initializer",
                     optionB: "Required initializer",
                     optionC: "Designated initializer",
                     optionD: "Convenience initializer",
                     questionId: 1350,
                     helpText: "It is sometimes useful to define a class, structure, or enumeration for which initialization can fail. This failure might be triggered by invalid initialization parameter values, the absence of a required external resource, or some other condition that prevents initialization from succeeding. To cope with initialization conditions that can fail, define one or more failable initializers as part of a class, structure, or enumeration definition. You write a failable initializer by placing a question mark after the init keyword (init?)."),
            
            Question(question: ["Can you define a failable and a nonfailable initializer with the same parameter types and names?",
                                "You can define a failable and a nonfailable initializer with the same parameter types and names. Is that true?"],
                     image: "",
                     optionA: "No",
                     optionB: "Yes",
                     optionC: "Sometimes",
                     optionD: "",
                     questionId: 1351,
                     helpText: "You cannot define a failable and a nonfailable initializer with the same parameter types and names. A failable initializer creates an optional value of the type it initializes. You write return nil within a failable initializer to indicate a point at which initialization failure can be triggered."),
            
            Question(question: ["How you write failable initializer?"],
                     image: "",
                     optionA: "init?() { }",
                     optionB: "init()? { }",
                     optionC: "init(?) { }",
                     optionD: "",
                     questionId: 1352,
                     helpText: "To cope with initialization conditions that can fail, define one or more failable initializers as part of a class, structure, or enumeration definition. You write a failable initializer by placing a question mark after the init keyword \"init?\"."),
            
            Question(question: ["Can we use a failable initializer for enumerations?",
                                "You can use a failable initializer to select an appropriate enumeration case based on one or more parameters. Is that true?"],
                     image: "",
                     optionA: "Yes",
                     optionB: "No",
                     optionC: "",
                     optionD: "",
                     questionId: 1353,
                     helpText: "You can use a failable initializer to select an appropriate enumeration case based on one or more parameters. The initializer can then fail if the provided parameters do not match an appropriate enumeration case."),
            
            Question(question: ["Enumerations with raw values automatically receive ___ initializer"],
                     image: "",
                     optionA: "Failable",
                     optionB: "Designated",
                     optionC: "Convinience",
                     optionD: "Required",
                     questionId: 1354,
                     helpText: "Enumerations with raw values automatically receive a failable initializer, init?(rawValue:), that takes a parameter called rawValue of the appropriate raw-value type and selects a matching enumeration case if one is found, or triggers an initialization failure if no matching value exists."),
            
            Question(question: ["Can the failable initializer of a class, structure, or enumeration be delegate across to another failable initializer from the same class?",
                                "Can the subclass failable initializer be delegate up to a superclass failable initializer?"],
                     image: "",
                     optionA: "Yes",
                     optionB: "No",
                     optionC: "",
                     optionD: "",
                     questionId: 1355,
                     helpText: "A failable initializer of a class, structure, or enumeration can delegate across to another failable initializer from the same class, structure, or enumeration. Similarly, a subclass failable initializer can delegate up to a superclass failable initializer."),
            
            Question(question: ["Какой инициализатор мы будем использовать, когда нам нужно, чтобы каждый подкласс этого класса был обязан реализовать его?"],
                     image: "",
                     optionA: "Требуемый",
                     optionB: "Назначенный",
                     optionC: "Вспомогательный",
                     optionD: "Почленный",
                     questionId: 1356,
                     helpText: "Напишите required перед определением инициализатора класса, если вы хотите, чтобы каждый подкласс этого класса был обязан реализовывать этот инициализатор."),
            
            Question(question: ["What keyword indicate that every subclass of the class must implement that initializer?"],
                     image: "",
                     optionA: "required",
                     optionB: "convenience",
                     optionC: "override",
                     optionD: "",
                     questionId: 1357,
                     helpText: "Write the required modifier before the definition of a class initializer to indicate that every subclass of the class must implement that initializer."),
            
            Question(question: ["You must write the override modifier when overriding a required designated initializer. Is that true?",
                                "Do we need to write the override modifier when overriding a required designated initializer?"],
                     image: "",
                     optionA: "No",
                     optionB: "Yes",
                     optionC: "",
                     optionD: "",
                     questionId: 1358,
                     helpText: "You must also write the required modifier before every subclass implementation of a required initializer, to indicate that the initializer requirement applies to further subclasses in the chain. You do not write the override modifier when overriding a required designated initializer."),
            
            Question(question: ["Do you have to provide an explicit implementation of a required initializer if you can satisfy the requirement with an inherited initializer?",
                                "If you can satisfy the requirement with an inherited initializer, do you have to provide an explicit implementation of a required initializer?"],
                     image: "",
                     optionA: "No",
                     optionB: "Yes",
                     optionC: "",
                     optionD: "",
                     questionId: 1359,
                     helpText: "You do not have to provide an explicit implementation of a required initializer if you can satisfy the requirement with an inherited initializer."),
            
            Question(question: ["If a stored property’s default value requires some customization or setup, can you use a closure to provide a customized default value for that property?",
                                "If a stored property’s default value requires some customization or setup, can you use a global function to provide a customized default value for that property?"],
                     image: "",
                     optionA: "Yes",
                     optionB: "No",
                     optionC: "",
                     optionD: "",
                     questionId: 1360,
                     helpText: "If a stored property’s default value requires some customization or setup, you can use a closure or global function to provide a customized default value for that property. Whenever a new instance of the type that the property belongs to is initialized, the closure or function is called, and its return value is assigned as the property’s default value. These kinds of closures or functions typically create a temporary value of the same type as the property, tailor that value to represent the desired initial state, and then return that temporary value to be used as the property’s default value."),
            
            Question(question: ["Do we need to use a empty pare of parentheses after curly brace?"],
                     image: "Initialization61",
                     optionA: "Yes",
                     optionB: "No",
                     optionC: "",
                     optionD: "",
                     questionId: 1361,
                     helpText: "Note that the closure’s end curly brace is followed by an empty pair of parentheses. This tells Swift to execute the closure immediately. If you omit these parentheses, you are trying to assign the closure itself to the property, and not the return value of the closure."),
            
            Question(question: ["If you use a closure to initialize a property, can we access any other property values from within your closure?",
                                "If you use a closure to initialize a property, can you use the implicit self property, or call any of the instance’s methods?"],
                     image: "",
                     optionA: "No",
                     optionB: "Yes",
                     optionC: "",
                     optionD: "",
                     questionId: 1362,
                     helpText: "If you use a closure to initialize a property, remember that the rest of the instance has not yet been initialized at the point that the closure is executed. This means that you cannot access any other property values from within your closure, even if those properties have default values. You also cannot use the implicit self property, or call any of the instance’s methods.")
        ]
    }
}
